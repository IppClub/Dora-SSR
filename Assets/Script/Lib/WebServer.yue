_ENV = Dorothy!

HttpServer\stop!

HttpServer.wwwPath = Path Content.writablePath, ".www"

import "Utils" as :LintYueGlobals

disabledCheckForLua =
	* "incompatible number of returns"
	* "unknown variable"
	* "cannot index key .* in union"
	* "module not found"
	* "don't know how to resolve a dynamic require"
	* "ContainerItem"
	* "<any type>"
	* "<unknown type>"

yueCheck = (file, content)->
	checkResult, luaCodes = yue.checkAsync content
	info = {}
	globals = {}
	for {t, msg, line, col} in *checkResult
		switch t when "error"
			info[] = {"syntax", file, line, col, msg}
		when "global"
			globals[] = {msg, line, col}
	if luaCodes
		success, lintResult = LintYueGlobals luaCodes, globals, false
		if success
			luaCodes = luaCodes\gsub "%s*local%s*_ENV%s*=%s*Dorothy%([^%)]-%)[^\n\r]+[\n\r%s]*", "\n"
			lintResult ..= "\n" unless lintResult == ""
			luaCodes = "-- [yue]: #{file}\n#{lintResult}" .. luaCodes
		else for {name, line, col} in *lintResult
			info[] = {"syntax", file, line, col, "invalid global variable"}
	luaCodes, info

luaCheck = (file, content)->
	res, err = load content, "check"
	if not res
		line, msg = err\match ".*:(%d+):%s*(.*)"
		return success: false, info: {{"syntax", file, tonumber(line), 0, msg}}
	success, info = teal.checkAsync content, file, true
	if info
		info = for item in *info
			useCheck = true
			for check in *disabledCheckForLua
				if item[5]\match check
					useCheck = false
			continue unless useCheck
			item
		if #info == 0
			info = nil
			success = true
	return :success, :info

getCompiledYueLine = (content, line, row)->
	luaCodes, info = yueCheck "", content
	return nil unless luaCodes
	current = 1
	lastLine = 1
	targetLine = nil
	targetRow = nil
	lineMap = {}
	for lineCode in luaCodes\gmatch "[^\n\r]*"
		num = lineCode\match "--%s*(%d+)%s*$"
		lastLine = tonumber num if num
		lineMap[current] = lastLine
		if row == lastLine and not targetLine
			targetRow = current
			targetLine = line\gsub("::", "\\")\gsub(":", "=")\gsub("\\", ":")\match "[%w_%.:]+$"
			if targetLine and targetLine\match "^[%.:]"
				targetLine = lineCode\match "[%w_%.:]+[%.:]#{targetLine\sub 2, -1}"
			break if targetLine
		current += 1
	if targetLine and targetRow
		luaCodes, targetLine, targetRow
	else
		nil

HttpServer\postSchedule "/check", (req)->
	switch req when {body: {:file, :content}}
		ext = Path\getExt file
		switch ext when "tl"
			success, info = teal.checkAsync content, file, false
			return :success, :info
		when "lua"
			return luaCheck file, content
		when "yue"
			luaCodes, info = yueCheck file, content
			if luaCodes
				res = luaCheck file, luaCodes
				if not res.success
					current = 1
					lastLine = 1
					lineMap = {}
					for lineCode in luaCodes\gmatch "[^\n\r]*"
						num = lineCode\match "--%s*(%d+)%s*$"
						if num
							lastLine = tonumber num
						lineMap[current] = lastLine
						current += 1
					for item in *res.info
						item[3] = lineMap[item[3]]
						item[4] = 0
						info[] = item
			if #info == 0
				return success: true
			else
				return success: false, :info
	success: true

HttpServer\postSchedule "/infer", (req)->
	switch req when {body: {:lang, :content, :line, :row}}
		switch lang when "tl", "lua"
			infered = teal.inferAsync content, line, row
			if infered?
				return success: true, :infered
		when "yue"
			luaCodes, targetLine, targetRow = getCompiledYueLine content, line, row
			return success: false unless luaCodes
			infered = teal.inferAsync luaCodes, targetLine, targetRow
			if infered?
				:file, :row, :col = infered
				if file == "" and row > 0 and col > 0
					infered.row = lineMap[row] or 0
					infered.col = 1
				return success: true, :infered
	success: false

luaKeywords = {
	'and'
	'break'
	'do'
	'else'
	'elseif'
	'end'
	'false'
	'for'
	'function'
	'goto'
	'if'
	'in'
	'local'
	'nil'
	'not'
	'or'
	'repeat'
	'return'
	'then'
	'true'
	'until'
	'while'
}

tealKeywords = {
	'record'
	'as'
	'is'
	'type'
	'embed'
	'enum'
}

yueKeywords = {
	"and"
	"break"
	"do"
	"else"
	"elseif"
	"false"
	"for"
	"goto"
	"if"
	"in"
	"local"
	"nil"
	"not"
	"or"
	"repeat"
	"return"
	"then"
	"true"
	"until"
	"while"
	"as"
	"class"
	"continue"
	"export"
	"extends"
	"from"
	"global"
	"import"
	"macro"
	"switch"
	"try"
	"unless"
	"using"
	"when"
	"with"
}

HttpServer\postSchedule "/complete", (req)->
	switch req when {body: {:lang, :content, :line, :row}}
		switch lang when "tl", "lua"
			suggestions = teal.completeAsync content, line, row
			if not line\match("[%.:][%w_]+[%.:]?$") and not line\match "[%w_]+[%.:]$"
				for word in *luaKeywords
					suggestions[] = {word, "keyword", "keyword"}
				if lang == "tl"
					for word in *tealKeywords
						suggestions[] = {word, "keyword", "keyword"}
			if #suggestions > 0
				return success: true, :suggestions
		when "yue"
			suggestions = {}
			gotGlobals = false
			if luaCodes, targetLine, targetRow = getCompiledYueLine content, line, row
				gotGlobals = true
				suggestions[] = item for item in *teal.completeAsync luaCodes, targetLine, targetRow
				if #suggestions == 0
					suggestions[] = item for item in *teal.completeAsync luaCodes, "builtin.#{targetLine}", targetRow
			if not line\match("[%.:\\][%w_]+[%.\\]?$") and not line\match "[%w_]+[%.\\]$"
				checkSet = {name, true for {name} in *suggestions}
				for item in *teal.completeAsync "", "builtin.", 1
					suggestions[] = item if not checkSet[item[1]]
				if not gotGlobals
					for item in *teal.completeAsync "", "x", 1
						suggestions[] = item if not checkSet[item[1]]
				for word in *yueKeywords
					if not checkSet[word]
						suggestions[] = {word, "keyword", "keyword"}
			if #suggestions > 0
				return success: true, :suggestions
	success: false

HttpServer\upload(
	"/upload"
	(req, filename)->
		switch req when {params: {:path}}
			uploadPath = Path Content.writablePath, ".upload"
			if not Content\exist uploadPath
				Content\mkdir uploadPath
			targetPath = Path uploadPath, filename
			Content\mkdir Path\getPath targetPath
			return targetPath
		nil
	(req, file)->
		switch req when {params: {:path}}
			uploadPath = Path Content.writablePath, ".upload"
			targetPath = Path path, Path\getRelative file, uploadPath
			Content\mkdir Path\getPath targetPath
			if Content\move file, targetPath
				return true
		false
)

HttpServer\post "/list", (req)->
	switch req when {body: {:path}}
		if Content\exist path
			files = {}
			visitAssets = (path, folder)->
				dirs = Content\getDirs path
				for dir in *dirs
					continue if dir\match "^%."
					current = if folder == ""
						dir
					else
						Path folder, dir
					files[] = current
					visitAssets Path(path, dir), current
				fs = Content\getFiles path
				for f in *fs
					continue if f\match "^%."
					files[] = if folder == ""
						f
					else
						Path folder, f
			visitAssets path, ""
			return success: true, :files
	success: false

HttpServer\post "/info", -> platform: App.platform

HttpServer\post "/new", (req)->
	switch req when {body: {:path}}
		if not Content\exist path
			if "" == Path\getExt path
				if Content\mkdir path
					return success: true
			else if Content\save path, ""
				return success: true
	success: false

HttpServer\post "/delete", (req)->
	switch req when {body: {:path}}
		if Content\exist path
			if Content\remove path
				return success: true
	success: false

HttpServer\post "/rename", (req)->
	switch req when {body: {:old, :new}}
		if Content\exist(old) and not Content\exist new
			if Content\move old, new
				return success: true
	success: false

HttpServer\postSchedule "/read", (req)->
	switch req when {body: {:path}}
		if Content\exist path
			if content = Content\loadAsync path
				return :content, success: true
	success: false

HttpServer\postSchedule "/write", (req)->
	switch req when {body: {:path, :content}}
		if Content\saveAsync path, content
			return success: true
	success: false

HttpServer\post "/assets", ->
	visitAssets = (path)->
		children = nil
		dirs = Content\getDirs path
		for dir in *dirs
			continue if dir\match "^%."
			children = {} unless children
			children[] = visitAssets Path path, dir
		files = Content\getFiles path
		for file in *files
			continue if file\match "^%."
			children = {} unless children
			children[] = {
				key: Path path, file
				dir: false
				title: file
			}
		title = Path\getFilename path
		if title == ""
			children
		else
			{
				key: path
				dir: true
				:title
				:children
			}
	{
		key: Content.writablePath,
		dir: true,
		title: "Assets",
		children: visitAssets Content.writablePath
	}

HttpServer\postSchedule "/run", (req)->
	switch req when {body: {:file, :asProj}}
		:writablePath = Content
		if writablePath ~= file\sub 1, #writablePath
			return success: false
		if asProj
			searchPath = Path\getRelative file, writablePath
			current = searchPath
			repeat
				current = Path\getPath current
				break if current == ""
				for f in *Content\getFiles Path writablePath, current
					if Path\getName(f)\lower! == "init"
						import "Dev.Entry"
						Entry.allClear!
						f = Path\replaceExt f, ""
						target = Path writablePath, current, f
						success, err = Entry.enterEntryAsync {"Project", target}
						target = target |> Path\getPath |> Path\getName
						return :success, :target, :err
			until false
		import "Dev.Entry"
		Entry.allClear!
		file = Path\replaceExt file, ""
		success, err = Entry.enterEntryAsync {Path\getName(file), file}
		return :success, :err
	success: false

HttpServer\postSchedule "/stop", ->
	import "Dev.Entry"
	success: Entry.stop!

HttpServer\postSchedule "/zip", (req)->
	switch req when {body: {:path, :zipFile}}
		Content\mkdir Path\getPath zipFile
		return success: Content\zipAsync zipFile, path
	success: false

thread ->
	doraWeb = Path Content.assetPath, "www", "index.html"
	doraReady = Path Content.writablePath, ".www", "dora-ready"
	if Content\exist(doraWeb) and not Content\exist doraReady
		Content\remove Path Content.writablePath, ".www"
		Content\copyAsync(
			Path Content.assetPath, "www"
			Path Content.writablePath, ".www"
		)
		Content\save doraReady, ""
		print "dora-dora is ready!"
	if HttpServer\start 8866
		:localIP = HttpServer
		localIP = "localhost" if localIP == ""
		print "server started at http://#{localIP}:8866"
	else
		print "port not available!"
