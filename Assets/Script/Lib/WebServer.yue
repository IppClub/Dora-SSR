_ENV = Dorothy!

HttpServer.wwwPath = Path Content.writablePath, ".www"

HttpServer\post "/infer", (req)->
	switch req when {body: {:lang, :content, :line, :row}}
		switch lang when "tl", "lua"
			infered = teal.infer content, line, row
			if infered?
				return success: true, :infered
	success: false

HttpServer\post "/complete", (req)->
	switch req when {body: {:lang, :content, :line, :row}}
		switch lang when "tl", "lua"
			suggestions = teal.complete content, line, row
			if #suggestions > 0
				return success: true, :suggestions
	success: false

lintYueGlobals = (luaCodes, info, file)->
	luaCodes = luaCodes\gsub "^local _module_[^\r\n]*[^\r\n]+", ""
	importCodes = luaCodes\match "^%s*local%s*_ENV%s*=%s*Dorothy%(([^%)]-)%)"
	importItems = if importCodes
		for item in importCodes\gmatch "%s*([^,\n\r]+)%s*"
			getImport = load "return #{item}"
			importItem = getImport?!
			continue if not importItem or "table" ~= type importItem
			importItem
	else {}
	importItems[] = _G
	return for {t, msg, line, col} in *info
		continue unless t == "global"
		findModule = false
		if importCodes
			if builtin[msg]
				findModule = true
			else for i, importItem in ipairs importItems
				if importItem[msg]?
					findModule = true
					break
		continue if findModule
		{"syntax", file, line, col, "invalid global variable"}

disabledCheckForLua =
	* "incompatible number of returns"
	* "unknown variable"
	* "cannot index key .* in union"
	* "module not found"

HttpServer\post "/check", (req)->
	switch req when {body: {:file, :content}}
		ext = Path\getExt file
		switch ext when "tl"
			success, info = teal.check content, file, false
			return :success, :info
		when "lua"
			res, err = load content, "check"
			if not res
				line, msg = err\match ".*:(%d+):%s*(.*)"
				return success: false, info: {{"syntax", file, tonumber(line), 0, msg}}
			success, info = teal.check content, file, true
			if info
				info = for item in *info
					useCheck = true
					for check in *disabledCheckForLua
						if item[5]\match check
							useCheck = false
					continue unless useCheck
					item
			return :success, :info
		when "yue"
			res, codes = yue.check content
			info = for {t, msg, line, col} in *res
				continue unless t == "error"
				{"syntax", file, line, col, msg}
			if codes
				globals = lintYueGlobals codes, res, file
				for item in *globals
					info[] = item
			if #info == 0
				return success: true
			else
				return success: false, :info
	success: true

HttpServer\upload(
	"/upload"
	(req, filename)->
		switch req when {params: {:path}}
			uploadPath = Path Content.writablePath, ".upload"
			if not Content\exist uploadPath
				Content\mkdir uploadPath
			return Path uploadPath, filename
		nil
	(req, file)->
		switch req when {params: {:path}}
			target = Path path, Path\getFilename file
			if Content\move file, target
				return true
		false
)

HttpServer\post "/list", (req)->
	switch req when {body: {:path}}
		if Content\exist path
			files = {}
			visitAssets = (path, folder)->
				dirs = Content\getDirs path
				for dir in *dirs
					continue if dir\match "^%."
					current = if folder == ""
						dir
					else
						Path folder, dir
					files[] = current
					visitAssets Path(path, dir), current
				fs = Content\getFiles path
				for f in *fs
					continue if f\match "^%."
					files[] = if folder == ""
						f
					else
						Path folder, f
			visitAssets path, ""
			return success: true, :files
	success: false

HttpServer\post "/info", -> platform: App.platform

HttpServer\post "/new", (req)->
	switch req when {body: {:path}}
		if not Content\exist path
			if "" == Path\getExt path
				if Content\mkdir path
					return success: true
			else if Content\save path, ""
				return success: true
	success: false

HttpServer\post "/delete", (req)->
	switch req when {body: {:path}}
		if Content\exist path
			if Content\remove path
				return success: true
	success: false

HttpServer\post "/rename", (req)->
	switch req when {body: {:old, :new}}
		if Content\exist(old) and not Content\exist new
			if Content\move old, new
				return success: true
	success: false

HttpServer\post "/read", (req)->
	switch req when {body: {:path}}
		if Content\exist path
			if content = Content\load path
				return :content, success: true
	success: false

HttpServer\post "/write", (req)->
	switch req when {body: {:path, :content}}
		if Content\save path, content
			return success: true
	success: false

HttpServer\post "/assets", ->
	visitAssets = (path)->
		children = nil
		dirs = Content\getDirs path
		for dir in *dirs
			continue if dir\match "^%."
			children = {} unless children
			children[] = visitAssets Path path, dir
		files = Content\getFiles path
		for file in *files
			continue if file\match "^%."
			children = {} unless children
			children[] = {
				key: Path path, file
				dir: false
				title: file
			}
		title = Path\getFilename path
		if title == ""
			children
		else
			{
				key: path
				dir: true
				:title
				:children
			}
	{
		key: Content.writablePath,
		dir: true,
		title: "Assets",
		children: visitAssets Content.writablePath
	}

if HttpServer\start 8866
	print "server started at 8866!"
else
	print "port not available!"

Director.entry\slot "Cleanup", -> HttpServer\stop!
