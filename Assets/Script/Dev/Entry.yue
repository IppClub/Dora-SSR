_ENV = Dorothy builtin.ImGui

moduleCache = {}
oldRequire = _G.require
require = (path)->
	loaded = package.loaded[path]
	if loaded == nil
		table.insert moduleCache, path
		return oldRequire path
	loaded
_G.require = require
builtin.require = require

import "Utils" as :Set, :Struct
import "yue" as options: {extension: yueext}, compile: yuecompile

print "Dorothy SSR #{App.version}#{App.debugging and ', debugging' or ''}"

LoadFontTTF "Font/sarasa-mono-sc-regular.ttf", 20, "Chinese"

allowedUseOfGlobals = Set
	* "Dorothy"
	* "builtin"
	* "require"

LintYueGlobals = (yueCodes, globals, file)->
	errors = {}
	requireModules = {}
	withImGui = false
	withPlatformer = false
	importCodes = table.concat (
		for importLine in yueCodes\gmatch "Dorothy%s*%(?([^%)!\r\n]*)%s*[%)!]?"
			continue if importLine == ""
			importLine
	), ","
	importItems = if importCodes
		for item in importCodes\gmatch "%s*([^,\n\r]+)%s*"
			getImport = load "return #{item}"
			importItem = getImport?!
			continue if not importItem or "table" ~= type importItem
			{importItem, item}
	else {}
	importSet = {}
	for {name, line, col} in *globals
		if not allowedUseOfGlobals[name]
			if builtin[name]
				requireModules[] = "local #{name} = require(\"#{name}\") -- 1"
			else
				findModule = false
				for i, importItem in ipairs importItems
					if importItem[1][name]?
						moduleName = "_module_#{i-1}"
						if not importSet[importItem[1]]
							importSet[importItem[1]] = true
							requireModules[] = "local #{moduleName} = #{importItem[2]} -- 1"
						requireModules[] = "local #{name} = #{moduleName}.#{name} -- 1"
						findModule = true
						break
				if not findModule
					countLine = 1
					code = ""
					codes = Content\load file
					for lineCode in codes\gmatch "[^\r\n]*"
						if countLine == line
							code = lineCode
							break
						countLine += 1
					errors[] = "Used invalid global variable \"#{name}\"\nin \"#{file}\", at line #{line}, col #{col}.\n#{code\gsub("\t", " ") .. '\n' .. string.rep(" ", col - 1) .. "^"}"
	if #errors > 0
		false, table.concat errors, "\n"
	else
		true, table.concat requireModules, "\n"

building = false

getAllFiles = (path, exts)->
	filters = Set exts
	return for file in *Content\getAllFiles path
		continue if not filters[Path\getExt file]
		file

doCompile = (minify)->
	return if building
	building = true
	startTime = App.runningTime
	luaFiles = {}
	yueFiles = {}
	xmlFiles = {}
	tlFiles = {}
	for {inputPath, outputPath} in *{
			{
				Path Content.assetPath
				Path Content.writablePath, "Build"
			}
			{
				Path Content.writablePath, "Production"
				Path Content.writablePath, "Build", "Production"
			}
		}
		continue unless Content\exist inputPath

		for file in *getAllFiles inputPath, {"lua"}
			luaFiles[] =
				* file
				* Path inputPath, file
				* Path outputPath, file

		for file in *getAllFiles inputPath, {yueext}
			yueFiles[] =
				* file
				* Path inputPath, file
				* Path outputPath, Path\replaceExt file, "lua"

		for file in *getAllFiles inputPath, {"xml"}
			xmlFiles[] =
				* file
				* Path inputPath, file
				* Path outputPath, Path\replaceExt file, "lua"

		for file in *getAllFiles inputPath, {"tl"}
			if not file\match ".*%.d%.tl$"
				tlFiles[] =
					* file
					* Path inputPath, file
					* Path outputPath, Path\replaceExt file, "lua"

	paths = {Path\getPath(file[3]), true \
		for files in *{luaFiles, yueFiles, xmlFiles, tlFiles} \
		for file in *files}

	Content\mkdir path for path in pairs paths

	totalFiles = #yueFiles + #xmlFiles + #tlFiles
	fileCount = 0
	errors = {}
	for {file, input, output} in *yueFiles
		(success) <- yuecompile input, output, (codes, err, globals)->
			if not codes
				table.insert errors, "Compile errors in #{file}.\n#{err}"
				return
			success, result = LintYueGlobals codes, globals, file
			if success
				result ..= "\n" unless result == ""
				"-- [yue]: #{file}\n#{result}" .. codes\gsub "local%s*_ENV%s*=%s*Dorothy%([^%)]*%)[^\r\n]*[\r\n]*",""
			else
				table.insert errors, result
				return
		print "Yue compiled: #{file}" if success
		fileCount += 1

	thread ->
		for {file, input, output} in *xmlFiles
			sourceCodes = Content\loadAsync input
			codes, err = xmltolua sourceCodes
			if not codes
				table.insert errors, "Compile errors in #{file}.\n#{err}"
			else
				Content\saveAsync output, "-- [xml]: #{file}\n#{codes}"
				print "Xml compiled: #{file}"
			fileCount += 1

	thread ->
		for {file, input, output} in *tlFiles
			sourceCodes = Content\loadAsync input
			moduleName = file\gsub("%.tl$", "")\gsub "[\\/]", "."
			codes, err = teal.tolua sourceCodes, moduleName
			if not codes
				table.insert errors, "Compile errors in #{file}.\n#{err}"
			else
				Content\saveAsync output, codes
				print "Teal compiled: #{file}"
			fileCount += 1

	thread ->
		wait -> fileCount == totalFiles
		if minify
			for files in *{yueFiles, xmlFiles, tlFiles} do for file in *files
				output = Path\replaceExt file[3], "lua"
				luaFiles[] =
					* Path\replaceExt file[1], "lua"
					* output
					* output

			import "luaminify.FormatMini"
			for {file, input, output} in *luaFiles
				if Content\exist input
					sourceCodes = Content\loadAsync input
					res, err = FormatMini sourceCodes
					if res
						Content\saveAsync output, res
						print "Minify: #{file}"
					else
						table.insert errors, "Minify errors in #{file}.\n#{err}"
				else
					table.insert errors, "Minify errors in #{file}.\nTarget file is not exist!"
			package.loaded["luaminify.FormatMini"] = nil
			package.loaded["luaminify.ParseLua"] = nil
			package.loaded["luaminify.Scope"] = nil
			package.loaded["luaminify.Util"] = nil
		print err for err in *errors
		builtFiles = totalFiles + (minify and #luaFiles or 0) - #errors
		print "\n#{builtFiles} #{builtFiles == 1 and 'file' or 'files'} built! Cost #{string.format '%.2f', App.runningTime - startTime}s"
		print "#{#errors} #{#errors == 1 and 'file fails' or 'files fail'} to build."
		Content\clearPathCache!
		teal.reset!
		building = false

doClean = ->
	return if building
	targetDir = Path Content.writablePath, "Build"
	cleaned = false
	Content\clearPathCache!
	if Content\remove targetDir
		cleaned = true
		print "Cleaned: #{targetDir}"
	if not cleaned
		print "Nothing to clean."

screenScale = 2 -- App.deviceRatio
scaleContent = false
isInEntry = true
currentEntryName = nil

footerWindow = nil
entryWindow = nil

allClear = ->
	for routine in *Routine
		switch routine
			when footerWindow, entryWindow
				continue
			else
				Routine\remove routine
	for module in *moduleCache
		package.loaded[module] = nil
	moduleCache = {}
	Director\cleanup!
	Cache\unload!
	Entity\clear!
	Platformer.Data\clear!
	Platformer.UnitAction\clear!
	currentEntryName = nil
	isInEntry = true
	Audio\stopStream 0.2
	Struct\clear!
	View.postEffect = nil
	View.scale = scaleContent and screenScale or 1
	Director.clearColor = Color 0xff1a1a1a
	teal.reset!
	collectgarbage!
	collectgarbage!

games = [Path\getName item for item in *Content\getDirs Path Content.assetPath, "Script", "Game"]
table.sort games
examples = [Path\getName item for item in *getAllFiles Path(Content.assetPath, "Script", "Example"), {"xml", "lua", yueext, "tl"}]
table.sort examples
tests = [Path\getName item for item in *getAllFiles Path(Content.assetPath, "Script", "Test"), {"xml", "lua", yueext, "tl"}]
table.sort tests
allNames = [Path "Game", game, "init" for game in *games]
for example in *examples do table.insert allNames, Path "Example", example
for test in *tests do table.insert allNames, Path "Test", test
cppTests = App.testNames
allNames[] = name for name in *cppTests
cppTestSet = Set cppTests

productionEntries = {}
productionTests = nil
locateProduction = (searchPath)->
	return false unless Content\exist Path searchPath, "Production"
	for file in *Content\getAllFiles Path searchPath, "Production"
		if "yue" == Path\getExt(file) and "init" == Path\getName file
			scriptFolder = Path\getPath Path searchPath, "Production", file
			productionAssets = Path\getPath scriptFolder
			for path in *{
					productionAssets
					Path productionAssets, "Script"
					Path productionAssets, "Spine"
					Path productionAssets, "Image"
					Path productionAssets, "Font"
					productionAssets
					Path productionAssets, "Script"
					Path productionAssets, "Spine"
					Path productionAssets, "Image"
					Path productionAssets, "Font"
				}
				Content\insertSearchPath 1, path
			productionTests = [Path\getName f for f in *Content\getAllFiles Path productionAssets, "Test"]
			package.path = Path(scriptFolder, "?.lua") .. ";" .. package.path
			productionEntries[] = Path scriptFolder, "init.yue"
			scriptFolder = Path\getPath Path Content.writablePath, "Build", "Production", file
			productionAssets = Path\getPath scriptFolder
			Content\insertSearchPath 1, productionAssets
			Content\insertSearchPath 1, scriptFolder
			package.path = Path(scriptFolder, "?.lua") .. ";" .. package.path
			productionEntries[] = Path scriptFolder, "init.lua"
			return true
	false

unless locateProduction Content.writablePath
	locateProduction Content.assetPath

enterDemoEntry = (name)->
	isInEntry = false
	currentEntryName = name
	if cppTestSet[name]
		App\runTest name
		return
	<- thread
	try
		result = require name
		if "function" == type result
			result = result!
			Director.entry\addChild if tolua.cast result, "Node"
				result
			else
				Node!
		else
			Director.entry\addChild Node!
	catch msg
		print debug.traceback msg
		allClear!

reloadCurrentEntry = ->
	if currentEntryName
		targetName = currentEntryName
		allClear!
		enterDemoEntry targetName

showEntry = false

thread ->
	unless App.debugging
		:width, :height = App.visualSize
		scale = App.deviceRatio * 0.7 * math.min(width, height) / 760
		with Sprite nvg.GetDorothySSRHappyWhite scale
			\addTo Director.entry
			sleep 1.0
			\removeFromParent!
	showEntry = true
	Director.clearColor = Color 0xff1a1a1a

enterProduct = ->
	return if currentEntryName
	for i = #productionEntries, 1, -1
		entry = productionEntries[i]
		if Content\exist entry
			enterDemoEntry Path\replaceExt entry, ""
			break

showStats = true
showConsole = true
showFooter = false
windowFlags =
	* "NoTitleBar"
	* "NoResize"
	* "NoMove"
	* "NoCollapse"
	* "NoSavedSettings"
	* "NoBringToFrontOnFocus"
initFooter = true
footerWindow = threadLoop ->
	App\shutdown! if Keyboard\isKeyDown "Escape"
	do
		ctrl = Keyboard\isKeyPressed "LCtrl"
		allClear! if ctrl and Keyboard\isKeyDown "Q"
		if ctrl and Keyboard\isKeyDown "Z"
			reloadCurrentEntry!
		if ctrl and Keyboard\isKeyDown ","
			showFooter = true
			showStats = not showStats
		if ctrl and Keyboard\isKeyDown "."
			showFooter = true
			showConsole = not showConsole
		if ctrl and Keyboard\isKeyDown "/"
			showFooter = not showFooter
		if ctrl and Keyboard\isKeyDown "R"
			enterProduct!
		left = ctrl and Keyboard\isKeyDown "Left"
		right = ctrl and Keyboard\isKeyDown "Right"
		currentIndex = nil
		for i, name in ipairs allNames
			if currentEntryName == name
				currentIndex = i
		if left
			allClear!
			currentIndex ??= #allNames + 1
			if currentIndex > 1
				enterDemoEntry allNames[currentIndex - 1]
		if right
			allClear!
			currentIndex ??= 0
			if currentIndex < #allNames
				enterDemoEntry allNames[currentIndex + 1]
	return unless showEntry
	:width, :height = App.visualSize
	SetNextWindowSize Vec2 200, 50
	SetNextWindowPos if width >= 600
		Vec2 width - 200, height - 50
	else
		Vec2 width, height
	PushStyleColor "WindowBg", Color(0x0), -> Begin "Show", windowFlags, ->
		if width >= 600
			Columns 2, false
			if showFooter
				changed, scaleContent = Checkbox string.format("%.1fx", screenScale), scaleContent
				View.scale = scaleContent and screenScale or 1 if changed
			else
				Dummy Vec2 10, 30
			SameLine!
			NextColumn!
			_, showFooter = Checkbox "Footer", showFooter
	if initFooter
		initFooter = false
	else
		return unless showFooter

	SetNextWindowSize Vec2 width, 50
	SetNextWindowPos Vec2 0, height - 50
	SetNextWindowBgAlpha 0.35
	PushStyleVar "WindowPadding", Vec2(10, 0), -> Begin "Footer", windowFlags, ->
		Separator!
		_, showStats = Checkbox "Stats", showStats
		SameLine!
		_, showConsole = Checkbox "Log", showConsole
		SameLine!
		if isInEntry
			OpenPopup "build" if Button "Build", Vec2 70, 30
			PushStyleVar "WindowPadding", Vec2(10, 10), -> BeginPopup "build", ->
				doCompile false if Selectable "Compile"
				Separator!
				doCompile true if Selectable "Minify"
				Separator!
				doClean! if Selectable "Clean"
			SameLine!
			if Button "Reload", Vec2 70, 30
				doClean!
				allClear!
				_G.require = oldRequire
				builtin.require = oldRequire
				package.loaded["Dev.Entry"] = nil
				Content.searchPaths =
					* Path Content.writablePath, "Build", "Script"
					* Path Content.writablePath, "Build", "Script", "Lib"
					* "Script"
					* Path "Script", "Lib"
					* Path "Script", "Lib", "Dora"
				Director.systemScheduler\schedule ->
					Routine\clear!
					oldRequire "Dev.Entry"
					true
		else
			SameLine!
			allClear! if Button "Home", Vec2 70, 30
			currentIndex = nil
			for i, name in ipairs allNames
				if currentEntryName == name
					currentIndex = i
			if currentIndex
				if currentIndex > 1
					SameLine!
					if Button("Prev", Vec2 70, 30)
						allClear!
						enterDemoEntry allNames[currentIndex - 1]
				if currentIndex < #allNames
					SameLine!
					if Button("Next", Vec2 70, 30)
						allClear!
						enterDemoEntry allNames[currentIndex + 1]
			SameLine!
			if Button "Reload", Vec2 70, 30
				reloadCurrentEntry!
		PushStyleVar "WindowPadding", Vec2(10, 10), ->
			if showStats
				SetNextWindowPos Vec2(10, 10), "FirstUseEver"
				ShowStats!
			if showConsole
				SetNextWindowPos Vec2(width - 400, height - 365), "FirstUseEver"
				ShowConsole!

cyan = Color 0xff00ffff
entryWindow = threadLoop ->
	return unless showEntry
	return unless isInEntry
	:width, :height = App.visualSize
	SetNextWindowPos Vec2.zero
	SetNextWindowSize Vec2 width, 45
	SetNextWindowBgAlpha 0.35
	PushStyleVar "WindowPadding", Vec2(10, 0), ->
		Begin "Dorothy Dev", windowFlags, ->
			Dummy Vec2 width - 20, 5
			TextColored cyan, "DOROTHY SSR DEV"
			Separator!
	SetNextWindowPos Vec2 0, 45
	SetNextWindowSize Vec2 width, height - 95
	PushStyleColor "WindowBg", Color(0x0), ->
		Begin "Content", windowFlags, ->
			TextColored cyan, "Game Demos"
			Columns math.max(math.floor(width / 200), 1), false
			for game in *games
				if Button game, Vec2 -1, 40
					enterDemoEntry Path "Game", game, "init"
				NextColumn!
			Columns 1, false
			TextColored cyan, "Examples"
			Columns math.max(math.floor(width / 200), 1), false
			for example in *examples
				if Button example, Vec2 -1, 40
					enterDemoEntry Path "Example", example
				NextColumn!
			Columns 1, false
			TextColored cyan, "Tests"
			Columns math.max(math.floor(width / 200), 1), false
			for test in *tests
				if Button test, Vec2 -1, 40
					enterDemoEntry Path "Test", test
				NextColumn!
			for test in *cppTests
				if Button test, Vec2 -1, 40
					enterDemoEntry test
				NextColumn!
			if #productionEntries > 0
				Columns 1, false
				TextColored cyan, "Product"
				Columns math.max(math.floor(width / 200), 1), false
				enterProduct! if Button "Enter", Vec2 -1, 40
				NextColumn!
				if productionTests and #productionTests > 0
					Columns 1, false
					TextColored cyan, "Product Test"
					Columns math.max(math.floor(width / 200), 1), false
					for test in *productionTests
						if Button test, Vec2 -1, 40
							enterDemoEntry Path "Test", test
						NextColumn!
			Columns 1, false
			Dummy Vec2 100, 40

require "WebServer"
