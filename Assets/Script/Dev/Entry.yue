_ENV = Dorothy builtin.ImGui
import "Utils" as :Set
import "yue" as options: {extension: yueext}

print "Dorothy SSR #{App.version}#{App.debugging and ', debugging' or ''}"

LoadFontTTF "Font/sarasa-mono-sc-regular.ttf", 18, "Chinese"

moduleCache = {}
oldRequire = _G.require
require = (path)->
	loaded = package.loaded[path]
	if loaded == nil
		table.insert moduleCache, path
		return oldRequire path
	loaded
_G.require = require
builtin.require = require

allowedUseOfGlobals = Set
	* "Dorothy"
	* "builtin"

LintYueGlobals = (yueCodes, globals, file)->
	requireModules = {}
	withImGui = false
	withPlatformer = false
	importCodes = table.concat (
		for importLine in yueCodes\gmatch "Dorothy%s*%(?([^%)!\r\n]*)%s*[%)!]?"
			continue if importLine == ""
			importLine
	), ","
	importItems = if importCodes
		for item in importCodes\gmatch "%s*([^,\n\r]+)%s*"
			getImport = load "return #{item}"
			importItem = getImport?!
			continue if not importItem or "table" ~= type importItem
			{importItem, item}
	else {}
	importSet = {}
	for var in *globals
		{name, line, col} = var
		if not allowedUseOfGlobals[name]
			if builtin[name]
				table.insert requireModules, "local #{name} = require(\"#{name}\") -- 1"
			else
				findModule = false
				for i, importItem in ipairs importItems
					if importItem[1][name]?
						moduleName = "_module_#{i-1}"
						if not importSet[importItem[1]]
							importSet[importItem[1]] = true
							table.insert requireModules, "local #{moduleName} = #{importItem[2]} -- 1"
						table.insert requireModules, "local #{name} = #{moduleName}.#{name} -- 1"
						findModule = true
						break
				if not findModule
					countLine = 1
					code = nil
					codes = Content\load file
					for lineCode in codes\gmatch "[^\n]*\n"
						if countLine == line
							code = lineCode
							break
						countLine += 1
					print "Used invalid global value \"#{name}\"\nin \"#{file}\", at line #{line}, col #{col}.\n#{code\gsub("\t", " ") .. string.rep(" ", col - 1) .. "^"}"
	table.concat requireModules, "\n"

building = false

getAllFiles = (path, exts)->
	filters = Set exts
	return for file in *Content\getAllFiles path
		continue if not filters[Path\getExt file]
		file

doCompile = (minify)->
	return if building
	building = true
	startTime = App.runningTime
	inputPath = Path Content.assetPath
	outputPath = Path Content.writablePath
	yueFiles = getAllFiles inputPath, {yueext}
	xmlFiles = getAllFiles inputPath, {"xml"}
	tlFiles = getAllFiles inputPath, {"tl"}
	tlFiles = [file for file in *tlFiles when not file\match ".*%.d%.tl$"]
	paths = {Path\getPath(file), true for file in *yueFiles}
	Content\mkdir Path outputPath, path for path in pairs paths
	totalFiles = #yueFiles + #xmlFiles + #tlFiles
	fileCount = 0
	errors = {}
	for file in *yueFiles
		dest = Path\replaceExt Path(outputPath, file), "lua"
		<- yuecompile Path(inputPath, file), dest, (codes, err, globals)->
			if not codes
				table.insert errors, "Compile errors in #{file}.\n#{err}"
				fileCount += 1
				return
			requires = LintYueGlobals codes, globals, file
			requires ..= "\n" unless requires == ""
			"-- [yue]: #{file}\n#{requires}" .. codes\gsub "local%s*_ENV%s*=%s*Dorothy%([^%)]*%)[^\r\n]*[\r\n]*",""
		print "Yue compiled: #{file}"
		fileCount += 1
	paths = {Path\getPath(file), true for file in *xmlFiles}
	Content\mkdir Path outputPath, path for path in pairs paths
	thread ->
		for file in *xmlFiles
			dest = Path\replaceExt Path(outputPath, file), "lua"
			sourceCodes = Content\loadAsync Path(inputPath, file)
			codes, err = xmltolua sourceCodes
			if not codes
				table.insert errors, "Compile errors in #{file}.\n#{err}"
			else
				Content\saveAsync dest, "-- [xml]: #{file}\n#{codes}"
				print "Xml compiled: #{file}"
			fileCount += 1
	paths = {Path\getPath(file), true for file in *tlFiles}
	Content\mkdir Path outputPath, path for path in pairs paths
	thread ->
		for file in *tlFiles
			dest = Path\replaceExt Path(outputPath, file), "lua"
			sourceCodes = Content\loadAsync Path(inputPath, file)
			moduleName = file\gsub("%.tl$", "")\gsub "[\\/]", "."
			codes, err = tealtolua sourceCodes, moduleName
			if not codes
				table.insert errors, "Compile errors in #{file}.\n#{err}"
			else
				Content\saveAsync dest, codes
				print "Teal compiled: #{file}"
			fileCount += 1
	thread ->
		wait -> fileCount == totalFiles
		if minify
			inputPath = Path Content.assetPath
			outputPath = Path Content.writablePath
			luaFiles = getAllFiles inputPath, {"lua"}
			luaFullPaths = [Path inputPath, file for file in *luaFiles]
			for file in *getAllFiles outputPath, {"lua"}
				table.insert luaFiles, file
				table.insert luaFullPaths, Path outputPath, file
			paths = {Path\getPath(file), true for file in *luaFiles}
			Content\mkdir Path outputPath, path for path in pairs paths
			import "luaminify.FormatMini"
			for i = 1, #luaFullPaths
				sourceCodes = Content\loadAsync luaFullPaths[i]
				res, err = FormatMini sourceCodes
				file = luaFiles[i]
				if res
					Content\saveAsync Path(outputPath, file), res
					print "Minify: #{file}"
				else
					table.insert errors, "Minify errors in #{file}.\n#{err}"
			package.loaded["luaminify.FormatMini"] = nil
			package.loaded["luaminify.ParseLua"] = nil
			package.loaded["luaminify.Scope"] = nil
			package.loaded["luaminify.Util"] = nil
		print err for err in *errors
		print "Build complete! Cost #{string.format '%.2f', App.runningTime - startTime}s"
		Content\clearPathCache!
		building = false

doClean = ->
	return if building
	targetDir = Path Content.writablePath, "Script"
	cleaned = false
	if Content\remove targetDir
		cleaned = true
		print "Cleaned: #{targetDir}"
	targetDir = Path Content.writablePath, "Production"
	if Content\remove targetDir
		cleaned = true
		print "Cleaned: #{targetDir}"
	if not cleaned
		print "Nothing to clean."

isInEntry = true
currentEntryName = nil

allClear = ->
	for module in *moduleCache
		package.loaded[module] = nil
	moduleCache = {}
	with Director.ui3D
		\removeAllChildren!
		.data\clear!
	with Director.ui
		\removeAllChildren!
		.data\clear!
	with Director.entry
		\removeAllChildren!
		.data\clear!
	with Director.postNode
		\removeAllChildren!
		.data\clear!
	Director\popCamera!
	Cache\unload!
	Entity\clear!
	Platformer.Data\clear!
	Platformer.UnitAction\clear!
	currentEntryName = nil
	isInEntry = true
	Audio\stopStream 0.2
	collectgarbage!

games = [Path\getName item for item in *Content\getDirs Path Content.assetPath, "Script", "Game"]
table.sort games
examples = [Path\getName item for item in *getAllFiles Path(Content.assetPath, "Script", "Example"), {"xml", "lua", yueext, "tl"}]
table.sort examples
tests = [Path\getName item for item in *getAllFiles Path(Content.assetPath, "Script", "Test"), {"xml", "lua", yueext, "tl"}]
table.sort tests
allNames = [Path "Game", game, "init" for game in *games]
for example in *examples do table.insert allNames, Path "Example", example
for test in *tests do table.insert allNames, Path "Test", test

productionEntry = nil
productionTests = nil
for file in *Content\getAllFiles Path Content.assetPath, "Production"
	if "init" == Path\getName file
		scriptFolder = Path\getPath Path Content.assetPath, "Production", file
		productionAssets = Path\getPath scriptFolder
		Content\insertSearchPath 1, productionAssets
		Content\insertSearchPath 1, Path productionAssets, "Spine"
		Content\insertSearchPath 1, Path productionAssets, "Image"
		Content\insertSearchPath 1, Path productionAssets, "Font"
		productionTests = [Path\getName f for f in *Content\getAllFiles Path productionAssets, "Test"]
		package.path = Path(scriptFolder, "?.lua") .. ";" .. package.path
		productionEntry = Path scriptFolder, "init"
		scriptFolder = Path\getPath Path Content.writablePath, "Production", file
		productionAssets = Path\getPath scriptFolder
		Content\insertSearchPath 1, productionAssets
		package.path = Path(scriptFolder, "?.lua") .. ";" .. package.path
		if Content\exist Path scriptFolder, "init.lua"
			productionEntry = Path scriptFolder, "init.lua"
		break

enterDemoEntry = (name)->
	isInEntry = false
	<- thread
	(msg)<- xpcall ->
		result = require name
		if "function" == type result
			result = result!
			Director.entry\addChild if tolua.cast result, "Node"
				result
			else
				Node!
		else
			Director.entry\addChild Node!
		currentEntryName = name
	print debug.traceback msg
	allClear!

showEntry = false

thread ->
	unless App.debugging
		:width, :height = App.visualSize
		scale = App.deviceRatio * 0.7 * math.min(width, height) / 760
		with Sprite GetDorothySSRHappyWhite scale
			\addTo Director.entry
			sleep 1.0
			\removeFromParent!
	showEntry = true
	Director.clearColor = Color 0xff1a1a1a

showStats = true
showConsole = true
showFooter = false
scaleContent = false
screenScale = 2 -- App.deviceRatio
windowFlags =
	* "NoTitleBar"
	* "NoResize"
	* "NoMove"
	* "NoCollapse"
	* "NoSavedSettings"
	* "NoBringToFrontOnFocus"
initFooter = true
threadLoop ->
	App\shutdown! if Keyboard\isKeyDown "Escape"
	do
		ctrl = Keyboard\isKeyPressed "LCtrl"
		allClear! if ctrl and Keyboard\isKeyDown "Q"
		if currentEntryName and ctrl and Keyboard\isKeyDown "Z"
			targetName = currentEntryName
			allClear!
			enterDemoEntry targetName
		if ctrl and Keyboard\isKeyDown ","
			showFooter = true
			showStats = not showStats
		if ctrl and Keyboard\isKeyDown "."
			showFooter = true
			showConsole = not showConsole
		if ctrl and Keyboard\isKeyDown "/"
			showFooter = not showFooter
		left = ctrl and Keyboard\isKeyDown "Left"
		right = ctrl and Keyboard\isKeyDown "Right"
		currentIndex = nil
		for i, name in ipairs allNames
			if currentEntryName == name
				currentIndex = i
		if left
			allClear!
			currentIndex ??= #allNames + 1
			if currentIndex > 1
				isInEntry = false
				enterDemoEntry allNames[currentIndex - 1]
		if right
			allClear!
			currentIndex ??= 0
			if currentIndex < #allNames
				isInEntry = false
				enterDemoEntry allNames[currentIndex + 1]
	return unless showEntry
	:width, :height = App.visualSize
	SetNextWindowSize Vec2 190, 50
	SetNextWindowPos Vec2 width - 190, height - 50
	if width >= 600
		PushStyleColor "WindowBg", Color(0x0), -> Begin "Show", windowFlags, ->
			Columns 2, false
			if showFooter
				changed, scaleContent = Checkbox string.format("%.1fx", screenScale), scaleContent
				View.scale = scaleContent and screenScale or 1 if changed
			else
				Dummy Vec2 10, 30
			SameLine!
			NextColumn!
			_, showFooter = Checkbox "Footer", showFooter
	if initFooter
		initFooter = false
	else
		return unless showFooter
	SetNextWindowSize Vec2 width, 50
	SetNextWindowPos Vec2 0, height - 50
	SetNextWindowBgAlpha 0.35
	PushStyleVar "WindowPadding", Vec2(10, 0), -> Begin "Footer", windowFlags, ->
		Separator!
		_, showStats = Checkbox "Stats", showStats
		SameLine!
		_, showConsole = Checkbox "Log", showConsole
		SameLine!
		if isInEntry
			OpenPopup "build" if Button "Build", Vec2 70, 30
			PushStyleVar "WindowPadding", Vec2(10, 10), -> BeginPopup "build", ->
				doCompile false if Selectable "Compile"
				Separator!
				doCompile true if Selectable "Minify"
				Separator!
				doClean! if Selectable "Clean"
		else
			SameLine!
			allClear! if Button "Home", Vec2 70, 30
			currentIndex = nil
			for i, name in ipairs allNames
				if currentEntryName == name
					currentIndex = i
			SameLine!
			if currentIndex and currentIndex > 1
				if Button("Prev", Vec2 70, 30)
					allClear!
					isInEntry = false
					enterDemoEntry allNames[currentIndex - 1]
			else Dummy Vec2 70, 30
			SameLine!
			if currentIndex and currentIndex < #allNames
				if Button("Next", Vec2 70, 30)
					allClear!
					isInEntry = false
					enterDemoEntry allNames[currentIndex + 1]
			else Dummy Vec2 70, 30
		PushStyleVar "WindowPadding", Vec2(10, 10), ->
			if showStats
				SetNextWindowPos Vec2(10, 10), "FirstUseEver"
				ShowStats!
			if showConsole
				SetNextWindowPos Vec2(width - 400, height - 365), "FirstUseEver"
				ShowConsole!

cyan = Color 0xff00ffff
threadLoop ->
	return unless showEntry
	return unless isInEntry
	:width, :height = App.visualSize
	SetNextWindowPos Vec2.zero
	SetNextWindowSize Vec2 width, 45
	SetNextWindowBgAlpha 0.35
	PushStyleVar "WindowPadding", Vec2(10, 0), ->
		Begin "Dorothy Dev", windowFlags, ->
			Dummy Vec2 width, 5
			TextColored cyan, "DOROTHY SSR DEV"
			Separator!
	SetNextWindowPos Vec2 0, 45
	SetNextWindowSize Vec2 width, height - 95
	PushStyleColor "WindowBg", Color(0x0), ->
		Begin "Content", windowFlags, ->
			TextColored cyan, "Game Demos"
			Columns math.max(math.floor(width / 200), 1), false
			for game in *games
				if Button game, Vec2 -1, 40
					enterDemoEntry Path "Game", game, "init"
				NextColumn!
			Columns 1, false
			TextColored cyan, "Examples"
			Columns math.max(math.floor(width / 200), 1), false
			for example in *examples
				if Button example, Vec2 -1, 40
					enterDemoEntry Path "Example", example
				NextColumn!
			Columns 1, false
			TextColored cyan, "Tests"
			Columns math.max(math.floor(width / 200), 1), false
			for test in *tests
				if Button test, Vec2 -1, 40
					enterDemoEntry Path "Test", test
				NextColumn!
			if productionEntry
				Columns 1, false
				TextColored cyan, "Product"
				Columns math.max(math.floor(width / 200), 1), false
				if Button "Enter", Vec2 -1, 40
					enterDemoEntry productionEntry
				NextColumn!
				if #productionTests > 0
					Columns 1, false
					TextColored cyan, "Product Test"
					Columns math.max(math.floor(width / 200), 1), false
					for test in *productionTests
						if Button test, Vec2 -1, 40
							enterDemoEntry Path "Test", test
						NextColumn!
			Columns 1, false
			Dummy Vec2 width, 40
