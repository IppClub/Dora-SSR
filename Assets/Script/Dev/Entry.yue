_ENV = Dorothy builtin.ImGui

App.idled = true

moduleCache = {}
oldRequire = _G.require
require = (path)->
	loaded = package.loaded[path]
	if loaded == nil
		table.insert moduleCache, path
		return oldRequire path
	loaded
_G.require = require
builtin.require = require

:searchPaths = Content

runningPaths =
	* Path Content.writablePath, ".build", "Script", "Lib"
	* Path Content.writablePath, ".build", "Script"
	* Path Content.writablePath, ".build"

import "Utils" as :Set, :Struct, :LintYueGlobals
options: {extension: yueext} = yue

print "Dorothy SSR #{App.version}#{App.debugging and ', debugging' or ''}"

LoadFontTTF "Font/sarasa-mono-sc-regular.ttf", 20, "Chinese"

building = false

getAllFiles = (path, exts)->
	filters = Set exts
	return for file in *Content\getAllFiles path
		continue if not filters[Path\getExt file]
		file

local gamesInDev

doCompile = (minify)->
	return if building
	building = true
	startTime = App.runningTime
	luaFiles = {}
	yueFiles = {}
	xmlFiles = {}
	tlFiles = {}
	:writablePath = Content
	buildPaths = {
		{
			Path Content.assetPath
			Path writablePath, ".build"
		}
	}
	for {name, entryFile} in *gamesInDev
		gamePath = Path\getPath entryFile
		buildPaths[] = {
			Path writablePath, gamePath
			Path writablePath, ".build", gamePath
		}
	for {inputPath, outputPath} in *buildPaths
		continue unless Content\exist inputPath

		for file in *getAllFiles inputPath, {"lua"}
			luaFiles[] =
				* file
				* Path inputPath, file
				* Path outputPath, file

		for file in *getAllFiles inputPath, {yueext}
			yueFiles[] =
				* file
				* Path inputPath, file
				* Path outputPath, Path\replaceExt file, "lua"

		for file in *getAllFiles inputPath, {"xml"}
			xmlFiles[] =
				* file
				* Path inputPath, file
				* Path outputPath, Path\replaceExt file, "lua"

		for file in *getAllFiles inputPath, {"tl"}
			if not file\match ".*%.d%.tl$"
				tlFiles[] =
					* file
					* Path inputPath, file
					* Path outputPath, Path\replaceExt file, "lua"

	paths = {Path\getPath(file[3]), true \
		for files in *{luaFiles, yueFiles, xmlFiles, tlFiles} \
		for file in *files}

	Content\mkdir path for path in pairs paths

	totalFiles = #yueFiles + #xmlFiles + #tlFiles
	fileCount = 0
	errors = {}
	for {file, input, output} in *yueFiles
		(success) <- yue.compile input, output, (codes, err, globals)->
			if not codes
				table.insert errors, "Compile errors in #{file}.\n#{err}"
				return
			success, result = LintYueGlobals codes, globals
			if success
				codes = codes\gsub "%s*local%s*_ENV%s*=%s*Dorothy%([^%)]-%)[^\n\r]+[\n\r%s]*", "\n"
				result ..= "\n" unless result == ""
				"-- [yue]: #{file}\n#{result}" .. codes
			else
				yueCodes = Content\load file
				for {name, line, col} in *result
					countLine = 1
					code = ""
					for lineCode in yueCodes\gmatch "[^\r\n]*"
						if countLine == line
							code = lineCode
							break
						countLine += 1
					errors[] = "invalid global variable \"#{name}\"\nin \"#{file}\", at line #{line}, col #{col}.\n#{code\gsub("\t", " ") .. '\n' .. string.rep(" ", col - 1) .. "^"}"
		print "Yue compiled: #{file}" if success
		fileCount += 1

	thread ->
		for {file, input, output} in *xmlFiles
			sourceCodes = Content\loadAsync input
			codes, err = xmltolua sourceCodes
			if not codes
				table.insert errors, "Compile errors in #{file}.\n#{err}"
			else
				Content\saveAsync output, "-- [xml]: #{file}\n#{codes}"
				print "Xml compiled: #{file}"
			fileCount += 1

	thread ->
		for {file, input, output} in *tlFiles
			sourceCodes = Content\loadAsync input
			codes, err = teal.toluaAsync sourceCodes, file
			if not codes
				table.insert errors, "Compile errors in #{file}.\n#{err}"
			else
				Content\saveAsync output, codes
				print "Teal compiled: #{file}"
			fileCount += 1

	thread ->
		wait -> fileCount == totalFiles
		if minify
			for files in *{yueFiles, xmlFiles, tlFiles} do for file in *files
				output = Path\replaceExt file[3], "lua"
				luaFiles[] =
					* Path\replaceExt file[1], "lua"
					* output
					* output

			import "luaminify.FormatMini"
			for {file, input, output} in *luaFiles
				if Content\exist input
					sourceCodes = Content\loadAsync input
					res, err = FormatMini sourceCodes
					if res
						Content\saveAsync output, res
						print "Minify: #{file}"
					else
						table.insert errors, "Minify errors in #{file}.\n#{err}"
				else
					table.insert errors, "Minify errors in #{file}.\nTarget file is not exist!"
			package.loaded["luaminify.FormatMini"] = nil
			package.loaded["luaminify.ParseLua"] = nil
			package.loaded["luaminify.Scope"] = nil
			package.loaded["luaminify.Util"] = nil
		print err for err in *errors
		builtFiles = totalFiles + (minify and #luaFiles or 0) - #errors
		print "\n#{builtFiles} #{builtFiles == 1 and 'file' or 'files'} built! Cost #{string.format '%.2f', App.runningTime - startTime}s"
		print "#{#errors} #{#errors == 1 and 'file fails' or 'files fail'} to build."
		Content\clearPathCache!
		teal.reset!
		building = false

doClean = ->
	return if building
	:writablePath = Content
	targetDir = Path writablePath, ".build"
	cleaned = false
	Content\clearPathCache!
	if Content\remove targetDir
		cleaned = true
		print "Cleaned: #{targetDir}"
	if not cleaned
		print "Nothing to clean."
	Content\remove Path writablePath, ".upload"
	Content\remove Path writablePath, ".download"

screenScale = 2 -- App.deviceRatio
scaleContent = false
isInEntry = true
currentEntry = nil

footerWindow = nil
entryWindow = nil

export allClear = ->
	for routine in *Routine
		switch routine
			when footerWindow, entryWindow
				continue
			else
				Routine\remove routine
	for module in *moduleCache
		package.loaded[module] = nil
	moduleCache = {}
	Director\cleanup!
	Cache\unload!
	Entity\clear!
	Platformer.Data\clear!
	Platformer.UnitAction\clear!
	Audio\stopStream 0.2
	Struct\clear!
	View.postEffect = nil
	View.scale = scaleContent and screenScale or 1
	Director.clearColor = Color 0xff1a1a1a
	teal.reset!
	collectgarbage!
	collectgarbage!
	Content.searchPaths = searchPaths
	App.idled = true

export stop = ->
	return false if isInEntry
	allClear!
	isInEntry = true
	currentEntry = nil
	true

examples = {}
tests = {}

getFileEntries = (path)->
	entries = {}
	for file in *getAllFiles path, {"xml", "lua", yueext, "tl"}
		entryName = Path\getName file
		file = Path\replaceExt file, ""
		file = Path Path\getName(path), file
		entry = {entryName, file}
		entries[] = entry
	table.sort entries, (a, b)-> a[1] < b[1]
	entries

getProjectEntries = (path)->
	entries = {}
	for dir in *Content\getDirs path
		continue if dir\match "^%."
		for file in *getAllFiles Path(path, dir), {"xml", "lua", yueext, "tl"}
			if "init" == Path\getName(file)\lower!
				examplePath = Path path, dir, Path\getPath(file), "Example"
				if Content\exist examplePath
					for {name, ePath} in *getFileEntries examplePath
						entry = {name, Path dir, Path\getPath(file), ePath}
						examples[] = entry
				testPath = Path path, dir, Path\getPath(file), "Test"
				if Content\exist testPath
					for {name, tPath} in *getFileEntries testPath
						entry = {name, Path dir, Path\getPath(file), tPath}
						tests[] = entry
				file = Path\replaceExt file, ""
				file = Path dir, file
				entryName = Path\getName Path\getPath file
				entry = {entryName, file}
				entries[] = entry
	table.sort entries, (a, b)-> a[1] < b[1]
	entries

gamesInDev = getProjectEntries Content.writablePath
games = getProjectEntries Path Content.assetPath, "Script"

examples[] = entry for entry in *getFileEntries Path Content.assetPath, "Script", "Example"
tests[] = entry for entry in *getFileEntries Path Content.assetPath, "Script", "Test"

cppTests = {}
for name in *App.testNames
	entry = {name}
	cppTests[] = entry
cppTestSet = Set cppTests

allEntries = {}
for group in *{
		games
		examples
		tests
		cppTests
		gamesInDev
	}
	for entry in *group
		allEntries[] = entry

export enterEntryAsync = (entry)->
	isInEntry = false
	App.idled = false
	currentEntry = entry
	{name, file} = entry
	if cppTestSet[entry]
		if App\runTest name
			return true
		else
			return false, "failed to run cpp test '#{name}'"
	sleep!
	try
		for path in *runningPaths
			Content\insertSearchPath 1, path
		result = require file
		if "function" == type result
			result = result!
			Director.entry\addChild if tolua.cast result, "Node"
				result
			else
				Node!
		else
			Director.entry\addChild Node!
	catch msg
		err = debug.traceback msg
		print err
		allClear!
		err

enterDemoEntry = (entry)-> thread -> enterEntryAsync entry

reloadCurrentEntry = ->
	if currentEntry
		allClear!
		enterDemoEntry currentEntry

showEntry = false

thread ->
	unless App.debugging
		:width, :height = App.visualSize
		scale = App.deviceRatio * 0.7 * math.min(width, height) / 760
		with Sprite nvg.GetDorothySSRHappyWhite scale
			\addTo Director.entry
			sleep 1.0
			\removeFromParent!
	showEntry = true
	Director.clearColor = Color 0xff1a1a1a

reloadDevEntry = ->
	doClean!
	allClear!
	_G.require = oldRequire
	builtin.require = oldRequire
	package.loaded["Dev.Entry"] = nil
	Director.systemScheduler\schedule ->
		Routine\clear!
		oldRequire "Dev.Entry"
		true

showStats = true
showConsole = true
showFooter = true
windowFlags =
	* "NoTitleBar"
	* "NoResize"
	* "NoMove"
	* "NoCollapse"
	* "NoSavedSettings"
	* "NoBringToFrontOnFocus"
initFooter = true
footerWindow = threadLoop ->
	App\shutdown! if Keyboard\isKeyDown "Escape"
	do
		ctrl = Keyboard\isKeyPressed "LCtrl"
		if ctrl and Keyboard\isKeyDown "Q"
			stop!
		if ctrl and Keyboard\isKeyDown "Z"
			reloadCurrentEntry!
		if ctrl and Keyboard\isKeyDown ","
			showFooter = true
			showStats = not showStats
		if ctrl and Keyboard\isKeyDown "."
			showFooter = true
			showConsole = not showConsole
		if ctrl and Keyboard\isKeyDown "/"
			showFooter = not showFooter
		left = ctrl and Keyboard\isKeyDown "Left"
		right = ctrl and Keyboard\isKeyDown "Right"
		currentIndex = nil
		for i, entry in ipairs allEntries
			if currentEntry == entry
				currentIndex = i
		if left
			allClear!
			currentIndex ??= #allEntries + 1
			enterDemoEntry if currentIndex > 1
				allEntries[currentIndex - 1]
			else
				allEntries[#allEntries]
		if right
			allClear!
			currentIndex ??= 0
			enterDemoEntry if currentIndex < #allEntries
				allEntries[currentIndex + 1]
			else
				allEntries[1]
	return unless showEntry
	:width, :height = App.visualSize
	SetNextWindowSize Vec2 200, 50
	SetNextWindowPos if width >= 600
		Vec2 width - 200, height - 50
	else
		Vec2 width, height
	PushStyleColor "WindowBg", Color(0x0), -> Begin "Show", windowFlags, ->
		if width >= 600
			Columns 2, false
			if showFooter
				changed, scaleContent = Checkbox string.format("%.1fx", screenScale), scaleContent
				View.scale = scaleContent and screenScale or 1 if changed
			else
				Dummy Vec2 10, 30
			SameLine!
			NextColumn!
			_, showFooter = Checkbox "Footer", showFooter
	if initFooter
		initFooter = false
	else
		return unless showFooter

	SetNextWindowSize Vec2 width, 50
	SetNextWindowPos Vec2 0, height - 50
	SetNextWindowBgAlpha 0.35
	PushStyleVar "WindowPadding", Vec2(10, 0), -> Begin "Footer", windowFlags, ->
		Separator!
		_, showStats = Checkbox "Stats", showStats
		SameLine!
		_, showConsole = Checkbox "Log", showConsole
		SameLine!
		if isInEntry
			OpenPopup "build" if Button "Build", Vec2 70, 30
			PushStyleVar "WindowPadding", Vec2(10, 10), -> BeginPopup "build", ->
				doCompile false if Selectable "Compile"
				Separator!
				doCompile true if Selectable "Minify"
				Separator!
				doClean! if Selectable "Clean"
			SameLine!
			if Keyboard\isKeyPressed("LCtrl") and
				Keyboard\isKeyDown "Z"
				reloadDevEntry!
			OpenPopup "reload" if Button "Reload", Vec2 70, 30
			PushStyleVar "WindowPadding", Vec2(10, 10), -> BeginPopup "reload", ->
				if Selectable "Web Editor"
					Content\remove Path Content.writablePath, ".www"
					reloadDevEntry!
				Separator!
				reloadDevEntry! if Selectable "Dev Entry"
			SameLine!
		else
			SameLine!
			if Button "Home", Vec2 70, 30
				allClear!
				isInEntry = true
				currentEntry = nil
			currentIndex = nil
			for i, entry in ipairs allEntries
				if currentEntry == entry
					currentIndex = i
			if currentIndex
				if currentIndex > 1
					SameLine!
					if Button "Prev", Vec2 70, 30
						allClear!
						enterDemoEntry allEntries[currentIndex - 1]
				if currentIndex < #allEntries
					SameLine!
					if Button "Next", Vec2 70, 30
						allClear!
						enterDemoEntry allEntries[currentIndex + 1]
			SameLine!
			if Button "Reload", Vec2 70, 30
				reloadCurrentEntry!
		PushStyleVar "WindowPadding", Vec2(10, 10), ->
			if showStats
				SetNextWindowPos Vec2(10, 10), "FirstUseEver"
				ShowStats!
			if showConsole
				SetNextWindowPos Vec2(width - 400, height - 365), "FirstUseEver"
				ShowConsole!

cyan = Color 0xff00ffff
entryWindow = threadLoop ->
	return unless showEntry
	return unless isInEntry
	:width, :height = App.visualSize
	SetNextWindowPos Vec2.zero
	SetNextWindowSize Vec2 width, 45
	SetNextWindowBgAlpha 0.35
	PushStyleVar "WindowPadding", Vec2(10, 0), ->
		Begin "Dorothy Dev", windowFlags, ->
			Dummy Vec2 width - 20, 5
			TextColored cyan, "DOROTHY SSR DEV"
			Separator!
	SetNextWindowPos Vec2 0, 45
	SetNextWindowSize Vec2 width, height - 95
	PushStyleColor "WindowBg", Color(0x0), ->
		Begin "Content", windowFlags, ->
			if #games > 0
				TextColored cyan, "Game Demos"
				Columns math.max(math.floor(width / 200), 1), false
				for game in *games
					if Button game[1], Vec2 -1, 40
						enterDemoEntry game
					NextColumn!
				Columns 1, false
			if #examples > 0
				TextColored cyan, "Examples"
				Columns math.max(math.floor(width / 200), 1), false
				for example in *examples
					if Button example[1], Vec2 -1, 40
						enterDemoEntry example
					NextColumn!
				Columns 1, false
			if #tests > 0
				TextColored cyan, "Tests"
				Columns math.max(math.floor(width / 200), 1), false
				for test in *tests
					if Button test[1], Vec2 -1, 40
						enterDemoEntry test
					NextColumn!
				for test in *cppTests
					if Button test[1], Vec2 -1, 40
						enterDemoEntry test
					NextColumn!
				Columns 1, false
			if #gamesInDev > 0
				TextColored cyan, "Games In Dev"
				Columns math.max(math.floor(width / 200), 1), false
				for game in *gamesInDev
					if Button game[1], Vec2 -1, 40
						enterDemoEntry game
					NextColumn!
				Columns 1, false
			Dummy Vec2 100, 40

require "WebServer"
