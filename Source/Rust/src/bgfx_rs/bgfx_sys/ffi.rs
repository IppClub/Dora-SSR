/* automatically generated by rust-bindgen 0.70.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
	storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
	#[inline]
	pub const fn new(storage: Storage) -> Self {
		Self { storage }
	}
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
	Storage: AsRef<[u8]> + AsMut<[u8]>,
{
	#[inline]
	fn extract_bit(byte: u8, index: usize) -> bool {
		let bit_index = if cfg!(target_endian = "big") {
			7 - (index % 8)
		} else {
			index % 8
		};
		let mask = 1 << bit_index;
		byte & mask == mask
	}
	#[inline]
	pub fn get_bit(&self, index: usize) -> bool {
		debug_assert!(index / 8 < self.storage.as_ref().len());
		let byte_index = index / 8;
		let byte = self.storage.as_ref()[byte_index];
		Self::extract_bit(byte, index)
	}
	#[inline]
	pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
		debug_assert!(index / 8 < core::mem::size_of::<Storage>());
		let byte_index = index / 8;
		let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
		Self::extract_bit(byte, index)
	}
	#[inline]
	fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
		let bit_index = if cfg!(target_endian = "big") {
			7 - (index % 8)
		} else {
			index % 8
		};
		let mask = 1 << bit_index;
		if val {
			byte | mask
		} else {
			byte & !mask
		}
	}
	#[inline]
	pub fn set_bit(&mut self, index: usize, val: bool) {
		debug_assert!(index / 8 < self.storage.as_ref().len());
		let byte_index = index / 8;
		let byte = &mut self.storage.as_mut()[byte_index];
		*byte = Self::change_bit(*byte, index, val);
	}
	#[inline]
	pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
		debug_assert!(index / 8 < core::mem::size_of::<Storage>());
		let byte_index = index / 8;
		let byte =
			(core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
		*byte = Self::change_bit(*byte, index, val);
	}
	#[inline]
	pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
		debug_assert!(bit_width <= 64);
		debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
		debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
		let mut val = 0;
		for i in 0..(bit_width as usize) {
			if self.get_bit(i + bit_offset) {
				let index = if cfg!(target_endian = "big") {
					bit_width as usize - 1 - i
				} else {
					i
				};
				val |= 1 << index;
			}
		}
		val
	}
	#[inline]
	pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
		debug_assert!(bit_width <= 64);
		debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
		debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
		let mut val = 0;
		for i in 0..(bit_width as usize) {
			if Self::raw_get_bit(this, i + bit_offset) {
				let index = if cfg!(target_endian = "big") {
					bit_width as usize - 1 - i
				} else {
					i
				};
				val |= 1 << index;
			}
		}
		val
	}
	#[inline]
	pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
		debug_assert!(bit_width <= 64);
		debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
		debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
		for i in 0..(bit_width as usize) {
			let mask = 1 << i;
			let val_bit_is_set = val & mask == mask;
			let index = if cfg!(target_endian = "big") {
				bit_width as usize - 1 - i
			} else {
				i
			};
			self.set_bit(index + bit_offset, val_bit_is_set);
		}
	}
	#[inline]
	pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
		debug_assert!(bit_width <= 64);
		debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
		debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
		for i in 0..(bit_width as usize) {
			let mask = 1 << i;
			let val_bit_is_set = val & mask == mask;
			let index = if cfg!(target_endian = "big") {
				bit_width as usize - 1 - i
			} else {
				i
			};
			Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
		}
	}
}
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __WORDSIZE: u32 = 64;
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const USE_CLANG_TYPES: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __MAC_14_5: u32 = 140500;
pub const __MAC_15_0: u32 = 150000;
pub const __MAC_15_1: u32 = 150100;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __IPHONE_17_5: u32 = 170500;
pub const __IPHONE_18_0: u32 = 180000;
pub const __IPHONE_18_1: u32 = 180100;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __WATCHOS_10_5: u32 = 100500;
pub const __WATCHOS_11_0: u32 = 110000;
pub const __WATCHOS_11_1: u32 = 110100;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __TVOS_17_5: u32 = 170500;
pub const __TVOS_18_0: u32 = 180000;
pub const __TVOS_18_1: u32 = 180100;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __BRIDGEOS_8_5: u32 = 80500;
pub const __BRIDGEOS_9_0: u32 = 90000;
pub const __BRIDGEOS_9_1: u32 = 90100;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __DRIVERKIT_23_5: u32 = 230500;
pub const __DRIVERKIT_24_0: u32 = 240000;
pub const __DRIVERKIT_24_1: u32 = 240100;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const __VISIONOS_1_2: u32 = 10200;
pub const __VISIONOS_2_0: u32 = 20000;
pub const __VISIONOS_2_1: u32 = 20100;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const MAC_OS_VERSION_14_5: u32 = 140500;
pub const MAC_OS_VERSION_15_0: u32 = 150000;
pub const MAC_OS_VERSION_15_1: u32 = 150100;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 150100;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const USE_CLANG_STDDEF: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_V6: u32 = 6;
pub const RUSAGE_INFO_CURRENT: u32 = 6;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY: u32 = 10;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT: u32 = 0;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON: u32 = 1;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const BX_ARCH_32BIT: u32 = 0;
pub const BX_ARCH_64BIT: u32 = 0;
pub const BX_COMPILER_CLANG: u32 = 0;
pub const BX_COMPILER_CLANG_ANALYZER: u32 = 0;
pub const BX_COMPILER_GCC: u32 = 0;
pub const BX_COMPILER_MSVC: u32 = 0;
pub const BX_CPU_ENDIAN_BIG: u32 = 0;
pub const BX_CPU_ENDIAN_LITTLE: u32 = 0;
pub const BX_CPU_ARM: u32 = 0;
pub const BX_CPU_JIT: u32 = 0;
pub const BX_CPU_MIPS: u32 = 0;
pub const BX_CPU_PPC: u32 = 0;
pub const BX_CPU_RISCV: u32 = 0;
pub const BX_CPU_X86: u32 = 0;
pub const BX_CRT_BIONIC: u32 = 0;
pub const BX_CRT_GLIBC: u32 = 0;
pub const BX_CRT_LIBCXX: u32 = 0;
pub const BX_CRT_MINGW: u32 = 0;
pub const BX_CRT_MSVC: u32 = 0;
pub const BX_CRT_NEWLIB: u32 = 0;
pub const BX_CRT_NONE: u32 = 0;
pub const BX_LANGUAGE_CPP17: u32 = 201703;
pub const BX_LANGUAGE_CPP20: u32 = 202002;
pub const BX_LANGUAGE_CPP23: u32 = 202207;
pub const BX_PLATFORM_ANDROID: u32 = 0;
pub const BX_PLATFORM_BSD: u32 = 0;
pub const BX_PLATFORM_EMSCRIPTEN: u32 = 0;
pub const BX_PLATFORM_HAIKU: u32 = 0;
pub const BX_PLATFORM_HURD: u32 = 0;
pub const BX_PLATFORM_IOS: u32 = 0;
pub const BX_PLATFORM_LINUX: u32 = 0;
pub const BX_PLATFORM_NX: u32 = 0;
pub const BX_PLATFORM_OSX: u32 = 0;
pub const BX_PLATFORM_PS4: u32 = 0;
pub const BX_PLATFORM_PS5: u32 = 0;
pub const BX_PLATFORM_RPI: u32 = 0;
pub const BX_PLATFORM_VISIONOS: u32 = 0;
pub const BX_PLATFORM_WINDOWS: u32 = 0;
pub const BX_PLATFORM_WINRT: u32 = 0;
pub const BX_PLATFORM_XBOXONE: u32 = 0;
pub const BX_CACHE_LINE_SIZE: u32 = 64;
pub const BX_PLATFORM_NAME: &[u8; 6] = b"macOS\0";
pub const BX_CPU_NAME: &[u8; 4] = b"ARM\0";
pub const BX_CRT_NAME: &[u8; 16] = b"Clang C Library\0";
pub const BX_ARCH_NAME: &[u8; 7] = b"64-bit\0";
pub const BX_CPP_NAME: &[u8; 11] = b"C++Unknown\0";
pub const BGFX_SHARED_LIB_BUILD: u32 = 0;
pub const BGFX_SHARED_LIB_USE: u32 = 0;
pub const BGFX_API_VERSION: u32 = 129;
pub const BGFX_STATE_WRITE_R: u32 = 1;
pub const BGFX_STATE_WRITE_G: u32 = 2;
pub const BGFX_STATE_WRITE_B: u32 = 4;
pub const BGFX_STATE_WRITE_A: u32 = 8;
pub const BGFX_STATE_WRITE_Z: u64 = 274877906944;
pub const BGFX_STATE_WRITE_RGB: u32 = 7;
pub const BGFX_STATE_WRITE_MASK: u64 = 274877906959;
pub const BGFX_STATE_DEPTH_TEST_LESS: u32 = 16;
pub const BGFX_STATE_DEPTH_TEST_LEQUAL: u32 = 32;
pub const BGFX_STATE_DEPTH_TEST_EQUAL: u32 = 48;
pub const BGFX_STATE_DEPTH_TEST_GEQUAL: u32 = 64;
pub const BGFX_STATE_DEPTH_TEST_GREATER: u32 = 80;
pub const BGFX_STATE_DEPTH_TEST_NOTEQUAL: u32 = 96;
pub const BGFX_STATE_DEPTH_TEST_NEVER: u32 = 112;
pub const BGFX_STATE_DEPTH_TEST_ALWAYS: u32 = 128;
pub const BGFX_STATE_DEPTH_TEST_SHIFT: u32 = 4;
pub const BGFX_STATE_DEPTH_TEST_MASK: u32 = 240;
pub const BGFX_STATE_BLEND_ZERO: u32 = 4096;
pub const BGFX_STATE_BLEND_ONE: u32 = 8192;
pub const BGFX_STATE_BLEND_SRC_COLOR: u32 = 12288;
pub const BGFX_STATE_BLEND_INV_SRC_COLOR: u32 = 16384;
pub const BGFX_STATE_BLEND_SRC_ALPHA: u32 = 20480;
pub const BGFX_STATE_BLEND_INV_SRC_ALPHA: u32 = 24576;
pub const BGFX_STATE_BLEND_DST_ALPHA: u32 = 28672;
pub const BGFX_STATE_BLEND_INV_DST_ALPHA: u32 = 32768;
pub const BGFX_STATE_BLEND_DST_COLOR: u32 = 36864;
pub const BGFX_STATE_BLEND_INV_DST_COLOR: u32 = 40960;
pub const BGFX_STATE_BLEND_SRC_ALPHA_SAT: u32 = 45056;
pub const BGFX_STATE_BLEND_FACTOR: u32 = 49152;
pub const BGFX_STATE_BLEND_INV_FACTOR: u32 = 53248;
pub const BGFX_STATE_BLEND_SHIFT: u32 = 12;
pub const BGFX_STATE_BLEND_MASK: u32 = 268431360;
pub const BGFX_STATE_BLEND_EQUATION_ADD: u32 = 0;
pub const BGFX_STATE_BLEND_EQUATION_SUB: u32 = 268435456;
pub const BGFX_STATE_BLEND_EQUATION_REVSUB: u32 = 536870912;
pub const BGFX_STATE_BLEND_EQUATION_MIN: u32 = 805306368;
pub const BGFX_STATE_BLEND_EQUATION_MAX: u32 = 1073741824;
pub const BGFX_STATE_BLEND_EQUATION_SHIFT: u32 = 28;
pub const BGFX_STATE_BLEND_EQUATION_MASK: u64 = 16911433728;
pub const BGFX_STATE_CULL_CW: u64 = 68719476736;
pub const BGFX_STATE_CULL_CCW: u64 = 137438953472;
pub const BGFX_STATE_CULL_SHIFT: u32 = 36;
pub const BGFX_STATE_CULL_MASK: u64 = 206158430208;
pub const BGFX_STATE_ALPHA_REF_SHIFT: u32 = 40;
pub const BGFX_STATE_ALPHA_REF_MASK: u64 = 280375465082880;
pub const BGFX_STATE_PT_TRISTRIP: u64 = 281474976710656;
pub const BGFX_STATE_PT_LINES: u64 = 562949953421312;
pub const BGFX_STATE_PT_LINESTRIP: u64 = 844424930131968;
pub const BGFX_STATE_PT_POINTS: u64 = 1125899906842624;
pub const BGFX_STATE_PT_SHIFT: u32 = 48;
pub const BGFX_STATE_PT_MASK: u64 = 1970324836974592;
pub const BGFX_STATE_POINT_SIZE_SHIFT: u32 = 52;
pub const BGFX_STATE_POINT_SIZE_MASK: u64 = 67553994410557440;
pub const BGFX_STATE_MSAA: u64 = 72057594037927936;
pub const BGFX_STATE_LINEAA: u64 = 144115188075855872;
pub const BGFX_STATE_CONSERVATIVE_RASTER: u64 = 288230376151711744;
pub const BGFX_STATE_NONE: u32 = 0;
pub const BGFX_STATE_FRONT_CCW: u64 = 549755813888;
pub const BGFX_STATE_BLEND_INDEPENDENT: u64 = 17179869184;
pub const BGFX_STATE_BLEND_ALPHA_TO_COVERAGE: u64 = 34359738368;
pub const BGFX_STATE_DEFAULT: u64 = 72057937635311647;
pub const BGFX_STATE_MASK: i32 = -1;
pub const BGFX_STATE_RESERVED_SHIFT: u32 = 61;
pub const BGFX_STATE_RESERVED_MASK: i64 = -2305843009213693952;
pub const BGFX_STENCIL_FUNC_REF_SHIFT: u32 = 0;
pub const BGFX_STENCIL_FUNC_REF_MASK: u32 = 255;
pub const BGFX_STENCIL_FUNC_RMASK_SHIFT: u32 = 8;
pub const BGFX_STENCIL_FUNC_RMASK_MASK: u32 = 65280;
pub const BGFX_STENCIL_NONE: u32 = 0;
pub const BGFX_STENCIL_MASK: u32 = 4294967295;
pub const BGFX_STENCIL_DEFAULT: u32 = 0;
pub const BGFX_STENCIL_TEST_LESS: u32 = 65536;
pub const BGFX_STENCIL_TEST_LEQUAL: u32 = 131072;
pub const BGFX_STENCIL_TEST_EQUAL: u32 = 196608;
pub const BGFX_STENCIL_TEST_GEQUAL: u32 = 262144;
pub const BGFX_STENCIL_TEST_GREATER: u32 = 327680;
pub const BGFX_STENCIL_TEST_NOTEQUAL: u32 = 393216;
pub const BGFX_STENCIL_TEST_NEVER: u32 = 458752;
pub const BGFX_STENCIL_TEST_ALWAYS: u32 = 524288;
pub const BGFX_STENCIL_TEST_SHIFT: u32 = 16;
pub const BGFX_STENCIL_TEST_MASK: u32 = 983040;
pub const BGFX_STENCIL_OP_FAIL_S_ZERO: u32 = 0;
pub const BGFX_STENCIL_OP_FAIL_S_KEEP: u32 = 1048576;
pub const BGFX_STENCIL_OP_FAIL_S_REPLACE: u32 = 2097152;
pub const BGFX_STENCIL_OP_FAIL_S_INCR: u32 = 3145728;
pub const BGFX_STENCIL_OP_FAIL_S_INCRSAT: u32 = 4194304;
pub const BGFX_STENCIL_OP_FAIL_S_DECR: u32 = 5242880;
pub const BGFX_STENCIL_OP_FAIL_S_DECRSAT: u32 = 6291456;
pub const BGFX_STENCIL_OP_FAIL_S_INVERT: u32 = 7340032;
pub const BGFX_STENCIL_OP_FAIL_S_SHIFT: u32 = 20;
pub const BGFX_STENCIL_OP_FAIL_S_MASK: u32 = 15728640;
pub const BGFX_STENCIL_OP_FAIL_Z_ZERO: u32 = 0;
pub const BGFX_STENCIL_OP_FAIL_Z_KEEP: u32 = 16777216;
pub const BGFX_STENCIL_OP_FAIL_Z_REPLACE: u32 = 33554432;
pub const BGFX_STENCIL_OP_FAIL_Z_INCR: u32 = 50331648;
pub const BGFX_STENCIL_OP_FAIL_Z_INCRSAT: u32 = 67108864;
pub const BGFX_STENCIL_OP_FAIL_Z_DECR: u32 = 83886080;
pub const BGFX_STENCIL_OP_FAIL_Z_DECRSAT: u32 = 100663296;
pub const BGFX_STENCIL_OP_FAIL_Z_INVERT: u32 = 117440512;
pub const BGFX_STENCIL_OP_FAIL_Z_SHIFT: u32 = 24;
pub const BGFX_STENCIL_OP_FAIL_Z_MASK: u32 = 251658240;
pub const BGFX_STENCIL_OP_PASS_Z_ZERO: u32 = 0;
pub const BGFX_STENCIL_OP_PASS_Z_KEEP: u32 = 268435456;
pub const BGFX_STENCIL_OP_PASS_Z_REPLACE: u32 = 536870912;
pub const BGFX_STENCIL_OP_PASS_Z_INCR: u32 = 805306368;
pub const BGFX_STENCIL_OP_PASS_Z_INCRSAT: u32 = 1073741824;
pub const BGFX_STENCIL_OP_PASS_Z_DECR: u32 = 1342177280;
pub const BGFX_STENCIL_OP_PASS_Z_DECRSAT: u32 = 1610612736;
pub const BGFX_STENCIL_OP_PASS_Z_INVERT: u32 = 1879048192;
pub const BGFX_STENCIL_OP_PASS_Z_SHIFT: u32 = 28;
pub const BGFX_STENCIL_OP_PASS_Z_MASK: u32 = 4026531840;
pub const BGFX_CLEAR_NONE: u32 = 0;
pub const BGFX_CLEAR_COLOR: u32 = 1;
pub const BGFX_CLEAR_DEPTH: u32 = 2;
pub const BGFX_CLEAR_STENCIL: u32 = 4;
pub const BGFX_CLEAR_DISCARD_COLOR_0: u32 = 8;
pub const BGFX_CLEAR_DISCARD_COLOR_1: u32 = 16;
pub const BGFX_CLEAR_DISCARD_COLOR_2: u32 = 32;
pub const BGFX_CLEAR_DISCARD_COLOR_3: u32 = 64;
pub const BGFX_CLEAR_DISCARD_COLOR_4: u32 = 128;
pub const BGFX_CLEAR_DISCARD_COLOR_5: u32 = 256;
pub const BGFX_CLEAR_DISCARD_COLOR_6: u32 = 512;
pub const BGFX_CLEAR_DISCARD_COLOR_7: u32 = 1024;
pub const BGFX_CLEAR_DISCARD_DEPTH: u32 = 2048;
pub const BGFX_CLEAR_DISCARD_STENCIL: u32 = 4096;
pub const BGFX_CLEAR_DISCARD_COLOR_MASK: u32 = 2040;
pub const BGFX_CLEAR_DISCARD_MASK: u32 = 8184;
pub const BGFX_DISCARD_NONE: u32 = 0;
pub const BGFX_DISCARD_BINDINGS: u32 = 1;
pub const BGFX_DISCARD_INDEX_BUFFER: u32 = 2;
pub const BGFX_DISCARD_INSTANCE_DATA: u32 = 4;
pub const BGFX_DISCARD_STATE: u32 = 8;
pub const BGFX_DISCARD_TRANSFORM: u32 = 16;
pub const BGFX_DISCARD_VERTEX_STREAMS: u32 = 32;
pub const BGFX_DISCARD_ALL: u32 = 255;
pub const BGFX_DEBUG_NONE: u32 = 0;
pub const BGFX_DEBUG_WIREFRAME: u32 = 1;
pub const BGFX_DEBUG_IFH: u32 = 2;
pub const BGFX_DEBUG_STATS: u32 = 4;
pub const BGFX_DEBUG_TEXT: u32 = 8;
pub const BGFX_DEBUG_PROFILER: u32 = 16;
pub const BGFX_BUFFER_COMPUTE_FORMAT_8X1: u32 = 1;
pub const BGFX_BUFFER_COMPUTE_FORMAT_8X2: u32 = 2;
pub const BGFX_BUFFER_COMPUTE_FORMAT_8X4: u32 = 3;
pub const BGFX_BUFFER_COMPUTE_FORMAT_16X1: u32 = 4;
pub const BGFX_BUFFER_COMPUTE_FORMAT_16X2: u32 = 5;
pub const BGFX_BUFFER_COMPUTE_FORMAT_16X4: u32 = 6;
pub const BGFX_BUFFER_COMPUTE_FORMAT_32X1: u32 = 7;
pub const BGFX_BUFFER_COMPUTE_FORMAT_32X2: u32 = 8;
pub const BGFX_BUFFER_COMPUTE_FORMAT_32X4: u32 = 9;
pub const BGFX_BUFFER_COMPUTE_FORMAT_SHIFT: u32 = 0;
pub const BGFX_BUFFER_COMPUTE_FORMAT_MASK: u32 = 15;
pub const BGFX_BUFFER_COMPUTE_TYPE_INT: u32 = 16;
pub const BGFX_BUFFER_COMPUTE_TYPE_UINT: u32 = 32;
pub const BGFX_BUFFER_COMPUTE_TYPE_FLOAT: u32 = 48;
pub const BGFX_BUFFER_COMPUTE_TYPE_SHIFT: u32 = 4;
pub const BGFX_BUFFER_COMPUTE_TYPE_MASK: u32 = 48;
pub const BGFX_BUFFER_NONE: u32 = 0;
pub const BGFX_BUFFER_COMPUTE_READ: u32 = 256;
pub const BGFX_BUFFER_COMPUTE_WRITE: u32 = 512;
pub const BGFX_BUFFER_DRAW_INDIRECT: u32 = 1024;
pub const BGFX_BUFFER_ALLOW_RESIZE: u32 = 2048;
pub const BGFX_BUFFER_INDEX32: u32 = 4096;
pub const BGFX_BUFFER_COMPUTE_READ_WRITE: u32 = 768;
pub const BGFX_TEXTURE_NONE: u32 = 0;
pub const BGFX_TEXTURE_MSAA_SAMPLE: u64 = 34359738368;
pub const BGFX_TEXTURE_RT: u64 = 68719476736;
pub const BGFX_TEXTURE_COMPUTE_WRITE: u64 = 17592186044416;
pub const BGFX_TEXTURE_SRGB: u64 = 35184372088832;
pub const BGFX_TEXTURE_BLIT_DST: u64 = 70368744177664;
pub const BGFX_TEXTURE_READ_BACK: u64 = 140737488355328;
pub const BGFX_TEXTURE_RT_MSAA_X2: u64 = 137438953472;
pub const BGFX_TEXTURE_RT_MSAA_X4: u64 = 206158430208;
pub const BGFX_TEXTURE_RT_MSAA_X8: u64 = 274877906944;
pub const BGFX_TEXTURE_RT_MSAA_X16: u64 = 343597383680;
pub const BGFX_TEXTURE_RT_MSAA_SHIFT: u32 = 36;
pub const BGFX_TEXTURE_RT_MSAA_MASK: u64 = 481036337152;
pub const BGFX_TEXTURE_RT_WRITE_ONLY: u64 = 549755813888;
pub const BGFX_TEXTURE_RT_SHIFT: u32 = 36;
pub const BGFX_TEXTURE_RT_MASK: u64 = 1030792151040;
pub const BGFX_SAMPLER_U_MIRROR: u32 = 1;
pub const BGFX_SAMPLER_U_CLAMP: u32 = 2;
pub const BGFX_SAMPLER_U_BORDER: u32 = 3;
pub const BGFX_SAMPLER_U_SHIFT: u32 = 0;
pub const BGFX_SAMPLER_U_MASK: u32 = 3;
pub const BGFX_SAMPLER_V_MIRROR: u32 = 4;
pub const BGFX_SAMPLER_V_CLAMP: u32 = 8;
pub const BGFX_SAMPLER_V_BORDER: u32 = 12;
pub const BGFX_SAMPLER_V_SHIFT: u32 = 2;
pub const BGFX_SAMPLER_V_MASK: u32 = 12;
pub const BGFX_SAMPLER_W_MIRROR: u32 = 16;
pub const BGFX_SAMPLER_W_CLAMP: u32 = 32;
pub const BGFX_SAMPLER_W_BORDER: u32 = 48;
pub const BGFX_SAMPLER_W_SHIFT: u32 = 4;
pub const BGFX_SAMPLER_W_MASK: u32 = 48;
pub const BGFX_SAMPLER_MIN_POINT: u32 = 64;
pub const BGFX_SAMPLER_MIN_ANISOTROPIC: u32 = 128;
pub const BGFX_SAMPLER_MIN_SHIFT: u32 = 6;
pub const BGFX_SAMPLER_MIN_MASK: u32 = 192;
pub const BGFX_SAMPLER_MAG_POINT: u32 = 256;
pub const BGFX_SAMPLER_MAG_ANISOTROPIC: u32 = 512;
pub const BGFX_SAMPLER_MAG_SHIFT: u32 = 8;
pub const BGFX_SAMPLER_MAG_MASK: u32 = 768;
pub const BGFX_SAMPLER_MIP_POINT: u32 = 1024;
pub const BGFX_SAMPLER_MIP_SHIFT: u32 = 10;
pub const BGFX_SAMPLER_MIP_MASK: u32 = 1024;
pub const BGFX_SAMPLER_COMPARE_LESS: u32 = 65536;
pub const BGFX_SAMPLER_COMPARE_LEQUAL: u32 = 131072;
pub const BGFX_SAMPLER_COMPARE_EQUAL: u32 = 196608;
pub const BGFX_SAMPLER_COMPARE_GEQUAL: u32 = 262144;
pub const BGFX_SAMPLER_COMPARE_GREATER: u32 = 327680;
pub const BGFX_SAMPLER_COMPARE_NOTEQUAL: u32 = 393216;
pub const BGFX_SAMPLER_COMPARE_NEVER: u32 = 458752;
pub const BGFX_SAMPLER_COMPARE_ALWAYS: u32 = 524288;
pub const BGFX_SAMPLER_COMPARE_SHIFT: u32 = 16;
pub const BGFX_SAMPLER_COMPARE_MASK: u32 = 983040;
pub const BGFX_SAMPLER_BORDER_COLOR_SHIFT: u32 = 24;
pub const BGFX_SAMPLER_BORDER_COLOR_MASK: u32 = 251658240;
pub const BGFX_SAMPLER_RESERVED_SHIFT: u32 = 28;
pub const BGFX_SAMPLER_RESERVED_MASK: u32 = 4026531840;
pub const BGFX_SAMPLER_NONE: u32 = 0;
pub const BGFX_SAMPLER_SAMPLE_STENCIL: u32 = 1048576;
pub const BGFX_SAMPLER_POINT: u32 = 1344;
pub const BGFX_SAMPLER_UVW_MIRROR: u32 = 21;
pub const BGFX_SAMPLER_UVW_CLAMP: u32 = 42;
pub const BGFX_SAMPLER_UVW_BORDER: u32 = 63;
pub const BGFX_SAMPLER_BITS_MASK: u32 = 985087;
pub const BGFX_RESET_MSAA_X2: u32 = 16;
pub const BGFX_RESET_MSAA_X4: u32 = 32;
pub const BGFX_RESET_MSAA_X8: u32 = 48;
pub const BGFX_RESET_MSAA_X16: u32 = 64;
pub const BGFX_RESET_MSAA_SHIFT: u32 = 4;
pub const BGFX_RESET_MSAA_MASK: u32 = 112;
pub const BGFX_RESET_NONE: u32 = 0;
pub const BGFX_RESET_FULLSCREEN: u32 = 1;
pub const BGFX_RESET_VSYNC: u32 = 128;
pub const BGFX_RESET_MAXANISOTROPY: u32 = 256;
pub const BGFX_RESET_CAPTURE: u32 = 512;
pub const BGFX_RESET_FLUSH_AFTER_RENDER: u32 = 8192;
pub const BGFX_RESET_FLIP_AFTER_RENDER: u32 = 16384;
pub const BGFX_RESET_SRGB_BACKBUFFER: u32 = 32768;
pub const BGFX_RESET_HDR10: u32 = 65536;
pub const BGFX_RESET_HIDPI: u32 = 131072;
pub const BGFX_RESET_DEPTH_CLAMP: u32 = 262144;
pub const BGFX_RESET_SUSPEND: u32 = 524288;
pub const BGFX_RESET_TRANSPARENT_BACKBUFFER: u32 = 1048576;
pub const BGFX_RESET_FULLSCREEN_SHIFT: u32 = 0;
pub const BGFX_RESET_FULLSCREEN_MASK: u32 = 1;
pub const BGFX_RESET_RESERVED_SHIFT: u32 = 31;
pub const BGFX_RESET_RESERVED_MASK: u32 = 2147483648;
pub const BGFX_CAPS_ALPHA_TO_COVERAGE: u32 = 1;
pub const BGFX_CAPS_BLEND_INDEPENDENT: u32 = 2;
pub const BGFX_CAPS_COMPUTE: u32 = 4;
pub const BGFX_CAPS_CONSERVATIVE_RASTER: u32 = 8;
pub const BGFX_CAPS_DRAW_INDIRECT: u32 = 16;
pub const BGFX_CAPS_DRAW_INDIRECT_COUNT: u32 = 32;
pub const BGFX_CAPS_FRAGMENT_DEPTH: u32 = 64;
pub const BGFX_CAPS_FRAGMENT_ORDERING: u32 = 128;
pub const BGFX_CAPS_GRAPHICS_DEBUGGER: u32 = 256;
pub const BGFX_CAPS_HDR10: u32 = 512;
pub const BGFX_CAPS_HIDPI: u32 = 1024;
pub const BGFX_CAPS_IMAGE_RW: u32 = 2048;
pub const BGFX_CAPS_INDEX32: u32 = 4096;
pub const BGFX_CAPS_INSTANCING: u32 = 8192;
pub const BGFX_CAPS_OCCLUSION_QUERY: u32 = 16384;
pub const BGFX_CAPS_PRIMITIVE_ID: u32 = 32768;
pub const BGFX_CAPS_RENDERER_MULTITHREADED: u32 = 65536;
pub const BGFX_CAPS_SWAP_CHAIN: u32 = 131072;
pub const BGFX_CAPS_TEXTURE_BLIT: u32 = 262144;
pub const BGFX_CAPS_TEXTURE_COMPARE_LEQUAL: u32 = 524288;
pub const BGFX_CAPS_TEXTURE_COMPARE_RESERVED: u32 = 1048576;
pub const BGFX_CAPS_TEXTURE_CUBE_ARRAY: u32 = 2097152;
pub const BGFX_CAPS_TEXTURE_DIRECT_ACCESS: u32 = 4194304;
pub const BGFX_CAPS_TEXTURE_READ_BACK: u32 = 8388608;
pub const BGFX_CAPS_TEXTURE_2D_ARRAY: u32 = 16777216;
pub const BGFX_CAPS_TEXTURE_3D: u32 = 33554432;
pub const BGFX_CAPS_TRANSPARENT_BACKBUFFER: u32 = 67108864;
pub const BGFX_CAPS_VERTEX_ATTRIB_HALF: u32 = 134217728;
pub const BGFX_CAPS_VERTEX_ATTRIB_UINT10: u32 = 268435456;
pub const BGFX_CAPS_VERTEX_ID: u32 = 536870912;
pub const BGFX_CAPS_VIEWPORT_LAYER_ARRAY: u32 = 1073741824;
pub const BGFX_CAPS_TEXTURE_COMPARE_ALL: u32 = 1572864;
pub const BGFX_CAPS_FORMAT_TEXTURE_NONE: u32 = 0;
pub const BGFX_CAPS_FORMAT_TEXTURE_2D: u32 = 1;
pub const BGFX_CAPS_FORMAT_TEXTURE_2D_SRGB: u32 = 2;
pub const BGFX_CAPS_FORMAT_TEXTURE_2D_EMULATED: u32 = 4;
pub const BGFX_CAPS_FORMAT_TEXTURE_3D: u32 = 8;
pub const BGFX_CAPS_FORMAT_TEXTURE_3D_SRGB: u32 = 16;
pub const BGFX_CAPS_FORMAT_TEXTURE_3D_EMULATED: u32 = 32;
pub const BGFX_CAPS_FORMAT_TEXTURE_CUBE: u32 = 64;
pub const BGFX_CAPS_FORMAT_TEXTURE_CUBE_SRGB: u32 = 128;
pub const BGFX_CAPS_FORMAT_TEXTURE_CUBE_EMULATED: u32 = 256;
pub const BGFX_CAPS_FORMAT_TEXTURE_VERTEX: u32 = 512;
pub const BGFX_CAPS_FORMAT_TEXTURE_IMAGE_READ: u32 = 1024;
pub const BGFX_CAPS_FORMAT_TEXTURE_IMAGE_WRITE: u32 = 2048;
pub const BGFX_CAPS_FORMAT_TEXTURE_FRAMEBUFFER: u32 = 4096;
pub const BGFX_CAPS_FORMAT_TEXTURE_FRAMEBUFFER_MSAA: u32 = 8192;
pub const BGFX_CAPS_FORMAT_TEXTURE_MSAA: u32 = 16384;
pub const BGFX_CAPS_FORMAT_TEXTURE_MIP_AUTOGEN: u32 = 32768;
pub const BGFX_RESOLVE_NONE: u32 = 0;
pub const BGFX_RESOLVE_AUTO_GEN_MIPS: u32 = 1;
pub const BGFX_PCI_ID_NONE: u32 = 0;
pub const BGFX_PCI_ID_SOFTWARE_RASTERIZER: u32 = 1;
pub const BGFX_PCI_ID_AMD: u32 = 4098;
pub const BGFX_PCI_ID_APPLE: u32 = 4203;
pub const BGFX_PCI_ID_INTEL: u32 = 32902;
pub const BGFX_PCI_ID_NVIDIA: u32 = 4318;
pub const BGFX_PCI_ID_MICROSOFT: u32 = 5140;
pub const BGFX_PCI_ID_ARM: u32 = 5045;
pub const BGFX_CUBE_MAP_POSITIVE_X: u32 = 0;
pub const BGFX_CUBE_MAP_NEGATIVE_X: u32 = 1;
pub const BGFX_CUBE_MAP_POSITIVE_Y: u32 = 2;
pub const BGFX_CUBE_MAP_NEGATIVE_Y: u32 = 3;
pub const BGFX_CUBE_MAP_POSITIVE_Z: u32 = 4;
pub const BGFX_CUBE_MAP_NEGATIVE_Z: u32 = 5;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
	pub __mbstate8: [::std::os::raw::c_char; 128usize],
	pub _mbstateL: ::std::os::raw::c_longlong,
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
	pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
	pub __arg: *mut ::std::os::raw::c_void,
	pub __next: *mut __darwin_pthread_handler_rec,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
	pub __sig: ::std::os::raw::c_long,
	pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
	pub __opaque: [::std::os::raw::c_char; 8176usize],
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub const P_ALL: idtype_t = 0;
pub const P_PID: idtype_t = 1;
pub const P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state {
	pub __exception: __uint32_t,
	pub __fsr: __uint32_t,
	pub __far: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64 {
	pub __far: __uint64_t,
	pub __esr: __uint32_t,
	pub __exception: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64_v2 {
	pub __far: __uint64_t,
	pub __esr: __uint64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state {
	pub __r: [__uint32_t; 13usize],
	pub __sp: __uint32_t,
	pub __lr: __uint32_t,
	pub __pc: __uint32_t,
	pub __cpsr: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state64 {
	pub __x: [__uint64_t; 29usize],
	pub __fp: __uint64_t,
	pub __lr: __uint64_t,
	pub __sp: __uint64_t,
	pub __pc: __uint64_t,
	pub __cpsr: __uint32_t,
	pub __pad: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_vfp_state {
	pub __r: [__uint32_t; 64usize],
	pub __fpscr: __uint32_t,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state64 {
	pub __v: [__uint128_t; 32usize],
	pub __fpsr: __uint32_t,
	pub __fpcr: __uint32_t,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state {
	pub __v: [__uint128_t; 16usize],
	pub __fpsr: __uint32_t,
	pub __fpcr: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_pagein_state {
	pub __pagein_error: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_legacy_debug_state {
	pub __bvr: [__uint32_t; 16usize],
	pub __bcr: [__uint32_t; 16usize],
	pub __wvr: [__uint32_t; 16usize],
	pub __wcr: [__uint32_t; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state32 {
	pub __bvr: [__uint32_t; 16usize],
	pub __bcr: [__uint32_t; 16usize],
	pub __wvr: [__uint32_t; 16usize],
	pub __wcr: [__uint32_t; 16usize],
	pub __mdscr_el1: __uint64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state64 {
	pub __bvr: [__uint64_t; 16usize],
	pub __bcr: [__uint64_t; 16usize],
	pub __wvr: [__uint64_t; 16usize],
	pub __wcr: [__uint64_t; 16usize],
	pub __mdscr_el1: __uint64_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_cpmu_state64 {
	pub __ctrs: [__uint64_t; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext32 {
	pub __es: __darwin_arm_exception_state,
	pub __ss: __darwin_arm_thread_state,
	pub __fs: __darwin_arm_vfp_state,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext64 {
	pub __es: __darwin_arm_exception_state64,
	pub __ss: __darwin_arm_thread_state64,
	pub __ns: __darwin_arm_neon_state64,
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
	pub ss_sp: *mut ::std::os::raw::c_void,
	pub ss_size: __darwin_size_t,
	pub ss_flags: ::std::os::raw::c_int,
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
	pub uc_onstack: ::std::os::raw::c_int,
	pub uc_sigmask: __darwin_sigset_t,
	pub uc_stack: __darwin_sigaltstack,
	pub uc_link: *mut __darwin_ucontext,
	pub uc_mcsize: __darwin_size_t,
	pub uc_mcontext: *mut __darwin_mcontext64,
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
	pub sival_int: ::std::os::raw::c_int,
	pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
	pub sigev_notify: ::std::os::raw::c_int,
	pub sigev_signo: ::std::os::raw::c_int,
	pub sigev_value: sigval,
	pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
	pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
	pub si_signo: ::std::os::raw::c_int,
	pub si_errno: ::std::os::raw::c_int,
	pub si_code: ::std::os::raw::c_int,
	pub si_pid: pid_t,
	pub si_uid: uid_t,
	pub si_status: ::std::os::raw::c_int,
	pub si_addr: *mut ::std::os::raw::c_void,
	pub si_value: sigval,
	pub si_band: ::std::os::raw::c_long,
	pub __pad: [::std::os::raw::c_ulong; 7usize],
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
	pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
	pub __sa_sigaction: ::std::option::Option<
		unsafe extern "C" fn(
			arg1: ::std::os::raw::c_int,
			arg2: *mut __siginfo,
			arg3: *mut ::std::os::raw::c_void,
		),
	>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
	pub __sigaction_u: __sigaction_u,
	pub sa_tramp: ::std::option::Option<
		unsafe extern "C" fn(
			arg1: *mut ::std::os::raw::c_void,
			arg2: ::std::os::raw::c_int,
			arg3: ::std::os::raw::c_int,
			arg4: *mut siginfo_t,
			arg5: *mut ::std::os::raw::c_void,
		),
	>,
	pub sa_mask: sigset_t,
	pub sa_flags: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
	pub __sigaction_u: __sigaction_u,
	pub sa_mask: sigset_t,
	pub sa_flags: ::std::os::raw::c_int,
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
	pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
	pub sv_mask: ::std::os::raw::c_int,
	pub sv_flags: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
	pub ss_sp: *mut ::std::os::raw::c_char,
	pub ss_onstack: ::std::os::raw::c_int,
}
extern "C" {
	pub fn signal(
		arg1: ::std::os::raw::c_int,
		arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
	) -> ::std::option::Option<
		unsafe extern "C" fn(
			arg1: ::std::os::raw::c_int,
			arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
		),
	>;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
	pub tv_sec: __darwin_time_t,
	pub tv_usec: __darwin_suseconds_t,
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
	pub ru_utime: timeval,
	pub ru_stime: timeval,
	pub ru_maxrss: ::std::os::raw::c_long,
	pub ru_ixrss: ::std::os::raw::c_long,
	pub ru_idrss: ::std::os::raw::c_long,
	pub ru_isrss: ::std::os::raw::c_long,
	pub ru_minflt: ::std::os::raw::c_long,
	pub ru_majflt: ::std::os::raw::c_long,
	pub ru_nswap: ::std::os::raw::c_long,
	pub ru_inblock: ::std::os::raw::c_long,
	pub ru_oublock: ::std::os::raw::c_long,
	pub ru_msgsnd: ::std::os::raw::c_long,
	pub ru_msgrcv: ::std::os::raw::c_long,
	pub ru_nsignals: ::std::os::raw::c_long,
	pub ru_nvcsw: ::std::os::raw::c_long,
	pub ru_nivcsw: ::std::os::raw::c_long,
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
	pub ri_uuid: [u8; 16usize],
	pub ri_user_time: u64,
	pub ri_system_time: u64,
	pub ri_pkg_idle_wkups: u64,
	pub ri_interrupt_wkups: u64,
	pub ri_pageins: u64,
	pub ri_wired_size: u64,
	pub ri_resident_size: u64,
	pub ri_phys_footprint: u64,
	pub ri_proc_start_abstime: u64,
	pub ri_proc_exit_abstime: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
	pub ri_uuid: [u8; 16usize],
	pub ri_user_time: u64,
	pub ri_system_time: u64,
	pub ri_pkg_idle_wkups: u64,
	pub ri_interrupt_wkups: u64,
	pub ri_pageins: u64,
	pub ri_wired_size: u64,
	pub ri_resident_size: u64,
	pub ri_phys_footprint: u64,
	pub ri_proc_start_abstime: u64,
	pub ri_proc_exit_abstime: u64,
	pub ri_child_user_time: u64,
	pub ri_child_system_time: u64,
	pub ri_child_pkg_idle_wkups: u64,
	pub ri_child_interrupt_wkups: u64,
	pub ri_child_pageins: u64,
	pub ri_child_elapsed_abstime: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
	pub ri_uuid: [u8; 16usize],
	pub ri_user_time: u64,
	pub ri_system_time: u64,
	pub ri_pkg_idle_wkups: u64,
	pub ri_interrupt_wkups: u64,
	pub ri_pageins: u64,
	pub ri_wired_size: u64,
	pub ri_resident_size: u64,
	pub ri_phys_footprint: u64,
	pub ri_proc_start_abstime: u64,
	pub ri_proc_exit_abstime: u64,
	pub ri_child_user_time: u64,
	pub ri_child_system_time: u64,
	pub ri_child_pkg_idle_wkups: u64,
	pub ri_child_interrupt_wkups: u64,
	pub ri_child_pageins: u64,
	pub ri_child_elapsed_abstime: u64,
	pub ri_diskio_bytesread: u64,
	pub ri_diskio_byteswritten: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
	pub ri_uuid: [u8; 16usize],
	pub ri_user_time: u64,
	pub ri_system_time: u64,
	pub ri_pkg_idle_wkups: u64,
	pub ri_interrupt_wkups: u64,
	pub ri_pageins: u64,
	pub ri_wired_size: u64,
	pub ri_resident_size: u64,
	pub ri_phys_footprint: u64,
	pub ri_proc_start_abstime: u64,
	pub ri_proc_exit_abstime: u64,
	pub ri_child_user_time: u64,
	pub ri_child_system_time: u64,
	pub ri_child_pkg_idle_wkups: u64,
	pub ri_child_interrupt_wkups: u64,
	pub ri_child_pageins: u64,
	pub ri_child_elapsed_abstime: u64,
	pub ri_diskio_bytesread: u64,
	pub ri_diskio_byteswritten: u64,
	pub ri_cpu_time_qos_default: u64,
	pub ri_cpu_time_qos_maintenance: u64,
	pub ri_cpu_time_qos_background: u64,
	pub ri_cpu_time_qos_utility: u64,
	pub ri_cpu_time_qos_legacy: u64,
	pub ri_cpu_time_qos_user_initiated: u64,
	pub ri_cpu_time_qos_user_interactive: u64,
	pub ri_billed_system_time: u64,
	pub ri_serviced_system_time: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
	pub ri_uuid: [u8; 16usize],
	pub ri_user_time: u64,
	pub ri_system_time: u64,
	pub ri_pkg_idle_wkups: u64,
	pub ri_interrupt_wkups: u64,
	pub ri_pageins: u64,
	pub ri_wired_size: u64,
	pub ri_resident_size: u64,
	pub ri_phys_footprint: u64,
	pub ri_proc_start_abstime: u64,
	pub ri_proc_exit_abstime: u64,
	pub ri_child_user_time: u64,
	pub ri_child_system_time: u64,
	pub ri_child_pkg_idle_wkups: u64,
	pub ri_child_interrupt_wkups: u64,
	pub ri_child_pageins: u64,
	pub ri_child_elapsed_abstime: u64,
	pub ri_diskio_bytesread: u64,
	pub ri_diskio_byteswritten: u64,
	pub ri_cpu_time_qos_default: u64,
	pub ri_cpu_time_qos_maintenance: u64,
	pub ri_cpu_time_qos_background: u64,
	pub ri_cpu_time_qos_utility: u64,
	pub ri_cpu_time_qos_legacy: u64,
	pub ri_cpu_time_qos_user_initiated: u64,
	pub ri_cpu_time_qos_user_interactive: u64,
	pub ri_billed_system_time: u64,
	pub ri_serviced_system_time: u64,
	pub ri_logical_writes: u64,
	pub ri_lifetime_max_phys_footprint: u64,
	pub ri_instructions: u64,
	pub ri_cycles: u64,
	pub ri_billed_energy: u64,
	pub ri_serviced_energy: u64,
	pub ri_interval_max_phys_footprint: u64,
	pub ri_runnable_time: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v5 {
	pub ri_uuid: [u8; 16usize],
	pub ri_user_time: u64,
	pub ri_system_time: u64,
	pub ri_pkg_idle_wkups: u64,
	pub ri_interrupt_wkups: u64,
	pub ri_pageins: u64,
	pub ri_wired_size: u64,
	pub ri_resident_size: u64,
	pub ri_phys_footprint: u64,
	pub ri_proc_start_abstime: u64,
	pub ri_proc_exit_abstime: u64,
	pub ri_child_user_time: u64,
	pub ri_child_system_time: u64,
	pub ri_child_pkg_idle_wkups: u64,
	pub ri_child_interrupt_wkups: u64,
	pub ri_child_pageins: u64,
	pub ri_child_elapsed_abstime: u64,
	pub ri_diskio_bytesread: u64,
	pub ri_diskio_byteswritten: u64,
	pub ri_cpu_time_qos_default: u64,
	pub ri_cpu_time_qos_maintenance: u64,
	pub ri_cpu_time_qos_background: u64,
	pub ri_cpu_time_qos_utility: u64,
	pub ri_cpu_time_qos_legacy: u64,
	pub ri_cpu_time_qos_user_initiated: u64,
	pub ri_cpu_time_qos_user_interactive: u64,
	pub ri_billed_system_time: u64,
	pub ri_serviced_system_time: u64,
	pub ri_logical_writes: u64,
	pub ri_lifetime_max_phys_footprint: u64,
	pub ri_instructions: u64,
	pub ri_cycles: u64,
	pub ri_billed_energy: u64,
	pub ri_serviced_energy: u64,
	pub ri_interval_max_phys_footprint: u64,
	pub ri_runnable_time: u64,
	pub ri_flags: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v6 {
	pub ri_uuid: [u8; 16usize],
	pub ri_user_time: u64,
	pub ri_system_time: u64,
	pub ri_pkg_idle_wkups: u64,
	pub ri_interrupt_wkups: u64,
	pub ri_pageins: u64,
	pub ri_wired_size: u64,
	pub ri_resident_size: u64,
	pub ri_phys_footprint: u64,
	pub ri_proc_start_abstime: u64,
	pub ri_proc_exit_abstime: u64,
	pub ri_child_user_time: u64,
	pub ri_child_system_time: u64,
	pub ri_child_pkg_idle_wkups: u64,
	pub ri_child_interrupt_wkups: u64,
	pub ri_child_pageins: u64,
	pub ri_child_elapsed_abstime: u64,
	pub ri_diskio_bytesread: u64,
	pub ri_diskio_byteswritten: u64,
	pub ri_cpu_time_qos_default: u64,
	pub ri_cpu_time_qos_maintenance: u64,
	pub ri_cpu_time_qos_background: u64,
	pub ri_cpu_time_qos_utility: u64,
	pub ri_cpu_time_qos_legacy: u64,
	pub ri_cpu_time_qos_user_initiated: u64,
	pub ri_cpu_time_qos_user_interactive: u64,
	pub ri_billed_system_time: u64,
	pub ri_serviced_system_time: u64,
	pub ri_logical_writes: u64,
	pub ri_lifetime_max_phys_footprint: u64,
	pub ri_instructions: u64,
	pub ri_cycles: u64,
	pub ri_billed_energy: u64,
	pub ri_serviced_energy: u64,
	pub ri_interval_max_phys_footprint: u64,
	pub ri_runnable_time: u64,
	pub ri_flags: u64,
	pub ri_user_ptime: u64,
	pub ri_system_ptime: u64,
	pub ri_pinstructions: u64,
	pub ri_pcycles: u64,
	pub ri_energy_nj: u64,
	pub ri_penergy_nj: u64,
	pub ri_secure_time_in_system: u64,
	pub ri_secure_ptime_in_system: u64,
	pub ri_neural_footprint: u64,
	pub ri_lifetime_max_neural_footprint: u64,
	pub ri_interval_max_neural_footprint: u64,
	pub ri_reserved: [u64; 9usize],
}
pub type rusage_info_current = rusage_info_v6;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
	pub rlim_cur: rlim_t,
	pub rlim_max: rlim_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
	pub wm_flags: u32,
	pub wm_rate: i32,
}
extern "C" {
	pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn getiopolicy_np(
		arg1: ::std::os::raw::c_int,
		arg2: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn setpriority(
		arg1: ::std::os::raw::c_int,
		arg2: id_t,
		arg3: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn setiopolicy_np(
		arg1: ::std::os::raw::c_int,
		arg2: ::std::os::raw::c_int,
		arg3: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
	pub w_status: ::std::os::raw::c_int,
	pub w_T: wait__bindgen_ty_1,
	pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
	pub _bitfield_align_1: [u16; 0],
	pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl wait__bindgen_ty_1 {
	#[inline]
	pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
	}
	#[inline]
	pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(0usize, 7u8, val as u64)
		}
	}
	#[inline]
	pub unsafe fn w_Termsig_raw(this: *const Self) -> ::std::os::raw::c_uint {
		unsafe {
			::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
				::std::ptr::addr_of!((*this)._bitfield_1),
				0usize,
				7u8,
			) as u32)
		}
	}
	#[inline]
	pub unsafe fn set_w_Termsig_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
				::std::ptr::addr_of_mut!((*this)._bitfield_1),
				0usize,
				7u8,
				val as u64,
			)
		}
	}
	#[inline]
	pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
	}
	#[inline]
	pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(7usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub unsafe fn w_Coredump_raw(this: *const Self) -> ::std::os::raw::c_uint {
		unsafe {
			::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
				::std::ptr::addr_of!((*this)._bitfield_1),
				7usize,
				1u8,
			) as u32)
		}
	}
	#[inline]
	pub unsafe fn set_w_Coredump_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
				::std::ptr::addr_of_mut!((*this)._bitfield_1),
				7usize,
				1u8,
				val as u64,
			)
		}
	}
	#[inline]
	pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
	}
	#[inline]
	pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(8usize, 8u8, val as u64)
		}
	}
	#[inline]
	pub unsafe fn w_Retcode_raw(this: *const Self) -> ::std::os::raw::c_uint {
		unsafe {
			::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
				::std::ptr::addr_of!((*this)._bitfield_1),
				8usize,
				8u8,
			) as u32)
		}
	}
	#[inline]
	pub unsafe fn set_w_Retcode_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
				::std::ptr::addr_of_mut!((*this)._bitfield_1),
				8usize,
				8u8,
				val as u64,
			)
		}
	}
	#[inline]
	pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
	}
	#[inline]
	pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(16usize, 16u8, val as u64)
		}
	}
	#[inline]
	pub unsafe fn w_Filler_raw(this: *const Self) -> ::std::os::raw::c_uint {
		unsafe {
			::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
				::std::ptr::addr_of!((*this)._bitfield_1),
				16usize,
				16u8,
			) as u32)
		}
	}
	#[inline]
	pub unsafe fn set_w_Filler_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
				::std::ptr::addr_of_mut!((*this)._bitfield_1),
				16usize,
				16u8,
				val as u64,
			)
		}
	}
	#[inline]
	pub fn new_bitfield_1(
		w_Termsig: ::std::os::raw::c_uint,
		w_Coredump: ::std::os::raw::c_uint,
		w_Retcode: ::std::os::raw::c_uint,
		w_Filler: ::std::os::raw::c_uint,
	) -> __BindgenBitfieldUnit<[u8; 4usize]> {
		let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
		__bindgen_bitfield_unit.set(0usize, 7u8, {
			let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
			w_Termsig as u64
		});
		__bindgen_bitfield_unit.set(7usize, 1u8, {
			let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
			w_Coredump as u64
		});
		__bindgen_bitfield_unit.set(8usize, 8u8, {
			let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
			w_Retcode as u64
		});
		__bindgen_bitfield_unit.set(16usize, 16u8, {
			let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
			w_Filler as u64
		});
		__bindgen_bitfield_unit
	}
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
	pub _bitfield_align_1: [u16; 0],
	pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl wait__bindgen_ty_2 {
	#[inline]
	pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
	}
	#[inline]
	pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(0usize, 8u8, val as u64)
		}
	}
	#[inline]
	pub unsafe fn w_Stopval_raw(this: *const Self) -> ::std::os::raw::c_uint {
		unsafe {
			::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
				::std::ptr::addr_of!((*this)._bitfield_1),
				0usize,
				8u8,
			) as u32)
		}
	}
	#[inline]
	pub unsafe fn set_w_Stopval_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
				::std::ptr::addr_of_mut!((*this)._bitfield_1),
				0usize,
				8u8,
				val as u64,
			)
		}
	}
	#[inline]
	pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
	}
	#[inline]
	pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(8usize, 8u8, val as u64)
		}
	}
	#[inline]
	pub unsafe fn w_Stopsig_raw(this: *const Self) -> ::std::os::raw::c_uint {
		unsafe {
			::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
				::std::ptr::addr_of!((*this)._bitfield_1),
				8usize,
				8u8,
			) as u32)
		}
	}
	#[inline]
	pub unsafe fn set_w_Stopsig_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
				::std::ptr::addr_of_mut!((*this)._bitfield_1),
				8usize,
				8u8,
				val as u64,
			)
		}
	}
	#[inline]
	pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
	}
	#[inline]
	pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(16usize, 16u8, val as u64)
		}
	}
	#[inline]
	pub unsafe fn w_Filler_raw(this: *const Self) -> ::std::os::raw::c_uint {
		unsafe {
			::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_get(
				::std::ptr::addr_of!((*this)._bitfield_1),
				16usize,
				16u8,
			) as u32)
		}
	}
	#[inline]
	pub unsafe fn set_w_Filler_raw(this: *mut Self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			<__BindgenBitfieldUnit<[u8; 4usize]>>::raw_set(
				::std::ptr::addr_of_mut!((*this)._bitfield_1),
				16usize,
				16u8,
				val as u64,
			)
		}
	}
	#[inline]
	pub fn new_bitfield_1(
		w_Stopval: ::std::os::raw::c_uint,
		w_Stopsig: ::std::os::raw::c_uint,
		w_Filler: ::std::os::raw::c_uint,
	) -> __BindgenBitfieldUnit<[u8; 4usize]> {
		let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
		__bindgen_bitfield_unit.set(0usize, 8u8, {
			let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
			w_Stopval as u64
		});
		__bindgen_bitfield_unit.set(8usize, 8u8, {
			let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
			w_Stopsig as u64
		});
		__bindgen_bitfield_unit.set(16usize, 16u8, {
			let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
			w_Filler as u64
		});
		__bindgen_bitfield_unit
	}
}
extern "C" {
	pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
	pub fn waitpid(
		arg1: pid_t,
		arg2: *mut ::std::os::raw::c_int,
		arg3: ::std::os::raw::c_int,
	) -> pid_t;
}
extern "C" {
	pub fn waitid(
		arg1: idtype_t,
		arg2: id_t,
		arg3: *mut siginfo_t,
		arg4: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn wait3(
		arg1: *mut ::std::os::raw::c_int,
		arg2: ::std::os::raw::c_int,
		arg3: *mut rusage,
	) -> pid_t;
}
extern "C" {
	pub fn wait4(
		arg1: pid_t,
		arg2: *mut ::std::os::raw::c_int,
		arg3: ::std::os::raw::c_int,
		arg4: *mut rusage,
	) -> pid_t;
}
extern "C" {
	pub fn alloca(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
	pub quot: ::std::os::raw::c_int,
	pub rem: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
	pub quot: ::std::os::raw::c_long,
	pub rem: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
	pub quot: ::std::os::raw::c_longlong,
	pub rem: ::std::os::raw::c_longlong,
}
extern "C" {
	pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
pub type malloc_type_id_t = ::std::os::raw::c_ulonglong;
extern "C" {
	pub fn malloc_type_malloc(
		size: usize,
		type_id: malloc_type_id_t,
	) -> *mut ::std::os::raw::c_void;
}
extern "C" {
	pub fn malloc_type_calloc(
		count: usize,
		size: usize,
		type_id: malloc_type_id_t,
	) -> *mut ::std::os::raw::c_void;
}
extern "C" {
	pub fn malloc_type_free(ptr: *mut ::std::os::raw::c_void, type_id: malloc_type_id_t);
}
extern "C" {
	pub fn malloc_type_realloc(
		ptr: *mut ::std::os::raw::c_void,
		size: usize,
		type_id: malloc_type_id_t,
	) -> *mut ::std::os::raw::c_void;
}
extern "C" {
	pub fn malloc_type_valloc(
		size: usize,
		type_id: malloc_type_id_t,
	) -> *mut ::std::os::raw::c_void;
}
extern "C" {
	pub fn malloc_type_aligned_alloc(
		alignment: usize,
		size: usize,
		type_id: malloc_type_id_t,
	) -> *mut ::std::os::raw::c_void;
}
extern "C" {
	pub fn malloc_type_posix_memalign(
		memptr: *mut *mut ::std::os::raw::c_void,
		alignment: usize,
		size: usize,
		type_id: malloc_type_id_t,
	) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _malloc_zone_t {
	_unused: [u8; 0],
}
pub type malloc_zone_t = _malloc_zone_t;
extern "C" {
	pub fn malloc_type_zone_malloc(
		zone: *mut malloc_zone_t,
		size: usize,
		type_id: malloc_type_id_t,
	) -> *mut ::std::os::raw::c_void;
}
extern "C" {
	pub fn malloc_type_zone_calloc(
		zone: *mut malloc_zone_t,
		count: usize,
		size: usize,
		type_id: malloc_type_id_t,
	) -> *mut ::std::os::raw::c_void;
}
extern "C" {
	pub fn malloc_type_zone_free(
		zone: *mut malloc_zone_t,
		ptr: *mut ::std::os::raw::c_void,
		type_id: malloc_type_id_t,
	);
}
extern "C" {
	pub fn malloc_type_zone_realloc(
		zone: *mut malloc_zone_t,
		ptr: *mut ::std::os::raw::c_void,
		size: usize,
		type_id: malloc_type_id_t,
	) -> *mut ::std::os::raw::c_void;
}
extern "C" {
	pub fn malloc_type_zone_valloc(
		zone: *mut malloc_zone_t,
		size: usize,
		type_id: malloc_type_id_t,
	) -> *mut ::std::os::raw::c_void;
}
extern "C" {
	pub fn malloc_type_zone_memalign(
		zone: *mut malloc_zone_t,
		alignment: usize,
		size: usize,
		type_id: malloc_type_id_t,
	) -> *mut ::std::os::raw::c_void;
}
extern "C" {
	pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
	pub fn calloc(
		__count: ::std::os::raw::c_ulong,
		__size: ::std::os::raw::c_ulong,
	) -> *mut ::std::os::raw::c_void;
}
extern "C" {
	pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
	pub fn realloc(
		__ptr: *mut ::std::os::raw::c_void,
		__size: ::std::os::raw::c_ulong,
	) -> *mut ::std::os::raw::c_void;
}
extern "C" {
	pub fn reallocf(
		__ptr: *mut ::std::os::raw::c_void,
		__size: usize,
	) -> *mut ::std::os::raw::c_void;
}
extern "C" {
	pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
	pub fn aligned_alloc(
		__alignment: ::std::os::raw::c_ulong,
		__size: ::std::os::raw::c_ulong,
	) -> *mut ::std::os::raw::c_void;
}
extern "C" {
	pub fn posix_memalign(
		__memptr: *mut *mut ::std::os::raw::c_void,
		__alignment: usize,
		__size: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn abort() -> !;
}
extern "C" {
	pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn at_quick_exit(
		arg1: ::std::option::Option<unsafe extern "C" fn()>,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
	pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
	pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
	pub fn bsearch(
		__key: *const ::std::os::raw::c_void,
		__base: *const ::std::os::raw::c_void,
		__nel: usize,
		__width: usize,
		__compar: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *const ::std::os::raw::c_void,
				arg2: *const ::std::os::raw::c_void,
			) -> ::std::os::raw::c_int,
		>,
	) -> *mut ::std::os::raw::c_void;
}
extern "C" {
	pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
	pub fn exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
	pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
	pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
	pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
	pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
	pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
	pub fn mbtowc(
		arg1: *mut wchar_t,
		arg2: *const ::std::os::raw::c_char,
		arg3: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn qsort(
		__base: *mut ::std::os::raw::c_void,
		__nel: usize,
		__width: usize,
		__compar: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *const ::std::os::raw::c_void,
				arg2: *const ::std::os::raw::c_void,
			) -> ::std::os::raw::c_int,
		>,
	);
}
extern "C" {
	pub fn quick_exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
	pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
	pub fn strtod(
		arg1: *const ::std::os::raw::c_char,
		arg2: *mut *mut ::std::os::raw::c_char,
	) -> f64;
}
extern "C" {
	pub fn strtof(
		arg1: *const ::std::os::raw::c_char,
		arg2: *mut *mut ::std::os::raw::c_char,
	) -> f32;
}
extern "C" {
	pub fn strtol(
		__str: *const ::std::os::raw::c_char,
		__endptr: *mut *mut ::std::os::raw::c_char,
		__base: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_long;
}
extern "C" {
	pub fn strtold(
		arg1: *const ::std::os::raw::c_char,
		arg2: *mut *mut ::std::os::raw::c_char,
	) -> f64;
}
extern "C" {
	pub fn strtoll(
		__str: *const ::std::os::raw::c_char,
		__endptr: *mut *mut ::std::os::raw::c_char,
		__base: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_longlong;
}
extern "C" {
	pub fn strtoul(
		__str: *const ::std::os::raw::c_char,
		__endptr: *mut *mut ::std::os::raw::c_char,
		__base: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_ulong;
}
extern "C" {
	pub fn strtoull(
		__str: *const ::std::os::raw::c_char,
		__endptr: *mut *mut ::std::os::raw::c_char,
		__base: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
	pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
	pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
	pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
	pub fn drand48() -> f64;
}
extern "C" {
	pub fn ecvt(
		arg1: f64,
		arg2: ::std::os::raw::c_int,
		arg3: *mut ::std::os::raw::c_int,
		arg4: *mut ::std::os::raw::c_int,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
	pub fn fcvt(
		arg1: f64,
		arg2: ::std::os::raw::c_int,
		arg3: *mut ::std::os::raw::c_int,
		arg4: *mut ::std::os::raw::c_int,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn gcvt(
		arg1: f64,
		arg2: ::std::os::raw::c_int,
		arg3: *mut ::std::os::raw::c_char,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn getsubopt(
		arg1: *mut *mut ::std::os::raw::c_char,
		arg2: *const *mut ::std::os::raw::c_char,
		arg3: *mut *mut ::std::os::raw::c_char,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn initstate(
		arg1: ::std::os::raw::c_uint,
		arg2: *mut ::std::os::raw::c_char,
		arg3: usize,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
	pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
	pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
	pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
	pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
	pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn ptsname_r(
		fildes: ::std::os::raw::c_int,
		buffer: *mut ::std::os::raw::c_char,
		buflen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
	pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
	#[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
	pub fn realpath(
		arg1: *const ::std::os::raw::c_char,
		arg2: *mut ::std::os::raw::c_char,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
	pub fn setenv(
		__name: *const ::std::os::raw::c_char,
		__value: *const ::std::os::raw::c_char,
		__overwrite: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
	pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
	pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
	pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
	pub fn arc4random() -> u32;
}
extern "C" {
	pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
	pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: usize);
}
extern "C" {
	pub fn arc4random_stir();
}
extern "C" {
	pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
	pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn bsearch_b(
		__key: *const ::std::os::raw::c_void,
		__base: *const ::std::os::raw::c_void,
		__nel: usize,
		__width: usize,
		__compar: *mut ::std::os::raw::c_void,
	) -> *mut ::std::os::raw::c_void;
}
extern "C" {
	pub fn cgetcap(
		arg1: *mut ::std::os::raw::c_char,
		arg2: *const ::std::os::raw::c_char,
		arg3: ::std::os::raw::c_int,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn cgetent(
		arg1: *mut *mut ::std::os::raw::c_char,
		arg2: *mut *mut ::std::os::raw::c_char,
		arg3: *const ::std::os::raw::c_char,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn cgetfirst(
		arg1: *mut *mut ::std::os::raw::c_char,
		arg2: *mut *mut ::std::os::raw::c_char,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn cgetmatch(
		arg1: *const ::std::os::raw::c_char,
		arg2: *const ::std::os::raw::c_char,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn cgetnext(
		arg1: *mut *mut ::std::os::raw::c_char,
		arg2: *mut *mut ::std::os::raw::c_char,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn cgetnum(
		arg1: *mut ::std::os::raw::c_char,
		arg2: *const ::std::os::raw::c_char,
		arg3: *mut ::std::os::raw::c_long,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn cgetstr(
		arg1: *mut ::std::os::raw::c_char,
		arg2: *const ::std::os::raw::c_char,
		arg3: *mut *mut ::std::os::raw::c_char,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn cgetustr(
		arg1: *mut ::std::os::raw::c_char,
		arg2: *const ::std::os::raw::c_char,
		arg3: *mut *mut ::std::os::raw::c_char,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn daemon(
		arg1: ::std::os::raw::c_int,
		arg2: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn devname_r(
		arg1: dev_t,
		arg2: mode_t,
		buf: *mut ::std::os::raw::c_char,
		len: ::std::os::raw::c_int,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn getbsize(
		arg1: *mut ::std::os::raw::c_int,
		arg2: *mut ::std::os::raw::c_long,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
	pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
	pub fn heapsort(
		__base: *mut ::std::os::raw::c_void,
		__nel: usize,
		__width: usize,
		__compar: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *const ::std::os::raw::c_void,
				arg2: *const ::std::os::raw::c_void,
			) -> ::std::os::raw::c_int,
		>,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn heapsort_b(
		__base: *mut ::std::os::raw::c_void,
		__nel: usize,
		__width: usize,
		__compar: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn mergesort(
		__base: *mut ::std::os::raw::c_void,
		__nel: usize,
		__width: usize,
		__compar: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *const ::std::os::raw::c_void,
				arg2: *const ::std::os::raw::c_void,
			) -> ::std::os::raw::c_int,
		>,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn mergesort_b(
		__base: *mut ::std::os::raw::c_void,
		__nel: usize,
		__width: usize,
		__compar: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn psort(
		__base: *mut ::std::os::raw::c_void,
		__nel: usize,
		__width: usize,
		__compar: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *const ::std::os::raw::c_void,
				arg2: *const ::std::os::raw::c_void,
			) -> ::std::os::raw::c_int,
		>,
	);
}
extern "C" {
	pub fn psort_b(
		__base: *mut ::std::os::raw::c_void,
		__nel: usize,
		__width: usize,
		__compar: *mut ::std::os::raw::c_void,
	);
}
extern "C" {
	pub fn psort_r(
		__base: *mut ::std::os::raw::c_void,
		__nel: usize,
		__width: usize,
		arg1: *mut ::std::os::raw::c_void,
		__compar: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *const ::std::os::raw::c_void,
				arg3: *const ::std::os::raw::c_void,
			) -> ::std::os::raw::c_int,
		>,
	);
}
extern "C" {
	pub fn qsort_b(
		__base: *mut ::std::os::raw::c_void,
		__nel: usize,
		__width: usize,
		__compar: *mut ::std::os::raw::c_void,
	);
}
extern "C" {
	pub fn qsort_r(
		__base: *mut ::std::os::raw::c_void,
		__nel: usize,
		__width: usize,
		arg1: *mut ::std::os::raw::c_void,
		__compar: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *const ::std::os::raw::c_void,
				arg3: *const ::std::os::raw::c_void,
			) -> ::std::os::raw::c_int,
		>,
	);
}
extern "C" {
	pub fn radixsort(
		__base: *mut *const ::std::os::raw::c_uchar,
		__nel: ::std::os::raw::c_int,
		__table: *const ::std::os::raw::c_uchar,
		__endbyte: ::std::os::raw::c_uint,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn sradixsort(
		__base: *mut *const ::std::os::raw::c_uchar,
		__nel: ::std::os::raw::c_int,
		__table: *const ::std::os::raw::c_uchar,
		__endbyte: ::std::os::raw::c_uint,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn sranddev();
}
extern "C" {
	pub fn srandomdev();
}
extern "C" {
	pub fn strtonum(
		__numstr: *const ::std::os::raw::c_char,
		__minval: ::std::os::raw::c_longlong,
		__maxval: ::std::os::raw::c_longlong,
		__errstrp: *mut *const ::std::os::raw::c_char,
	) -> ::std::os::raw::c_longlong;
}
extern "C" {
	pub fn strtoq(
		__str: *const ::std::os::raw::c_char,
		__endptr: *mut *mut ::std::os::raw::c_char,
		__base: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_longlong;
}
extern "C" {
	pub fn strtouq(
		__str: *const ::std::os::raw::c_char,
		__endptr: *mut *mut ::std::os::raw::c_char,
		__base: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
	pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
pub const BGFX_FATAL_DEBUG_CHECK: bgfx_fatal = 0;
#[doc = " ( 0)"]
pub const BGFX_FATAL_INVALID_SHADER: bgfx_fatal = 1;
#[doc = " ( 1)"]
pub const BGFX_FATAL_UNABLE_TO_INITIALIZE: bgfx_fatal = 2;
#[doc = " ( 2)"]
pub const BGFX_FATAL_UNABLE_TO_CREATE_TEXTURE: bgfx_fatal = 3;
#[doc = " ( 3)"]
pub const BGFX_FATAL_DEVICE_LOST: bgfx_fatal = 4;
#[doc = " ( 4)"]
pub const BGFX_FATAL_COUNT: bgfx_fatal = 5;
#[doc = " Fatal error enum.\n"]
pub type bgfx_fatal = ::std::os::raw::c_uint;
#[doc = " Fatal error enum.\n"]
pub use self::bgfx_fatal as bgfx_fatal_t;
pub const BGFX_RENDERER_TYPE_NOOP: bgfx_renderer_type = 0;
#[doc = " ( 0) No rendering."]
pub const BGFX_RENDERER_TYPE_AGC: bgfx_renderer_type = 1;
#[doc = " ( 1) AGC"]
pub const BGFX_RENDERER_TYPE_DIRECT3D11: bgfx_renderer_type = 2;
#[doc = " ( 2) Direct3D 11.0"]
pub const BGFX_RENDERER_TYPE_DIRECT3D12: bgfx_renderer_type = 3;
#[doc = " ( 3) Direct3D 12.0"]
pub const BGFX_RENDERER_TYPE_GNM: bgfx_renderer_type = 4;
#[doc = " ( 4) GNM"]
pub const BGFX_RENDERER_TYPE_METAL: bgfx_renderer_type = 5;
#[doc = " ( 5) Metal"]
pub const BGFX_RENDERER_TYPE_NVN: bgfx_renderer_type = 6;
#[doc = " ( 6) NVN"]
pub const BGFX_RENDERER_TYPE_OPENGLES: bgfx_renderer_type = 7;
#[doc = " ( 7) OpenGL ES 2.0+"]
pub const BGFX_RENDERER_TYPE_OPENGL: bgfx_renderer_type = 8;
#[doc = " ( 8) OpenGL 2.1+"]
pub const BGFX_RENDERER_TYPE_VULKAN: bgfx_renderer_type = 9;
#[doc = " ( 9) Vulkan"]
pub const BGFX_RENDERER_TYPE_COUNT: bgfx_renderer_type = 10;
#[doc = " Renderer backend type enum.\n"]
pub type bgfx_renderer_type = ::std::os::raw::c_uint;
#[doc = " Renderer backend type enum.\n"]
pub use self::bgfx_renderer_type as bgfx_renderer_type_t;
pub const BGFX_ACCESS_READ: bgfx_access = 0;
#[doc = " ( 0) Read."]
pub const BGFX_ACCESS_WRITE: bgfx_access = 1;
#[doc = " ( 1) Write."]
pub const BGFX_ACCESS_READWRITE: bgfx_access = 2;
#[doc = " ( 2) Read and write."]
pub const BGFX_ACCESS_COUNT: bgfx_access = 3;
#[doc = " Access mode enum.\n"]
pub type bgfx_access = ::std::os::raw::c_uint;
#[doc = " Access mode enum.\n"]
pub use self::bgfx_access as bgfx_access_t;
pub const BGFX_ATTRIB_POSITION: bgfx_attrib = 0;
#[doc = " ( 0) a_position"]
pub const BGFX_ATTRIB_NORMAL: bgfx_attrib = 1;
#[doc = " ( 1) a_normal"]
pub const BGFX_ATTRIB_TANGENT: bgfx_attrib = 2;
#[doc = " ( 2) a_tangent"]
pub const BGFX_ATTRIB_BITANGENT: bgfx_attrib = 3;
#[doc = " ( 3) a_bitangent"]
pub const BGFX_ATTRIB_COLOR0: bgfx_attrib = 4;
#[doc = " ( 4) a_color0"]
pub const BGFX_ATTRIB_COLOR1: bgfx_attrib = 5;
#[doc = " ( 5) a_color1"]
pub const BGFX_ATTRIB_COLOR2: bgfx_attrib = 6;
#[doc = " ( 6) a_color2"]
pub const BGFX_ATTRIB_COLOR3: bgfx_attrib = 7;
#[doc = " ( 7) a_color3"]
pub const BGFX_ATTRIB_INDICES: bgfx_attrib = 8;
#[doc = " ( 8) a_indices"]
pub const BGFX_ATTRIB_WEIGHT: bgfx_attrib = 9;
#[doc = " ( 9) a_weight"]
pub const BGFX_ATTRIB_TEXCOORD0: bgfx_attrib = 10;
#[doc = " (10) a_texcoord0"]
pub const BGFX_ATTRIB_TEXCOORD1: bgfx_attrib = 11;
#[doc = " (11) a_texcoord1"]
pub const BGFX_ATTRIB_TEXCOORD2: bgfx_attrib = 12;
#[doc = " (12) a_texcoord2"]
pub const BGFX_ATTRIB_TEXCOORD3: bgfx_attrib = 13;
#[doc = " (13) a_texcoord3"]
pub const BGFX_ATTRIB_TEXCOORD4: bgfx_attrib = 14;
#[doc = " (14) a_texcoord4"]
pub const BGFX_ATTRIB_TEXCOORD5: bgfx_attrib = 15;
#[doc = " (15) a_texcoord5"]
pub const BGFX_ATTRIB_TEXCOORD6: bgfx_attrib = 16;
#[doc = " (16) a_texcoord6"]
pub const BGFX_ATTRIB_TEXCOORD7: bgfx_attrib = 17;
#[doc = " (17) a_texcoord7"]
pub const BGFX_ATTRIB_COUNT: bgfx_attrib = 18;
#[doc = " Vertex attribute enum.\n"]
pub type bgfx_attrib = ::std::os::raw::c_uint;
#[doc = " Vertex attribute enum.\n"]
pub use self::bgfx_attrib as bgfx_attrib_t;
pub const BGFX_ATTRIB_TYPE_UINT8: bgfx_attrib_type = 0;
#[doc = " ( 0) Uint8"]
pub const BGFX_ATTRIB_TYPE_UINT10: bgfx_attrib_type = 1;
#[doc = " ( 1) Uint10, availability depends on: `BGFX_CAPS_VERTEX_ATTRIB_UINT10`."]
pub const BGFX_ATTRIB_TYPE_INT16: bgfx_attrib_type = 2;
#[doc = " ( 2) Int16"]
pub const BGFX_ATTRIB_TYPE_HALF: bgfx_attrib_type = 3;
#[doc = " ( 3) Half, availability depends on: `BGFX_CAPS_VERTEX_ATTRIB_HALF`."]
pub const BGFX_ATTRIB_TYPE_FLOAT: bgfx_attrib_type = 4;
#[doc = " ( 4) Float"]
pub const BGFX_ATTRIB_TYPE_COUNT: bgfx_attrib_type = 5;
#[doc = " Vertex attribute type enum.\n"]
pub type bgfx_attrib_type = ::std::os::raw::c_uint;
#[doc = " Vertex attribute type enum.\n"]
pub use self::bgfx_attrib_type as bgfx_attrib_type_t;
pub const BGFX_TEXTURE_FORMAT_BC1: bgfx_texture_format = 0;
#[doc = " ( 0) DXT1 R5G6B5A1"]
pub const BGFX_TEXTURE_FORMAT_BC2: bgfx_texture_format = 1;
#[doc = " ( 1) DXT3 R5G6B5A4"]
pub const BGFX_TEXTURE_FORMAT_BC3: bgfx_texture_format = 2;
#[doc = " ( 2) DXT5 R5G6B5A8"]
pub const BGFX_TEXTURE_FORMAT_BC4: bgfx_texture_format = 3;
#[doc = " ( 3) LATC1/ATI1 R8"]
pub const BGFX_TEXTURE_FORMAT_BC5: bgfx_texture_format = 4;
#[doc = " ( 4) LATC2/ATI2 RG8"]
pub const BGFX_TEXTURE_FORMAT_BC6H: bgfx_texture_format = 5;
#[doc = " ( 5) BC6H RGB16F"]
pub const BGFX_TEXTURE_FORMAT_BC7: bgfx_texture_format = 6;
#[doc = " ( 6) BC7 RGB 4-7 bits per color channel, 0-8 bits alpha"]
pub const BGFX_TEXTURE_FORMAT_ETC1: bgfx_texture_format = 7;
#[doc = " ( 7) ETC1 RGB8"]
pub const BGFX_TEXTURE_FORMAT_ETC2: bgfx_texture_format = 8;
#[doc = " ( 8) ETC2 RGB8"]
pub const BGFX_TEXTURE_FORMAT_ETC2A: bgfx_texture_format = 9;
#[doc = " ( 9) ETC2 RGBA8"]
pub const BGFX_TEXTURE_FORMAT_ETC2A1: bgfx_texture_format = 10;
#[doc = " (10) ETC2 RGB8A1"]
pub const BGFX_TEXTURE_FORMAT_PTC12: bgfx_texture_format = 11;
#[doc = " (11) PVRTC1 RGB 2BPP"]
pub const BGFX_TEXTURE_FORMAT_PTC14: bgfx_texture_format = 12;
#[doc = " (12) PVRTC1 RGB 4BPP"]
pub const BGFX_TEXTURE_FORMAT_PTC12A: bgfx_texture_format = 13;
#[doc = " (13) PVRTC1 RGBA 2BPP"]
pub const BGFX_TEXTURE_FORMAT_PTC14A: bgfx_texture_format = 14;
#[doc = " (14) PVRTC1 RGBA 4BPP"]
pub const BGFX_TEXTURE_FORMAT_PTC22: bgfx_texture_format = 15;
#[doc = " (15) PVRTC2 RGBA 2BPP"]
pub const BGFX_TEXTURE_FORMAT_PTC24: bgfx_texture_format = 16;
#[doc = " (16) PVRTC2 RGBA 4BPP"]
pub const BGFX_TEXTURE_FORMAT_ATC: bgfx_texture_format = 17;
#[doc = " (17) ATC RGB 4BPP"]
pub const BGFX_TEXTURE_FORMAT_ATCE: bgfx_texture_format = 18;
#[doc = " (18) ATCE RGBA 8 BPP explicit alpha"]
pub const BGFX_TEXTURE_FORMAT_ATCI: bgfx_texture_format = 19;
#[doc = " (19) ATCI RGBA 8 BPP interpolated alpha"]
pub const BGFX_TEXTURE_FORMAT_ASTC4X4: bgfx_texture_format = 20;
#[doc = " (20) ASTC 4x4 8.0 BPP"]
pub const BGFX_TEXTURE_FORMAT_ASTC5X4: bgfx_texture_format = 21;
#[doc = " (21) ASTC 5x4 6.40 BPP"]
pub const BGFX_TEXTURE_FORMAT_ASTC5X5: bgfx_texture_format = 22;
#[doc = " (22) ASTC 5x5 5.12 BPP"]
pub const BGFX_TEXTURE_FORMAT_ASTC6X5: bgfx_texture_format = 23;
#[doc = " (23) ASTC 6x5 4.27 BPP"]
pub const BGFX_TEXTURE_FORMAT_ASTC6X6: bgfx_texture_format = 24;
#[doc = " (24) ASTC 6x6 3.56 BPP"]
pub const BGFX_TEXTURE_FORMAT_ASTC8X5: bgfx_texture_format = 25;
#[doc = " (25) ASTC 8x5 3.20 BPP"]
pub const BGFX_TEXTURE_FORMAT_ASTC8X6: bgfx_texture_format = 26;
#[doc = " (26) ASTC 8x6 2.67 BPP"]
pub const BGFX_TEXTURE_FORMAT_ASTC8X8: bgfx_texture_format = 27;
#[doc = " (27) ASTC 8x8 2.00 BPP"]
pub const BGFX_TEXTURE_FORMAT_ASTC10X5: bgfx_texture_format = 28;
#[doc = " (28) ASTC 10x5 2.56 BPP"]
pub const BGFX_TEXTURE_FORMAT_ASTC10X6: bgfx_texture_format = 29;
#[doc = " (29) ASTC 10x6 2.13 BPP"]
pub const BGFX_TEXTURE_FORMAT_ASTC10X8: bgfx_texture_format = 30;
#[doc = " (30) ASTC 10x8 1.60 BPP"]
pub const BGFX_TEXTURE_FORMAT_ASTC10X10: bgfx_texture_format = 31;
#[doc = " (31) ASTC 10x10 1.28 BPP"]
pub const BGFX_TEXTURE_FORMAT_ASTC12X10: bgfx_texture_format = 32;
#[doc = " (32) ASTC 12x10 1.07 BPP"]
pub const BGFX_TEXTURE_FORMAT_ASTC12X12: bgfx_texture_format = 33;
#[doc = " (33) ASTC 12x12 0.89 BPP"]
pub const BGFX_TEXTURE_FORMAT_UNKNOWN: bgfx_texture_format = 34;
#[doc = " (34) Compressed formats above."]
pub const BGFX_TEXTURE_FORMAT_R1: bgfx_texture_format = 35;
#[doc = " (35)"]
pub const BGFX_TEXTURE_FORMAT_A8: bgfx_texture_format = 36;
#[doc = " (36)"]
pub const BGFX_TEXTURE_FORMAT_R8: bgfx_texture_format = 37;
#[doc = " (37)"]
pub const BGFX_TEXTURE_FORMAT_R8I: bgfx_texture_format = 38;
#[doc = " (38)"]
pub const BGFX_TEXTURE_FORMAT_R8U: bgfx_texture_format = 39;
#[doc = " (39)"]
pub const BGFX_TEXTURE_FORMAT_R8S: bgfx_texture_format = 40;
#[doc = " (40)"]
pub const BGFX_TEXTURE_FORMAT_R16: bgfx_texture_format = 41;
#[doc = " (41)"]
pub const BGFX_TEXTURE_FORMAT_R16I: bgfx_texture_format = 42;
#[doc = " (42)"]
pub const BGFX_TEXTURE_FORMAT_R16U: bgfx_texture_format = 43;
#[doc = " (43)"]
pub const BGFX_TEXTURE_FORMAT_R16F: bgfx_texture_format = 44;
#[doc = " (44)"]
pub const BGFX_TEXTURE_FORMAT_R16S: bgfx_texture_format = 45;
#[doc = " (45)"]
pub const BGFX_TEXTURE_FORMAT_R32I: bgfx_texture_format = 46;
#[doc = " (46)"]
pub const BGFX_TEXTURE_FORMAT_R32U: bgfx_texture_format = 47;
#[doc = " (47)"]
pub const BGFX_TEXTURE_FORMAT_R32F: bgfx_texture_format = 48;
#[doc = " (48)"]
pub const BGFX_TEXTURE_FORMAT_RG8: bgfx_texture_format = 49;
#[doc = " (49)"]
pub const BGFX_TEXTURE_FORMAT_RG8I: bgfx_texture_format = 50;
#[doc = " (50)"]
pub const BGFX_TEXTURE_FORMAT_RG8U: bgfx_texture_format = 51;
#[doc = " (51)"]
pub const BGFX_TEXTURE_FORMAT_RG8S: bgfx_texture_format = 52;
#[doc = " (52)"]
pub const BGFX_TEXTURE_FORMAT_RG16: bgfx_texture_format = 53;
#[doc = " (53)"]
pub const BGFX_TEXTURE_FORMAT_RG16I: bgfx_texture_format = 54;
#[doc = " (54)"]
pub const BGFX_TEXTURE_FORMAT_RG16U: bgfx_texture_format = 55;
#[doc = " (55)"]
pub const BGFX_TEXTURE_FORMAT_RG16F: bgfx_texture_format = 56;
#[doc = " (56)"]
pub const BGFX_TEXTURE_FORMAT_RG16S: bgfx_texture_format = 57;
#[doc = " (57)"]
pub const BGFX_TEXTURE_FORMAT_RG32I: bgfx_texture_format = 58;
#[doc = " (58)"]
pub const BGFX_TEXTURE_FORMAT_RG32U: bgfx_texture_format = 59;
#[doc = " (59)"]
pub const BGFX_TEXTURE_FORMAT_RG32F: bgfx_texture_format = 60;
#[doc = " (60)"]
pub const BGFX_TEXTURE_FORMAT_RGB8: bgfx_texture_format = 61;
#[doc = " (61)"]
pub const BGFX_TEXTURE_FORMAT_RGB8I: bgfx_texture_format = 62;
#[doc = " (62)"]
pub const BGFX_TEXTURE_FORMAT_RGB8U: bgfx_texture_format = 63;
#[doc = " (63)"]
pub const BGFX_TEXTURE_FORMAT_RGB8S: bgfx_texture_format = 64;
#[doc = " (64)"]
pub const BGFX_TEXTURE_FORMAT_RGB9E5F: bgfx_texture_format = 65;
#[doc = " (65)"]
pub const BGFX_TEXTURE_FORMAT_BGRA8: bgfx_texture_format = 66;
#[doc = " (66)"]
pub const BGFX_TEXTURE_FORMAT_RGBA8: bgfx_texture_format = 67;
#[doc = " (67)"]
pub const BGFX_TEXTURE_FORMAT_RGBA8I: bgfx_texture_format = 68;
#[doc = " (68)"]
pub const BGFX_TEXTURE_FORMAT_RGBA8U: bgfx_texture_format = 69;
#[doc = " (69)"]
pub const BGFX_TEXTURE_FORMAT_RGBA8S: bgfx_texture_format = 70;
#[doc = " (70)"]
pub const BGFX_TEXTURE_FORMAT_RGBA16: bgfx_texture_format = 71;
#[doc = " (71)"]
pub const BGFX_TEXTURE_FORMAT_RGBA16I: bgfx_texture_format = 72;
#[doc = " (72)"]
pub const BGFX_TEXTURE_FORMAT_RGBA16U: bgfx_texture_format = 73;
#[doc = " (73)"]
pub const BGFX_TEXTURE_FORMAT_RGBA16F: bgfx_texture_format = 74;
#[doc = " (74)"]
pub const BGFX_TEXTURE_FORMAT_RGBA16S: bgfx_texture_format = 75;
#[doc = " (75)"]
pub const BGFX_TEXTURE_FORMAT_RGBA32I: bgfx_texture_format = 76;
#[doc = " (76)"]
pub const BGFX_TEXTURE_FORMAT_RGBA32U: bgfx_texture_format = 77;
#[doc = " (77)"]
pub const BGFX_TEXTURE_FORMAT_RGBA32F: bgfx_texture_format = 78;
#[doc = " (78)"]
pub const BGFX_TEXTURE_FORMAT_B5G6R5: bgfx_texture_format = 79;
#[doc = " (79)"]
pub const BGFX_TEXTURE_FORMAT_R5G6B5: bgfx_texture_format = 80;
#[doc = " (80)"]
pub const BGFX_TEXTURE_FORMAT_BGRA4: bgfx_texture_format = 81;
#[doc = " (81)"]
pub const BGFX_TEXTURE_FORMAT_RGBA4: bgfx_texture_format = 82;
#[doc = " (82)"]
pub const BGFX_TEXTURE_FORMAT_BGR5A1: bgfx_texture_format = 83;
#[doc = " (83)"]
pub const BGFX_TEXTURE_FORMAT_RGB5A1: bgfx_texture_format = 84;
#[doc = " (84)"]
pub const BGFX_TEXTURE_FORMAT_RGB10A2: bgfx_texture_format = 85;
#[doc = " (85)"]
pub const BGFX_TEXTURE_FORMAT_RG11B10F: bgfx_texture_format = 86;
#[doc = " (86)"]
pub const BGFX_TEXTURE_FORMAT_UNKNOWNDEPTH: bgfx_texture_format = 87;
#[doc = " (87) Depth formats below."]
pub const BGFX_TEXTURE_FORMAT_D16: bgfx_texture_format = 88;
#[doc = " (88)"]
pub const BGFX_TEXTURE_FORMAT_D24: bgfx_texture_format = 89;
#[doc = " (89)"]
pub const BGFX_TEXTURE_FORMAT_D24S8: bgfx_texture_format = 90;
#[doc = " (90)"]
pub const BGFX_TEXTURE_FORMAT_D32: bgfx_texture_format = 91;
#[doc = " (91)"]
pub const BGFX_TEXTURE_FORMAT_D16F: bgfx_texture_format = 92;
#[doc = " (92)"]
pub const BGFX_TEXTURE_FORMAT_D24F: bgfx_texture_format = 93;
#[doc = " (93)"]
pub const BGFX_TEXTURE_FORMAT_D32F: bgfx_texture_format = 94;
#[doc = " (94)"]
pub const BGFX_TEXTURE_FORMAT_D0S8: bgfx_texture_format = 95;
#[doc = " (95)"]
pub const BGFX_TEXTURE_FORMAT_COUNT: bgfx_texture_format = 96;
#[doc = " Texture format enum.\n Notation:\n	   RGBA16S\n	   ^   ^ ^\n	   |   | +-- [ ]Unorm\n	   |   |	 [F]loat\n	   |   |	 [S]norm\n	   |   |	 [I]nt\n	   |   |	 [U]int\n	   |   +---- Number of bits per component\n	   +-------- Components\n @attention Availability depends on Caps (see: formats).\n"]
pub type bgfx_texture_format = ::std::os::raw::c_uint;
#[doc = " Texture format enum.\n Notation:\n	   RGBA16S\n	   ^   ^ ^\n	   |   | +-- [ ]Unorm\n	   |   |	 [F]loat\n	   |   |	 [S]norm\n	   |   |	 [I]nt\n	   |   |	 [U]int\n	   |   +---- Number of bits per component\n	   +-------- Components\n @attention Availability depends on Caps (see: formats).\n"]
pub use self::bgfx_texture_format as bgfx_texture_format_t;
pub const BGFX_UNIFORM_TYPE_SAMPLER: bgfx_uniform_type = 0;
#[doc = " ( 0) Sampler."]
pub const BGFX_UNIFORM_TYPE_END: bgfx_uniform_type = 1;
#[doc = " ( 1) Reserved, do not use."]
pub const BGFX_UNIFORM_TYPE_VEC4: bgfx_uniform_type = 2;
#[doc = " ( 2) 4 floats vector."]
pub const BGFX_UNIFORM_TYPE_MAT3: bgfx_uniform_type = 3;
#[doc = " ( 3) 3x3 matrix."]
pub const BGFX_UNIFORM_TYPE_MAT4: bgfx_uniform_type = 4;
#[doc = " ( 4) 4x4 matrix."]
pub const BGFX_UNIFORM_TYPE_COUNT: bgfx_uniform_type = 5;
#[doc = " Uniform type enum.\n"]
pub type bgfx_uniform_type = ::std::os::raw::c_uint;
#[doc = " Uniform type enum.\n"]
pub use self::bgfx_uniform_type as bgfx_uniform_type_t;
pub const BGFX_BACKBUFFER_RATIO_EQUAL: bgfx_backbuffer_ratio = 0;
#[doc = " ( 0) Equal to backbuffer."]
pub const BGFX_BACKBUFFER_RATIO_HALF: bgfx_backbuffer_ratio = 1;
#[doc = " ( 1) One half size of backbuffer."]
pub const BGFX_BACKBUFFER_RATIO_QUARTER: bgfx_backbuffer_ratio = 2;
#[doc = " ( 2) One quarter size of backbuffer."]
pub const BGFX_BACKBUFFER_RATIO_EIGHTH: bgfx_backbuffer_ratio = 3;
#[doc = " ( 3) One eighth size of backbuffer."]
pub const BGFX_BACKBUFFER_RATIO_SIXTEENTH: bgfx_backbuffer_ratio = 4;
#[doc = " ( 4) One sixteenth size of backbuffer."]
pub const BGFX_BACKBUFFER_RATIO_DOUBLE: bgfx_backbuffer_ratio = 5;
#[doc = " ( 5) Double size of backbuffer."]
pub const BGFX_BACKBUFFER_RATIO_COUNT: bgfx_backbuffer_ratio = 6;
#[doc = " Backbuffer ratio enum.\n"]
pub type bgfx_backbuffer_ratio = ::std::os::raw::c_uint;
#[doc = " Backbuffer ratio enum.\n"]
pub use self::bgfx_backbuffer_ratio as bgfx_backbuffer_ratio_t;
pub const BGFX_OCCLUSION_QUERY_RESULT_INVISIBLE: bgfx_occlusion_query_result = 0;
#[doc = " ( 0) Query failed test."]
pub const BGFX_OCCLUSION_QUERY_RESULT_VISIBLE: bgfx_occlusion_query_result = 1;
#[doc = " ( 1) Query passed test."]
pub const BGFX_OCCLUSION_QUERY_RESULT_NORESULT: bgfx_occlusion_query_result = 2;
#[doc = " ( 2) Query result is not available yet."]
pub const BGFX_OCCLUSION_QUERY_RESULT_COUNT: bgfx_occlusion_query_result = 3;
#[doc = " Occlusion query result.\n"]
pub type bgfx_occlusion_query_result = ::std::os::raw::c_uint;
#[doc = " Occlusion query result.\n"]
pub use self::bgfx_occlusion_query_result as bgfx_occlusion_query_result_t;
pub const BGFX_TOPOLOGY_TRI_LIST: bgfx_topology = 0;
#[doc = " ( 0) Triangle list."]
pub const BGFX_TOPOLOGY_TRI_STRIP: bgfx_topology = 1;
#[doc = " ( 1) Triangle strip."]
pub const BGFX_TOPOLOGY_LINE_LIST: bgfx_topology = 2;
#[doc = " ( 2) Line list."]
pub const BGFX_TOPOLOGY_LINE_STRIP: bgfx_topology = 3;
#[doc = " ( 3) Line strip."]
pub const BGFX_TOPOLOGY_POINT_LIST: bgfx_topology = 4;
#[doc = " ( 4) Point list."]
pub const BGFX_TOPOLOGY_COUNT: bgfx_topology = 5;
#[doc = " Primitive topology.\n"]
pub type bgfx_topology = ::std::os::raw::c_uint;
#[doc = " Primitive topology.\n"]
pub use self::bgfx_topology as bgfx_topology_t;
pub const BGFX_TOPOLOGY_CONVERT_TRI_LIST_FLIP_WINDING: bgfx_topology_convert = 0;
#[doc = " ( 0) Flip winding order of triangle list."]
pub const BGFX_TOPOLOGY_CONVERT_TRI_STRIP_FLIP_WINDING: bgfx_topology_convert = 1;
#[doc = " ( 1) Flip winding order of triangle strip."]
pub const BGFX_TOPOLOGY_CONVERT_TRI_LIST_TO_LINE_LIST: bgfx_topology_convert = 2;
#[doc = " ( 2) Convert triangle list to line list."]
pub const BGFX_TOPOLOGY_CONVERT_TRI_STRIP_TO_TRI_LIST: bgfx_topology_convert = 3;
#[doc = " ( 3) Convert triangle strip to triangle list."]
pub const BGFX_TOPOLOGY_CONVERT_LINE_STRIP_TO_LINE_LIST: bgfx_topology_convert = 4;
#[doc = " ( 4) Convert line strip to line list."]
pub const BGFX_TOPOLOGY_CONVERT_COUNT: bgfx_topology_convert = 5;
#[doc = " Topology conversion function.\n"]
pub type bgfx_topology_convert = ::std::os::raw::c_uint;
#[doc = " Topology conversion function.\n"]
pub use self::bgfx_topology_convert as bgfx_topology_convert_t;
pub const BGFX_TOPOLOGY_SORT_DIRECTION_FRONT_TO_BACK_MIN: bgfx_topology_sort = 0;
#[doc = " ( 0)"]
pub const BGFX_TOPOLOGY_SORT_DIRECTION_FRONT_TO_BACK_AVG: bgfx_topology_sort = 1;
#[doc = " ( 1)"]
pub const BGFX_TOPOLOGY_SORT_DIRECTION_FRONT_TO_BACK_MAX: bgfx_topology_sort = 2;
#[doc = " ( 2)"]
pub const BGFX_TOPOLOGY_SORT_DIRECTION_BACK_TO_FRONT_MIN: bgfx_topology_sort = 3;
#[doc = " ( 3)"]
pub const BGFX_TOPOLOGY_SORT_DIRECTION_BACK_TO_FRONT_AVG: bgfx_topology_sort = 4;
#[doc = " ( 4)"]
pub const BGFX_TOPOLOGY_SORT_DIRECTION_BACK_TO_FRONT_MAX: bgfx_topology_sort = 5;
#[doc = " ( 5)"]
pub const BGFX_TOPOLOGY_SORT_DISTANCE_FRONT_TO_BACK_MIN: bgfx_topology_sort = 6;
#[doc = " ( 6)"]
pub const BGFX_TOPOLOGY_SORT_DISTANCE_FRONT_TO_BACK_AVG: bgfx_topology_sort = 7;
#[doc = " ( 7)"]
pub const BGFX_TOPOLOGY_SORT_DISTANCE_FRONT_TO_BACK_MAX: bgfx_topology_sort = 8;
#[doc = " ( 8)"]
pub const BGFX_TOPOLOGY_SORT_DISTANCE_BACK_TO_FRONT_MIN: bgfx_topology_sort = 9;
#[doc = " ( 9)"]
pub const BGFX_TOPOLOGY_SORT_DISTANCE_BACK_TO_FRONT_AVG: bgfx_topology_sort = 10;
#[doc = " (10)"]
pub const BGFX_TOPOLOGY_SORT_DISTANCE_BACK_TO_FRONT_MAX: bgfx_topology_sort = 11;
#[doc = " (11)"]
pub const BGFX_TOPOLOGY_SORT_COUNT: bgfx_topology_sort = 12;
#[doc = " Topology sort order.\n"]
pub type bgfx_topology_sort = ::std::os::raw::c_uint;
#[doc = " Topology sort order.\n"]
pub use self::bgfx_topology_sort as bgfx_topology_sort_t;
pub const BGFX_VIEW_MODE_DEFAULT: bgfx_view_mode = 0;
#[doc = " ( 0) Default sort order."]
pub const BGFX_VIEW_MODE_SEQUENTIAL: bgfx_view_mode = 1;
#[doc = " ( 1) Sort in the same order in which submit calls were called."]
pub const BGFX_VIEW_MODE_DEPTH_ASCENDING: bgfx_view_mode = 2;
#[doc = " ( 2) Sort draw call depth in ascending order."]
pub const BGFX_VIEW_MODE_DEPTH_DESCENDING: bgfx_view_mode = 3;
#[doc = " ( 3) Sort draw call depth in descending order."]
pub const BGFX_VIEW_MODE_COUNT: bgfx_view_mode = 4;
#[doc = " View mode sets draw call sort order.\n"]
pub type bgfx_view_mode = ::std::os::raw::c_uint;
#[doc = " View mode sets draw call sort order.\n"]
pub use self::bgfx_view_mode as bgfx_view_mode_t;
pub const BGFX_NATIVE_WINDOW_HANDLE_TYPE_DEFAULT: bgfx_native_window_handle_type = 0;
#[doc = " ( 0) Platform default handle type (X11 on Linux)."]
pub const BGFX_NATIVE_WINDOW_HANDLE_TYPE_WAYLAND: bgfx_native_window_handle_type = 1;
#[doc = " ( 1) Wayland."]
pub const BGFX_NATIVE_WINDOW_HANDLE_TYPE_COUNT: bgfx_native_window_handle_type = 2;
#[doc = " Native window handle type.\n"]
pub type bgfx_native_window_handle_type = ::std::os::raw::c_uint;
#[doc = " Native window handle type.\n"]
pub use self::bgfx_native_window_handle_type as bgfx_native_window_handle_type_t;
pub const BGFX_RENDER_FRAME_NO_CONTEXT: bgfx_render_frame = 0;
#[doc = " ( 0) Renderer context is not created yet."]
pub const BGFX_RENDER_FRAME_RENDER: bgfx_render_frame = 1;
#[doc = " ( 1) Renderer context is created and rendering."]
pub const BGFX_RENDER_FRAME_TIMEOUT: bgfx_render_frame = 2;
#[doc = " ( 2) Renderer context wait for main thread signal timed out without rendering."]
pub const BGFX_RENDER_FRAME_EXITING: bgfx_render_frame = 3;
#[doc = " ( 3) Renderer context is getting destroyed."]
pub const BGFX_RENDER_FRAME_COUNT: bgfx_render_frame = 4;
#[doc = " Render frame enum.\n"]
pub type bgfx_render_frame = ::std::os::raw::c_uint;
#[doc = " Render frame enum.\n"]
pub use self::bgfx_render_frame as bgfx_render_frame_t;
pub type bgfx_view_id_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_allocator_interface_s {
	pub vtbl: *const bgfx_allocator_vtbl_s,
}
pub type bgfx_allocator_interface_t = bgfx_allocator_interface_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_allocator_vtbl_s {
	pub realloc: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_allocator_interface_t,
			_ptr: *mut ::std::os::raw::c_void,
			_size: usize,
			_align: usize,
			_file: *const ::std::os::raw::c_char,
			_line: u32,
		) -> *mut ::std::os::raw::c_void,
	>,
}
pub type bgfx_allocator_vtbl_t = bgfx_allocator_vtbl_s;
pub type bgfx_interface_vtbl_t = bgfx_interface_vtbl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_callback_interface_s {
	pub vtbl: *const bgfx_callback_vtbl_s,
}
pub type bgfx_callback_interface_t = bgfx_callback_interface_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_callback_vtbl_s {
	pub fatal: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_callback_interface_t,
			_filePath: *const ::std::os::raw::c_char,
			_line: u16,
			_code: bgfx_fatal_t,
			_str: *const ::std::os::raw::c_char,
		),
	>,
	pub trace_vargs: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_callback_interface_t,
			_filePath: *const ::std::os::raw::c_char,
			_line: u16,
			_format: *const ::std::os::raw::c_char,
			_argList: va_list,
		),
	>,
	pub profiler_begin: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_callback_interface_t,
			_name: *const ::std::os::raw::c_char,
			_abgr: u32,
			_filePath: *const ::std::os::raw::c_char,
			_line: u16,
		),
	>,
	pub profiler_begin_literal: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_callback_interface_t,
			_name: *const ::std::os::raw::c_char,
			_abgr: u32,
			_filePath: *const ::std::os::raw::c_char,
			_line: u16,
		),
	>,
	pub profiler_end:
		::std::option::Option<unsafe extern "C" fn(_this: *mut bgfx_callback_interface_t)>,
	pub cache_read_size: ::std::option::Option<
		unsafe extern "C" fn(_this: *mut bgfx_callback_interface_t, _id: u64) -> u32,
	>,
	pub cache_read: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_callback_interface_t,
			_id: u64,
			_data: *mut ::std::os::raw::c_void,
			_size: u32,
		) -> bool,
	>,
	pub cache_write: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_callback_interface_t,
			_id: u64,
			_data: *const ::std::os::raw::c_void,
			_size: u32,
		),
	>,
	pub screen_shot: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_callback_interface_t,
			_filePath: *const ::std::os::raw::c_char,
			_width: u32,
			_height: u32,
			_pitch: u32,
			_data: *const ::std::os::raw::c_void,
			_size: u32,
			_yflip: bool,
		),
	>,
	pub capture_begin: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_callback_interface_t,
			_width: u32,
			_height: u32,
			_pitch: u32,
			_format: bgfx_texture_format_t,
			_yflip: bool,
		),
	>,
	pub capture_end:
		::std::option::Option<unsafe extern "C" fn(_this: *mut bgfx_callback_interface_t)>,
	pub capture_frame: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_callback_interface_t,
			_data: *const ::std::os::raw::c_void,
			_size: u32,
		),
	>,
}
pub type bgfx_callback_vtbl_t = bgfx_callback_vtbl_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_dynamic_index_buffer_handle_s {
	pub idx: u16,
}
pub type bgfx_dynamic_index_buffer_handle_t = bgfx_dynamic_index_buffer_handle_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_dynamic_vertex_buffer_handle_s {
	pub idx: u16,
}
pub type bgfx_dynamic_vertex_buffer_handle_t = bgfx_dynamic_vertex_buffer_handle_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_frame_buffer_handle_s {
	pub idx: u16,
}
pub type bgfx_frame_buffer_handle_t = bgfx_frame_buffer_handle_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_index_buffer_handle_s {
	pub idx: u16,
}
pub type bgfx_index_buffer_handle_t = bgfx_index_buffer_handle_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_indirect_buffer_handle_s {
	pub idx: u16,
}
pub type bgfx_indirect_buffer_handle_t = bgfx_indirect_buffer_handle_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_occlusion_query_handle_s {
	pub idx: u16,
}
pub type bgfx_occlusion_query_handle_t = bgfx_occlusion_query_handle_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_program_handle_s {
	pub idx: u16,
}
pub type bgfx_program_handle_t = bgfx_program_handle_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_shader_handle_s {
	pub idx: u16,
}
pub type bgfx_shader_handle_t = bgfx_shader_handle_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_texture_handle_s {
	pub idx: u16,
}
pub type bgfx_texture_handle_t = bgfx_texture_handle_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_uniform_handle_s {
	pub idx: u16,
}
pub type bgfx_uniform_handle_t = bgfx_uniform_handle_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_vertex_buffer_handle_s {
	pub idx: u16,
}
pub type bgfx_vertex_buffer_handle_t = bgfx_vertex_buffer_handle_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_vertex_layout_handle_s {
	pub idx: u16,
}
pub type bgfx_vertex_layout_handle_t = bgfx_vertex_layout_handle_s;
#[doc = " Memory release callback.\n\n @param[in] _ptr Pointer to allocated data.\n @param[in] _userData User defined data if needed.\n"]
pub type bgfx_release_fn_t = ::std::option::Option<
	unsafe extern "C" fn(_ptr: *mut ::std::os::raw::c_void, _userData: *mut ::std::os::raw::c_void),
>;
#[doc = " GPU info.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_caps_gpu_s {
	pub vendorId: u16,
	#[doc = " Vendor PCI id. See `BGFX_PCI_ID_*`."]
	pub deviceId: u16,
}
#[doc = " GPU info.\n"]
pub type bgfx_caps_gpu_t = bgfx_caps_gpu_s;
#[doc = " Renderer runtime limits.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_caps_limits_s {
	pub maxDrawCalls: u32,
	#[doc = " Maximum number of draw calls."]
	pub maxBlits: u32,
	#[doc = " Maximum number of blit calls."]
	pub maxTextureSize: u32,
	#[doc = " Maximum texture size."]
	pub maxTextureLayers: u32,
	#[doc = " Maximum texture layers."]
	pub maxViews: u32,
	#[doc = " Maximum number of views."]
	pub maxFrameBuffers: u32,
	#[doc = " Maximum number of frame buffer handles."]
	pub maxFBAttachments: u32,
	#[doc = " Maximum number of frame buffer attachments."]
	pub maxPrograms: u32,
	#[doc = " Maximum number of program handles."]
	pub maxShaders: u32,
	#[doc = " Maximum number of shader handles."]
	pub maxTextures: u32,
	#[doc = " Maximum number of texture handles."]
	pub maxTextureSamplers: u32,
	#[doc = " Maximum number of texture samplers."]
	pub maxComputeBindings: u32,
	#[doc = " Maximum number of compute bindings."]
	pub maxVertexLayouts: u32,
	#[doc = " Maximum number of vertex format layouts."]
	pub maxVertexStreams: u32,
	#[doc = " Maximum number of vertex streams."]
	pub maxIndexBuffers: u32,
	#[doc = " Maximum number of index buffer handles."]
	pub maxVertexBuffers: u32,
	#[doc = " Maximum number of vertex buffer handles."]
	pub maxDynamicIndexBuffers: u32,
	#[doc = " Maximum number of dynamic index buffer handles."]
	pub maxDynamicVertexBuffers: u32,
	#[doc = " Maximum number of dynamic vertex buffer handles."]
	pub maxUniforms: u32,
	#[doc = " Maximum number of uniform handles."]
	pub maxOcclusionQueries: u32,
	#[doc = " Maximum number of occlusion query handles."]
	pub maxEncoders: u32,
	#[doc = " Maximum number of encoder threads."]
	pub minResourceCbSize: u32,
	#[doc = " Minimum resource command buffer size."]
	pub transientVbSize: u32,
	#[doc = " Maximum transient vertex buffer size."]
	pub transientIbSize: u32,
}
#[doc = " Renderer runtime limits.\n"]
pub type bgfx_caps_limits_t = bgfx_caps_limits_s;
#[doc = " Renderer capabilities.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_caps_s {
	pub rendererType: bgfx_renderer_type_t,
	#[doc = " Supported functionality.\n   @attention See `BGFX_CAPS_*` flags at https://bkaradzic.github.io/bgfx/bgfx.html#available-caps"]
	pub supported: u64,
	pub vendorId: u16,
	#[doc = " Selected GPU vendor PCI id."]
	pub deviceId: u16,
	#[doc = " Selected GPU device id."]
	pub homogeneousDepth: bool,
	#[doc = " True when NDC depth is in [-1, 1] range, otherwise its [0, 1]."]
	pub originBottomLeft: bool,
	#[doc = " True when NDC origin is at bottom left."]
	pub numGPUs: u8,
	#[doc = " Number of enumerated GPUs."]
	pub gpu: [bgfx_caps_gpu_t; 4usize],
	#[doc = " Enumerated GPUs."]
	pub limits: bgfx_caps_limits_t,
	#[doc = " Supported texture format capabilities flags:\n   - `BGFX_CAPS_FORMAT_TEXTURE_NONE` - Texture format is not supported.\n   - `BGFX_CAPS_FORMAT_TEXTURE_2D` - Texture format is supported.\n   - `BGFX_CAPS_FORMAT_TEXTURE_2D_SRGB` - Texture as sRGB format is supported.\n   - `BGFX_CAPS_FORMAT_TEXTURE_2D_EMULATED` - Texture format is emulated.\n   - `BGFX_CAPS_FORMAT_TEXTURE_3D` - Texture format is supported.\n   - `BGFX_CAPS_FORMAT_TEXTURE_3D_SRGB` - Texture as sRGB format is supported.\n   - `BGFX_CAPS_FORMAT_TEXTURE_3D_EMULATED` - Texture format is emulated.\n   - `BGFX_CAPS_FORMAT_TEXTURE_CUBE` - Texture format is supported.\n   - `BGFX_CAPS_FORMAT_TEXTURE_CUBE_SRGB` - Texture as sRGB format is supported.\n   - `BGFX_CAPS_FORMAT_TEXTURE_CUBE_EMULATED` - Texture format is emulated.\n   - `BGFX_CAPS_FORMAT_TEXTURE_VERTEX` - Texture format can be used from vertex shader.\n   - `BGFX_CAPS_FORMAT_TEXTURE_IMAGE_READ` - Texture format can be used as image\n	 and read from.\n   - `BGFX_CAPS_FORMAT_TEXTURE_IMAGE_WRITE` - Texture format can be used as image\n	 and written to.\n   - `BGFX_CAPS_FORMAT_TEXTURE_FRAMEBUFFER` - Texture format can be used as frame\n	 buffer.\n   - `BGFX_CAPS_FORMAT_TEXTURE_FRAMEBUFFER_MSAA` - Texture format can be used as MSAA\n	 frame buffer.\n   - `BGFX_CAPS_FORMAT_TEXTURE_MSAA` - Texture can be sampled as MSAA.\n   - `BGFX_CAPS_FORMAT_TEXTURE_MIP_AUTOGEN` - Texture format supports auto-generated\n	 mips."]
	pub formats: [u16; 96usize],
}
#[doc = " Renderer capabilities.\n"]
pub type bgfx_caps_t = bgfx_caps_s;
#[doc = " Internal data.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_internal_data_s {
	pub caps: *const bgfx_caps_t,
	#[doc = " Renderer capabilities."]
	pub context: *mut ::std::os::raw::c_void,
}
#[doc = " Internal data.\n"]
pub type bgfx_internal_data_t = bgfx_internal_data_s;
#[doc = " Platform data.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_platform_data_s {
	pub ndt: *mut ::std::os::raw::c_void,
	#[doc = " Native window handle. If `NULL`, bgfx will create a headless\n context/device, provided the rendering API supports it."]
	pub nwh: *mut ::std::os::raw::c_void,
	#[doc = " GL context, D3D device, or Vulkan device. If `NULL`, bgfx\n will create context/device."]
	pub context: *mut ::std::os::raw::c_void,
	#[doc = " GL back-buffer, or D3D render target view. If `NULL` bgfx will\n create back-buffer color surface."]
	pub backBuffer: *mut ::std::os::raw::c_void,
	#[doc = " Backbuffer depth/stencil. If `NULL`, bgfx will create a back-buffer\n depth/stencil surface."]
	pub backBufferDS: *mut ::std::os::raw::c_void,
	pub type_: bgfx_native_window_handle_type_t,
}
#[doc = " Platform data.\n"]
pub type bgfx_platform_data_t = bgfx_platform_data_s;
#[doc = " Backbuffer resolution and reset parameters.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_resolution_s {
	pub format: bgfx_texture_format_t,
	#[doc = " Backbuffer format."]
	pub width: u32,
	#[doc = " Backbuffer width."]
	pub height: u32,
	#[doc = " Backbuffer height."]
	pub reset: u32,
	#[doc = " Reset parameters."]
	pub numBackBuffers: u8,
	#[doc = " Number of back buffers."]
	pub maxFrameLatency: u8,
	#[doc = " Maximum frame latency."]
	pub debugTextScale: u8,
}
#[doc = " Backbuffer resolution and reset parameters.\n"]
pub type bgfx_resolution_t = bgfx_resolution_s;
#[doc = " Configurable runtime limits parameters.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_init_limits_s {
	pub maxEncoders: u16,
	#[doc = " Maximum number of encoder threads."]
	pub minResourceCbSize: u32,
	#[doc = " Minimum resource command buffer size."]
	pub transientVbSize: u32,
	#[doc = " Maximum transient vertex buffer size."]
	pub transientIbSize: u32,
}
#[doc = " Configurable runtime limits parameters.\n"]
pub type bgfx_init_limits_t = bgfx_init_limits_s;
#[doc = " Initialization parameters used by `bgfx::init`.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_init_s {
	#[doc = " Select rendering backend. When set to RendererType::Count\n a default rendering backend will be selected appropriate to the platform.\n See: `bgfx::RendererType`"]
	pub type_: bgfx_renderer_type_t,
	#[doc = " Vendor PCI ID. If set to `BGFX_PCI_ID_NONE`, discrete and integrated\n GPUs will be prioritised.\n   - `BGFX_PCI_ID_NONE` - Autoselect adapter.\n   - `BGFX_PCI_ID_SOFTWARE_RASTERIZER` - Software rasterizer.\n   - `BGFX_PCI_ID_AMD` - AMD adapter.\n   - `BGFX_PCI_ID_APPLE` - Apple adapter.\n   - `BGFX_PCI_ID_INTEL` - Intel adapter.\n   - `BGFX_PCI_ID_NVIDIA` - NVIDIA adapter.\n   - `BGFX_PCI_ID_MICROSOFT` - Microsoft adapter."]
	pub vendorId: u16,
	#[doc = " Device ID. If set to 0 it will select first device, or device with\n matching ID."]
	pub deviceId: u16,
	pub capabilities: u64,
	#[doc = " Capabilities initialization mask (default: UINT64_MAX)."]
	pub debug: bool,
	#[doc = " Enable device for debugging."]
	pub profile: bool,
	#[doc = " Enable device for profiling."]
	pub platformData: bgfx_platform_data_t,
	#[doc = " Platform data."]
	pub resolution: bgfx_resolution_t,
	#[doc = " Backbuffer resolution and reset parameters. See: `bgfx::Resolution`."]
	pub limits: bgfx_init_limits_t,
	#[doc = " Provide application specific callback interface.\n See: `bgfx::CallbackI`"]
	pub callback: *mut bgfx_callback_interface_t,
	#[doc = " Custom allocator. When a custom allocator is not\n specified, bgfx uses the CRT allocator. Bgfx assumes\n custom allocator is thread safe."]
	pub allocator: *mut bgfx_allocator_interface_t,
}
#[doc = " Initialization parameters used by `bgfx::init`.\n"]
pub type bgfx_init_t = bgfx_init_s;
#[doc = " Memory must be obtained by calling `bgfx::alloc`, `bgfx::copy`, or `bgfx::makeRef`.\n @attention It is illegal to create this structure on stack and pass it to any bgfx API.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_memory_s {
	pub data: *mut u8,
	#[doc = " Pointer to data."]
	pub size: u32,
}
#[doc = " Memory must be obtained by calling `bgfx::alloc`, `bgfx::copy`, or `bgfx::makeRef`.\n @attention It is illegal to create this structure on stack and pass it to any bgfx API.\n"]
pub type bgfx_memory_t = bgfx_memory_s;
#[doc = " Transient index buffer.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_transient_index_buffer_s {
	pub data: *mut u8,
	#[doc = " Pointer to data."]
	pub size: u32,
	#[doc = " Data size."]
	pub startIndex: u32,
	#[doc = " First index."]
	pub handle: bgfx_index_buffer_handle_t,
	#[doc = " Index buffer handle."]
	pub isIndex16: bool,
}
#[doc = " Transient index buffer.\n"]
pub type bgfx_transient_index_buffer_t = bgfx_transient_index_buffer_s;
#[doc = " Transient vertex buffer.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_transient_vertex_buffer_s {
	pub data: *mut u8,
	#[doc = " Pointer to data."]
	pub size: u32,
	#[doc = " Data size."]
	pub startVertex: u32,
	#[doc = " First vertex."]
	pub stride: u16,
	#[doc = " Vertex stride."]
	pub handle: bgfx_vertex_buffer_handle_t,
	#[doc = " Vertex buffer handle."]
	pub layoutHandle: bgfx_vertex_layout_handle_t,
}
#[doc = " Transient vertex buffer.\n"]
pub type bgfx_transient_vertex_buffer_t = bgfx_transient_vertex_buffer_s;
#[doc = " Instance data buffer info.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_instance_data_buffer_s {
	pub data: *mut u8,
	#[doc = " Pointer to data."]
	pub size: u32,
	#[doc = " Data size."]
	pub offset: u32,
	#[doc = " Offset in vertex buffer."]
	pub num: u32,
	#[doc = " Number of instances."]
	pub stride: u16,
	#[doc = " Vertex buffer stride."]
	pub handle: bgfx_vertex_buffer_handle_t,
}
#[doc = " Instance data buffer info.\n"]
pub type bgfx_instance_data_buffer_t = bgfx_instance_data_buffer_s;
#[doc = " Texture info.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_texture_info_s {
	pub format: bgfx_texture_format_t,
	#[doc = " Texture format."]
	pub storageSize: u32,
	#[doc = " Total amount of bytes required to store texture."]
	pub width: u16,
	#[doc = " Texture width."]
	pub height: u16,
	#[doc = " Texture height."]
	pub depth: u16,
	#[doc = " Texture depth."]
	pub numLayers: u16,
	#[doc = " Number of layers in texture array."]
	pub numMips: u8,
	#[doc = " Number of MIP maps."]
	pub bitsPerPixel: u8,
	#[doc = " Format bits per pixel."]
	pub cubeMap: bool,
}
#[doc = " Texture info.\n"]
pub type bgfx_texture_info_t = bgfx_texture_info_s;
#[doc = " Uniform info.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_uniform_info_s {
	pub name: [::std::os::raw::c_char; 256usize],
	#[doc = " Uniform name."]
	pub type_: bgfx_uniform_type_t,
	#[doc = " Uniform type."]
	pub num: u16,
}
#[doc = " Uniform info.\n"]
pub type bgfx_uniform_info_t = bgfx_uniform_info_s;
#[doc = " Frame buffer texture attachment info.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_attachment_s {
	pub access: bgfx_access_t,
	#[doc = " Attachment access. See `Access::Enum`."]
	pub handle: bgfx_texture_handle_t,
	#[doc = " Render target texture handle."]
	pub mip: u16,
	#[doc = " Mip level."]
	pub layer: u16,
	#[doc = " Cubemap side or depth layer/slice to use."]
	pub numLayers: u16,
	#[doc = " Number of texture layer/slice(s) in array to use."]
	pub resolve: u8,
}
#[doc = " Frame buffer texture attachment info.\n"]
pub type bgfx_attachment_t = bgfx_attachment_s;
#[doc = " Transform data.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_transform_s {
	pub data: *mut f32,
	#[doc = " Pointer to first 4x4 matrix."]
	pub num: u16,
}
#[doc = " Transform data.\n"]
pub type bgfx_transform_t = bgfx_transform_s;
#[doc = " View stats.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_view_stats_s {
	pub name: [::std::os::raw::c_char; 256usize],
	#[doc = " View name."]
	pub view: bgfx_view_id_t,
	#[doc = " View id."]
	pub cpuTimeBegin: i64,
	#[doc = " CPU (submit) begin time."]
	pub cpuTimeEnd: i64,
	#[doc = " CPU (submit) end time."]
	pub gpuTimeBegin: i64,
	#[doc = " GPU begin time."]
	pub gpuTimeEnd: i64,
	#[doc = " GPU end time."]
	pub gpuFrameNum: u32,
}
#[doc = " View stats.\n"]
pub type bgfx_view_stats_t = bgfx_view_stats_s;
#[doc = " Encoder stats.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_encoder_stats_s {
	pub cpuTimeBegin: i64,
	#[doc = " Encoder thread CPU submit begin time."]
	pub cpuTimeEnd: i64,
}
#[doc = " Encoder stats.\n"]
pub type bgfx_encoder_stats_t = bgfx_encoder_stats_s;
#[doc = " Renderer statistics data.\n @remarks All time values are high-resolution timestamps, while\n time frequencies define timestamps-per-second for that hardware.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_stats_s {
	pub cpuTimeFrame: i64,
	#[doc = " CPU time between two `bgfx::frame` calls."]
	pub cpuTimeBegin: i64,
	#[doc = " Render thread CPU submit begin time."]
	pub cpuTimeEnd: i64,
	#[doc = " Render thread CPU submit end time."]
	pub cpuTimerFreq: i64,
	#[doc = " CPU timer frequency. Timestamps-per-second"]
	pub gpuTimeBegin: i64,
	#[doc = " GPU frame begin time."]
	pub gpuTimeEnd: i64,
	#[doc = " GPU frame end time."]
	pub gpuTimerFreq: i64,
	#[doc = " GPU timer frequency."]
	pub waitRender: i64,
	#[doc = " Time spent waiting for render backend thread to finish issuing draw commands to underlying graphics API."]
	pub waitSubmit: i64,
	#[doc = " Time spent waiting for submit thread to advance to next frame."]
	pub numDraw: u32,
	#[doc = " Number of draw calls submitted."]
	pub numCompute: u32,
	#[doc = " Number of compute calls submitted."]
	pub numBlit: u32,
	#[doc = " Number of blit calls submitted."]
	pub maxGpuLatency: u32,
	#[doc = " GPU driver latency."]
	pub gpuFrameNum: u32,
	#[doc = " Frame which generated gpuTimeBegin, gpuTimeEnd."]
	pub numDynamicIndexBuffers: u16,
	#[doc = " Number of used dynamic index buffers."]
	pub numDynamicVertexBuffers: u16,
	#[doc = " Number of used dynamic vertex buffers."]
	pub numFrameBuffers: u16,
	#[doc = " Number of used frame buffers."]
	pub numIndexBuffers: u16,
	#[doc = " Number of used index buffers."]
	pub numOcclusionQueries: u16,
	#[doc = " Number of used occlusion queries."]
	pub numPrograms: u16,
	#[doc = " Number of used programs."]
	pub numShaders: u16,
	#[doc = " Number of used shaders."]
	pub numTextures: u16,
	#[doc = " Number of used textures."]
	pub numUniforms: u16,
	#[doc = " Number of used uniforms."]
	pub numVertexBuffers: u16,
	#[doc = " Number of used vertex buffers."]
	pub numVertexLayouts: u16,
	#[doc = " Number of used vertex layouts."]
	pub textureMemoryUsed: i64,
	#[doc = " Estimate of texture memory used."]
	pub rtMemoryUsed: i64,
	#[doc = " Estimate of render target memory used."]
	pub transientVbUsed: i32,
	#[doc = " Amount of transient vertex buffer used."]
	pub transientIbUsed: i32,
	#[doc = " Amount of transient index buffer used."]
	pub numPrims: [u32; 5usize],
	#[doc = " Number of primitives rendered."]
	pub gpuMemoryMax: i64,
	#[doc = " Maximum available GPU memory for application."]
	pub gpuMemoryUsed: i64,
	#[doc = " Amount of GPU memory used by the application."]
	pub width: u16,
	#[doc = " Backbuffer width in pixels."]
	pub height: u16,
	#[doc = " Backbuffer height in pixels."]
	pub textWidth: u16,
	#[doc = " Debug text width in characters."]
	pub textHeight: u16,
	#[doc = " Debug text height in characters."]
	pub numViews: u16,
	#[doc = " Number of view stats."]
	pub viewStats: *mut bgfx_view_stats_t,
	#[doc = " Array of View stats."]
	pub numEncoders: u8,
	#[doc = " Number of encoders used during frame."]
	pub encoderStats: *mut bgfx_encoder_stats_t,
}
#[doc = " Renderer statistics data.\n @remarks All time values are high-resolution timestamps, while\n time frequencies define timestamps-per-second for that hardware.\n"]
pub type bgfx_stats_t = bgfx_stats_s;
#[doc = " Vertex layout.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_vertex_layout_s {
	pub hash: u32,
	#[doc = " Hash."]
	pub stride: u16,
	#[doc = " Stride."]
	pub offset: [u16; 18usize],
	#[doc = " Attribute offsets."]
	pub attributes: [u16; 18usize],
}
#[doc = " Vertex layout.\n"]
pub type bgfx_vertex_layout_t = bgfx_vertex_layout_s;
#[doc = " Encoders are used for submitting draw calls from multiple threads. Only one encoder\n per thread should be used. Use `bgfx::begin()` to obtain an encoder for a thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bgfx_encoder_s {
	_unused: [u8; 0],
}
pub type bgfx_encoder_t = bgfx_encoder_s;
extern "C" {
	#[doc = " Init attachment.\n\n @param[in] _handle Render target texture handle.\n @param[in] _access Access. See `Access::Enum`.\n @param[in] _layer Cubemap side or depth layer/slice to use.\n @param[in] _numLayers Number of texture layer/slice(s) in array to use.\n @param[in] _mip Mip level.\n @param[in] _resolve Resolve flags. See: `BGFX_RESOLVE_*`\n"]
	pub fn bgfx_attachment_init(
		_this: *mut bgfx_attachment_t,
		_handle: bgfx_texture_handle_t,
		_access: bgfx_access_t,
		_layer: u16,
		_numLayers: u16,
		_mip: u16,
		_resolve: u8,
	);
}
extern "C" {
	#[doc = " Start VertexLayout.\n\n @param[in] _rendererType Renderer backend type. See: `bgfx::RendererType`\n\n @returns Returns itself.\n"]
	pub fn bgfx_vertex_layout_begin(
		_this: *mut bgfx_vertex_layout_t,
		_rendererType: bgfx_renderer_type_t,
	) -> *mut bgfx_vertex_layout_t;
}
extern "C" {
	#[doc = " Add attribute to VertexLayout.\n @remarks Must be called between begin/end.\n\n @param[in] _attrib Attribute semantics. See: `bgfx::Attrib`\n @param[in] _num Number of elements 1, 2, 3 or 4.\n @param[in] _type Element type.\n @param[in] _normalized When using fixed point AttribType (f.e. Uint8)\n  value will be normalized for vertex shader usage. When normalized\n  is set to true, AttribType::Uint8 value in range 0-255 will be\n  in range 0.0-1.0 in vertex shader.\n @param[in] _asInt Packaging rule for vertexPack, vertexUnpack, and\n  vertexConvert for AttribType::Uint8 and AttribType::Int16.\n  Unpacking code must be implemented inside vertex shader.\n\n @returns Returns itself.\n"]
	pub fn bgfx_vertex_layout_add(
		_this: *mut bgfx_vertex_layout_t,
		_attrib: bgfx_attrib_t,
		_num: u8,
		_type: bgfx_attrib_type_t,
		_normalized: bool,
		_asInt: bool,
	) -> *mut bgfx_vertex_layout_t;
}
extern "C" {
	#[doc = " Decode attribute.\n\n @param[in] _attrib Attribute semantics. See: `bgfx::Attrib`\n @param[out] _num Number of elements.\n @param[out] _type Element type.\n @param[out] _normalized Attribute is normalized.\n @param[out] _asInt Attribute is packed as int.\n"]
	pub fn bgfx_vertex_layout_decode(
		_this: *const bgfx_vertex_layout_t,
		_attrib: bgfx_attrib_t,
		_num: *mut u8,
		_type: *mut bgfx_attrib_type_t,
		_normalized: *mut bool,
		_asInt: *mut bool,
	);
}
extern "C" {
	#[doc = " Returns `true` if VertexLayout contains attribute.\n\n @param[in] _attrib Attribute semantics. See: `bgfx::Attrib`\n\n @returns True if VertexLayout contains attribute.\n"]
	pub fn bgfx_vertex_layout_has(
		_this: *const bgfx_vertex_layout_t,
		_attrib: bgfx_attrib_t,
	) -> bool;
}
extern "C" {
	#[doc = " Skip `_num` bytes in vertex stream.\n\n @param[in] _num Number of bytes to skip.\n\n @returns Returns itself.\n"]
	pub fn bgfx_vertex_layout_skip(
		_this: *mut bgfx_vertex_layout_t,
		_num: u8,
	) -> *mut bgfx_vertex_layout_t;
}
extern "C" {
	#[doc = " End VertexLayout.\n"]
	pub fn bgfx_vertex_layout_end(_this: *mut bgfx_vertex_layout_t);
}
extern "C" {
	#[doc = " Returns relative attribute offset from the vertex.\n\n @param[in] _attrib Attribute semantics. See: `bgfx::Attrib`\n\n @returns Relative attribute offset from the vertex.\n"]
	pub fn bgfx_vertex_layout_get_offset(
		_this: *const bgfx_vertex_layout_t,
		_attrib: bgfx_attrib_t,
	) -> u16;
}
extern "C" {
	#[doc = " Returns vertex stride.\n"]
	pub fn bgfx_vertex_layout_get_stride(_this: *const bgfx_vertex_layout_t) -> u16;
}
extern "C" {
	#[doc = " Returns size of vertex buffer for number of vertices.\n\n @param[in] _num Number of vertices.\n\n @returns Size of vertex buffer for number of vertices.\n"]
	pub fn bgfx_vertex_layout_get_size(_this: *const bgfx_vertex_layout_t, _num: u32) -> u32;
}
extern "C" {
	#[doc = " Pack vertex attribute into vertex stream format.\n\n @param[in] _input Value to be packed into vertex stream.\n @param[in] _inputNormalized `true` if input value is already normalized.\n @param[in] _attr Attribute to pack.\n @param[in] _layout Vertex stream layout.\n @param[in] _data Destination vertex stream where data will be packed.\n @param[in] _index Vertex index that will be modified.\n"]
	pub fn bgfx_vertex_pack(
		_input: *const f32,
		_inputNormalized: bool,
		_attr: bgfx_attrib_t,
		_layout: *const bgfx_vertex_layout_t,
		_data: *mut ::std::os::raw::c_void,
		_index: u32,
	);
}
extern "C" {
	#[doc = " Unpack vertex attribute from vertex stream format.\n\n @param[out] _output Result of unpacking.\n @param[in] _attr Attribute to unpack.\n @param[in] _layout Vertex stream layout.\n @param[in] _data Source vertex stream from where data will be unpacked.\n @param[in] _index Vertex index that will be unpacked.\n"]
	pub fn bgfx_vertex_unpack(
		_output: *mut f32,
		_attr: bgfx_attrib_t,
		_layout: *const bgfx_vertex_layout_t,
		_data: *const ::std::os::raw::c_void,
		_index: u32,
	);
}
extern "C" {
	#[doc = " Converts vertex stream data from one vertex stream format to another.\n\n @param[in] _dstLayout Destination vertex stream layout.\n @param[in] _dstData Destination vertex stream.\n @param[in] _srcLayout Source vertex stream layout.\n @param[in] _srcData Source vertex stream data.\n @param[in] _num Number of vertices to convert from source to destination.\n"]
	pub fn bgfx_vertex_convert(
		_dstLayout: *const bgfx_vertex_layout_t,
		_dstData: *mut ::std::os::raw::c_void,
		_srcLayout: *const bgfx_vertex_layout_t,
		_srcData: *const ::std::os::raw::c_void,
		_num: u32,
	);
}
extern "C" {
	#[doc = " Weld vertices.\n\n @param[in] _output Welded vertices remapping table. The size of buffer\n  must be the same as number of vertices.\n @param[in] _layout Vertex stream layout.\n @param[in] _data Vertex stream.\n @param[in] _num Number of vertices in vertex stream.\n @param[in] _index32 Set to `true` if input indices are 32-bit.\n @param[in] _epsilon Error tolerance for vertex position comparison.\n\n @returns Number of unique vertices after vertex welding.\n"]
	pub fn bgfx_weld_vertices(
		_output: *mut ::std::os::raw::c_void,
		_layout: *const bgfx_vertex_layout_t,
		_data: *const ::std::os::raw::c_void,
		_num: u32,
		_index32: bool,
		_epsilon: f32,
	) -> u32;
}
extern "C" {
	#[doc = " Convert index buffer for use with different primitive topologies.\n\n @param[in] _conversion Conversion type, see `TopologyConvert::Enum`.\n @param[out] _dst Destination index buffer. If this argument is NULL\n  function will return number of indices after conversion.\n @param[in] _dstSize Destination index buffer in bytes. It must be\n  large enough to contain output indices. If destination size is\n  insufficient index buffer will be truncated.\n @param[in] _indices Source indices.\n @param[in] _numIndices Number of input indices.\n @param[in] _index32 Set to `true` if input indices are 32-bit.\n\n @returns Number of output indices after conversion.\n"]
	pub fn bgfx_topology_convert(
		_conversion: bgfx_topology_convert_t,
		_dst: *mut ::std::os::raw::c_void,
		_dstSize: u32,
		_indices: *const ::std::os::raw::c_void,
		_numIndices: u32,
		_index32: bool,
	) -> u32;
}
extern "C" {
	#[doc = " Sort indices.\n\n @param[in] _sort Sort order, see `TopologySort::Enum`.\n @param[out] _dst Destination index buffer.\n @param[in] _dstSize Destination index buffer in bytes. It must be\n  large enough to contain output indices. If destination size is\n  insufficient index buffer will be truncated.\n @param[in] _dir Direction (vector must be normalized).\n @param[in] _pos Position.\n @param[in] _vertices Pointer to first vertex represented as\n  float x, y, z. Must contain at least number of vertices\n  referencende by index buffer.\n @param[in] _stride Vertex stride.\n @param[in] _indices Source indices.\n @param[in] _numIndices Number of input indices.\n @param[in] _index32 Set to `true` if input indices are 32-bit.\n"]
	pub fn bgfx_topology_sort_tri_list(
		_sort: bgfx_topology_sort_t,
		_dst: *mut ::std::os::raw::c_void,
		_dstSize: u32,
		_dir: *const f32,
		_pos: *const f32,
		_vertices: *const ::std::os::raw::c_void,
		_stride: u32,
		_indices: *const ::std::os::raw::c_void,
		_numIndices: u32,
		_index32: bool,
	);
}
extern "C" {
	#[doc = " Returns supported backend API renderers.\n\n @param[in] _max Maximum number of elements in _enum array.\n @param[inout] _enum Array where supported renderers will be written.\n\n @returns Number of supported renderers.\n"]
	pub fn bgfx_get_supported_renderers(_max: u8, _enum: *mut bgfx_renderer_type_t) -> u8;
}
extern "C" {
	#[doc = " Returns name of renderer.\n\n @param[in] _type Renderer backend type. See: `bgfx::RendererType`\n\n @returns Name of renderer.\n"]
	pub fn bgfx_get_renderer_name(_type: bgfx_renderer_type_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
	#[doc = " Fill bgfx::Init struct with default values, before using it to initialize the library.\n\n @param[in] _init Pointer to structure to be initialized. See: `bgfx::Init` for more info.\n"]
	pub fn bgfx_init_ctor(_init: *mut bgfx_init_t);
}
extern "C" {
	#[doc = " Initialize the bgfx library.\n\n @param[in] _init Initialization parameters. See: `bgfx::Init` for more info.\n\n @returns `true` if initialization was successful.\n"]
	pub fn bgfx_init(_init: *const bgfx_init_t) -> bool;
}
extern "C" {
	#[doc = " Shutdown bgfx library.\n"]
	pub fn bgfx_shutdown();
}
extern "C" {
	#[doc = " Reset graphic settings and back-buffer size.\n @attention This call doesn’t change the window size, it just resizes\n   the back-buffer. Your windowing code controls the window size.\n\n @param[in] _width Back-buffer width.\n @param[in] _height Back-buffer height.\n @param[in] _flags See: `BGFX_RESET_*` for more info.\n	- `BGFX_RESET_NONE` - No reset flags.\n	- `BGFX_RESET_FULLSCREEN` - Not supported yet.\n	- `BGFX_RESET_MSAA_X[2/4/8/16]` - Enable 2, 4, 8 or 16 x MSAA.\n	- `BGFX_RESET_VSYNC` - Enable V-Sync.\n	- `BGFX_RESET_MAXANISOTROPY` - Turn on/off max anisotropy.\n	- `BGFX_RESET_CAPTURE` - Begin screen capture.\n	- `BGFX_RESET_FLUSH_AFTER_RENDER` - Flush rendering after submitting to GPU.\n	- `BGFX_RESET_FLIP_AFTER_RENDER` - This flag  specifies where flip\n	  occurs. Default behaviour is that flip occurs before rendering new\n	  frame. This flag only has effect when `BGFX_CONFIG_MULTITHREADED=0`.\n	- `BGFX_RESET_SRGB_BACKBUFFER` - Enable sRGB back-buffer.\n @param[in] _format Texture format. See: `TextureFormat::Enum`.\n"]
	pub fn bgfx_reset(_width: u32, _height: u32, _flags: u32, _format: bgfx_texture_format_t);
}
extern "C" {
	#[doc = " Advance to next frame. When using multithreaded renderer, this call\n just swaps internal buffers, kicks render thread, and returns. In\n singlethreaded renderer this call does frame rendering.\n\n @param[in] _capture Capture frame with graphics debugger.\n\n @returns Current frame number. This might be used in conjunction with\n  double/multi buffering data outside the library and passing it to\n  library via `bgfx::makeRef` calls.\n"]
	pub fn bgfx_frame(_capture: bool) -> u32;
}
extern "C" {
	#[doc = " Returns current renderer backend API type.\n @remarks\n   Library must be initialized.\n"]
	pub fn bgfx_get_renderer_type() -> bgfx_renderer_type_t;
}
extern "C" {
	#[doc = " Returns renderer capabilities.\n @remarks\n   Library must be initialized.\n"]
	pub fn bgfx_get_caps() -> *const bgfx_caps_t;
}
extern "C" {
	#[doc = " Returns performance counters.\n @attention Pointer returned is valid until `bgfx::frame` is called.\n"]
	pub fn bgfx_get_stats() -> *const bgfx_stats_t;
}
extern "C" {
	#[doc = " Allocate buffer to pass to bgfx calls. Data will be freed inside bgfx.\n\n @param[in] _size Size to allocate.\n\n @returns Allocated memory.\n"]
	pub fn bgfx_alloc(_size: u32) -> *const bgfx_memory_t;
}
extern "C" {
	#[doc = " Allocate buffer and copy data into it. Data will be freed inside bgfx.\n\n @param[in] _data Pointer to data to be copied.\n @param[in] _size Size of data to be copied.\n\n @returns Allocated memory.\n"]
	pub fn bgfx_copy(_data: *const ::std::os::raw::c_void, _size: u32) -> *const bgfx_memory_t;
}
extern "C" {
	#[doc = " Make reference to data to pass to bgfx. Unlike `bgfx::alloc`, this call\n doesn't allocate memory for data. It just copies the _data pointer. You\n can pass `ReleaseFn` function pointer to release this memory after it's\n consumed, otherwise you must make sure _data is available for at least 2\n `bgfx::frame` calls. `ReleaseFn` function must be able to be called\n from any thread.\n @attention Data passed must be available for at least 2 `bgfx::frame` calls.\n\n @param[in] _data Pointer to data.\n @param[in] _size Size of data.\n\n @returns Referenced memory.\n"]
	pub fn bgfx_make_ref(_data: *const ::std::os::raw::c_void, _size: u32) -> *const bgfx_memory_t;
}
extern "C" {
	#[doc = " Make reference to data to pass to bgfx. Unlike `bgfx::alloc`, this call\n doesn't allocate memory for data. It just copies the _data pointer. You\n can pass `ReleaseFn` function pointer to release this memory after it's\n consumed, otherwise you must make sure _data is available for at least 2\n `bgfx::frame` calls. `ReleaseFn` function must be able to be called\n from any thread.\n @attention Data passed must be available for at least 2 `bgfx::frame` calls.\n\n @param[in] _data Pointer to data.\n @param[in] _size Size of data.\n @param[in] _releaseFn Callback function to release memory after use.\n @param[in] _userData User data to be passed to callback function.\n\n @returns Referenced memory.\n"]
	pub fn bgfx_make_ref_release(
		_data: *const ::std::os::raw::c_void,
		_size: u32,
		_releaseFn: bgfx_release_fn_t,
		_userData: *mut ::std::os::raw::c_void,
	) -> *const bgfx_memory_t;
}
extern "C" {
	#[doc = " Set debug flags.\n\n @param[in] _debug Available flags:\n	- `BGFX_DEBUG_IFH` - Infinitely fast hardware. When this flag is set\n	  all rendering calls will be skipped. This is useful when profiling\n	  to quickly assess potential bottlenecks between CPU and GPU.\n	- `BGFX_DEBUG_PROFILER` - Enable profiler.\n	- `BGFX_DEBUG_STATS` - Display internal statistics.\n	- `BGFX_DEBUG_TEXT` - Display debug text.\n	- `BGFX_DEBUG_WIREFRAME` - Wireframe rendering. All rendering\n	  primitives will be rendered as lines.\n"]
	pub fn bgfx_set_debug(_debug: u32);
}
extern "C" {
	#[doc = " Clear internal debug text buffer.\n\n @param[in] _attr Background color.\n @param[in] _small Default 8x16 or 8x8 font.\n"]
	pub fn bgfx_dbg_text_clear(_attr: u8, _small: bool);
}
extern "C" {
	#[doc = " Print formatted data to internal debug text character-buffer (VGA-compatible text mode).\n\n @param[in] _x Position x from the left corner of the window.\n @param[in] _y Position y from the top corner of the window.\n @param[in] _attr Color palette. Where top 4-bits represent index of background, and bottom\n  4-bits represent foreground color from standard VGA text palette (ANSI escape codes).\n @param[in] _format `printf` style format.\n @param[in]\n"]
	pub fn bgfx_dbg_text_printf(
		_x: u16,
		_y: u16,
		_attr: u8,
		_format: *const ::std::os::raw::c_char,
		...
	);
}
extern "C" {
	#[doc = " Print formatted data from variable argument list to internal debug text character-buffer (VGA-compatible text mode).\n\n @param[in] _x Position x from the left corner of the window.\n @param[in] _y Position y from the top corner of the window.\n @param[in] _attr Color palette. Where top 4-bits represent index of background, and bottom\n  4-bits represent foreground color from standard VGA text palette (ANSI escape codes).\n @param[in] _format `printf` style format.\n @param[in] _argList Variable arguments list for format string.\n"]
	pub fn bgfx_dbg_text_vprintf(
		_x: u16,
		_y: u16,
		_attr: u8,
		_format: *const ::std::os::raw::c_char,
		_argList: va_list,
	);
}
extern "C" {
	#[doc = " Draw image into internal debug text buffer.\n\n @param[in] _x Position x from the left corner of the window.\n @param[in] _y Position y from the top corner of the window.\n @param[in] _width Image width.\n @param[in] _height Image height.\n @param[in] _data Raw image data (character/attribute raw encoding).\n @param[in] _pitch Image pitch in bytes.\n"]
	pub fn bgfx_dbg_text_image(
		_x: u16,
		_y: u16,
		_width: u16,
		_height: u16,
		_data: *const ::std::os::raw::c_void,
		_pitch: u16,
	);
}
extern "C" {
	#[doc = " Create static index buffer.\n\n @param[in] _mem Index buffer data.\n @param[in] _flags Buffer creation flags.\n	- `BGFX_BUFFER_NONE` - No flags.\n	- `BGFX_BUFFER_COMPUTE_READ` - Buffer will be read from by compute shader.\n	- `BGFX_BUFFER_COMPUTE_WRITE` - Buffer will be written into by compute shader. When buffer\n		is created with `BGFX_BUFFER_COMPUTE_WRITE` flag it cannot be updated from CPU.\n	- `BGFX_BUFFER_COMPUTE_READ_WRITE` - Buffer will be used for read/write by compute shader.\n	- `BGFX_BUFFER_ALLOW_RESIZE` - Buffer will resize on buffer update if a different amount of\n		data is passed. If this flag is not specified, and more data is passed on update, the buffer\n		will be trimmed to fit the existing buffer size. This flag has effect only on dynamic\n		buffers.\n	- `BGFX_BUFFER_INDEX32` - Buffer is using 32-bit indices. This flag has effect only on\n		index buffers.\n"]
	pub fn bgfx_create_index_buffer(
		_mem: *const bgfx_memory_t,
		_flags: u16,
	) -> bgfx_index_buffer_handle_t;
}
extern "C" {
	#[doc = " Set static index buffer debug name.\n\n @param[in] _handle Static index buffer handle.\n @param[in] _name Static index buffer name.\n @param[in] _len Static index buffer name length (if length is INT32_MAX, it's expected\n  that _name is zero terminated string.\n"]
	pub fn bgfx_set_index_buffer_name(
		_handle: bgfx_index_buffer_handle_t,
		_name: *const ::std::os::raw::c_char,
		_len: i32,
	);
}
extern "C" {
	#[doc = " Destroy static index buffer.\n\n @param[in] _handle Static index buffer handle.\n"]
	pub fn bgfx_destroy_index_buffer(_handle: bgfx_index_buffer_handle_t);
}
extern "C" {
	#[doc = " Create vertex layout.\n\n @param[in] _layout Vertex layout.\n"]
	pub fn bgfx_create_vertex_layout(
		_layout: *const bgfx_vertex_layout_t,
	) -> bgfx_vertex_layout_handle_t;
}
extern "C" {
	#[doc = " Destroy vertex layout.\n\n @param[in] _layoutHandle Vertex layout handle.\n"]
	pub fn bgfx_destroy_vertex_layout(_layoutHandle: bgfx_vertex_layout_handle_t);
}
extern "C" {
	#[doc = " Create static vertex buffer.\n\n @param[in] _mem Vertex buffer data.\n @param[in] _layout Vertex layout.\n @param[in] _flags Buffer creation flags.\n   - `BGFX_BUFFER_NONE` - No flags.\n   - `BGFX_BUFFER_COMPUTE_READ` - Buffer will be read from by compute shader.\n   - `BGFX_BUFFER_COMPUTE_WRITE` - Buffer will be written into by compute shader. When buffer\n	   is created with `BGFX_BUFFER_COMPUTE_WRITE` flag it cannot be updated from CPU.\n   - `BGFX_BUFFER_COMPUTE_READ_WRITE` - Buffer will be used for read/write by compute shader.\n   - `BGFX_BUFFER_ALLOW_RESIZE` - Buffer will resize on buffer update if a different amount of\n	   data is passed. If this flag is not specified, and more data is passed on update, the buffer\n	   will be trimmed to fit the existing buffer size. This flag has effect only on dynamic buffers.\n   - `BGFX_BUFFER_INDEX32` - Buffer is using 32-bit indices. This flag has effect only on index buffers.\n\n @returns Static vertex buffer handle.\n"]
	pub fn bgfx_create_vertex_buffer(
		_mem: *const bgfx_memory_t,
		_layout: *const bgfx_vertex_layout_t,
		_flags: u16,
	) -> bgfx_vertex_buffer_handle_t;
}
extern "C" {
	#[doc = " Set static vertex buffer debug name.\n\n @param[in] _handle Static vertex buffer handle.\n @param[in] _name Static vertex buffer name.\n @param[in] _len Static vertex buffer name length (if length is INT32_MAX, it's expected\n  that _name is zero terminated string.\n"]
	pub fn bgfx_set_vertex_buffer_name(
		_handle: bgfx_vertex_buffer_handle_t,
		_name: *const ::std::os::raw::c_char,
		_len: i32,
	);
}
extern "C" {
	#[doc = " Destroy static vertex buffer.\n\n @param[in] _handle Static vertex buffer handle.\n"]
	pub fn bgfx_destroy_vertex_buffer(_handle: bgfx_vertex_buffer_handle_t);
}
extern "C" {
	#[doc = " Create empty dynamic index buffer.\n\n @param[in] _num Number of indices.\n @param[in] _flags Buffer creation flags.\n	- `BGFX_BUFFER_NONE` - No flags.\n	- `BGFX_BUFFER_COMPUTE_READ` - Buffer will be read from by compute shader.\n	- `BGFX_BUFFER_COMPUTE_WRITE` - Buffer will be written into by compute shader. When buffer\n		is created with `BGFX_BUFFER_COMPUTE_WRITE` flag it cannot be updated from CPU.\n	- `BGFX_BUFFER_COMPUTE_READ_WRITE` - Buffer will be used for read/write by compute shader.\n	- `BGFX_BUFFER_ALLOW_RESIZE` - Buffer will resize on buffer update if a different amount of\n		data is passed. If this flag is not specified, and more data is passed on update, the buffer\n		will be trimmed to fit the existing buffer size. This flag has effect only on dynamic\n		buffers.\n	- `BGFX_BUFFER_INDEX32` - Buffer is using 32-bit indices. This flag has effect only on\n		index buffers.\n\n @returns Dynamic index buffer handle.\n"]
	pub fn bgfx_create_dynamic_index_buffer(
		_num: u32,
		_flags: u16,
	) -> bgfx_dynamic_index_buffer_handle_t;
}
extern "C" {
	#[doc = " Create a dynamic index buffer and initialize it.\n\n @param[in] _mem Index buffer data.\n @param[in] _flags Buffer creation flags.\n	- `BGFX_BUFFER_NONE` - No flags.\n	- `BGFX_BUFFER_COMPUTE_READ` - Buffer will be read from by compute shader.\n	- `BGFX_BUFFER_COMPUTE_WRITE` - Buffer will be written into by compute shader. When buffer\n		is created with `BGFX_BUFFER_COMPUTE_WRITE` flag it cannot be updated from CPU.\n	- `BGFX_BUFFER_COMPUTE_READ_WRITE` - Buffer will be used for read/write by compute shader.\n	- `BGFX_BUFFER_ALLOW_RESIZE` - Buffer will resize on buffer update if a different amount of\n		data is passed. If this flag is not specified, and more data is passed on update, the buffer\n		will be trimmed to fit the existing buffer size. This flag has effect only on dynamic\n		buffers.\n	- `BGFX_BUFFER_INDEX32` - Buffer is using 32-bit indices. This flag has effect only on\n		index buffers.\n\n @returns Dynamic index buffer handle.\n"]
	pub fn bgfx_create_dynamic_index_buffer_mem(
		_mem: *const bgfx_memory_t,
		_flags: u16,
	) -> bgfx_dynamic_index_buffer_handle_t;
}
extern "C" {
	#[doc = " Update dynamic index buffer.\n\n @param[in] _handle Dynamic index buffer handle.\n @param[in] _startIndex Start index.\n @param[in] _mem Index buffer data.\n"]
	pub fn bgfx_update_dynamic_index_buffer(
		_handle: bgfx_dynamic_index_buffer_handle_t,
		_startIndex: u32,
		_mem: *const bgfx_memory_t,
	);
}
extern "C" {
	#[doc = " Destroy dynamic index buffer.\n\n @param[in] _handle Dynamic index buffer handle.\n"]
	pub fn bgfx_destroy_dynamic_index_buffer(_handle: bgfx_dynamic_index_buffer_handle_t);
}
extern "C" {
	#[doc = " Create empty dynamic vertex buffer.\n\n @param[in] _num Number of vertices.\n @param[in] _layout Vertex layout.\n @param[in] _flags Buffer creation flags.\n	- `BGFX_BUFFER_NONE` - No flags.\n	- `BGFX_BUFFER_COMPUTE_READ` - Buffer will be read from by compute shader.\n	- `BGFX_BUFFER_COMPUTE_WRITE` - Buffer will be written into by compute shader. When buffer\n		is created with `BGFX_BUFFER_COMPUTE_WRITE` flag it cannot be updated from CPU.\n	- `BGFX_BUFFER_COMPUTE_READ_WRITE` - Buffer will be used for read/write by compute shader.\n	- `BGFX_BUFFER_ALLOW_RESIZE` - Buffer will resize on buffer update if a different amount of\n		data is passed. If this flag is not specified, and more data is passed on update, the buffer\n		will be trimmed to fit the existing buffer size. This flag has effect only on dynamic\n		buffers.\n	- `BGFX_BUFFER_INDEX32` - Buffer is using 32-bit indices. This flag has effect only on\n		index buffers.\n\n @returns Dynamic vertex buffer handle.\n"]
	pub fn bgfx_create_dynamic_vertex_buffer(
		_num: u32,
		_layout: *const bgfx_vertex_layout_t,
		_flags: u16,
	) -> bgfx_dynamic_vertex_buffer_handle_t;
}
extern "C" {
	#[doc = " Create dynamic vertex buffer and initialize it.\n\n @param[in] _mem Vertex buffer data.\n @param[in] _layout Vertex layout.\n @param[in] _flags Buffer creation flags.\n	- `BGFX_BUFFER_NONE` - No flags.\n	- `BGFX_BUFFER_COMPUTE_READ` - Buffer will be read from by compute shader.\n	- `BGFX_BUFFER_COMPUTE_WRITE` - Buffer will be written into by compute shader. When buffer\n		is created with `BGFX_BUFFER_COMPUTE_WRITE` flag it cannot be updated from CPU.\n	- `BGFX_BUFFER_COMPUTE_READ_WRITE` - Buffer will be used for read/write by compute shader.\n	- `BGFX_BUFFER_ALLOW_RESIZE` - Buffer will resize on buffer update if a different amount of\n		data is passed. If this flag is not specified, and more data is passed on update, the buffer\n		will be trimmed to fit the existing buffer size. This flag has effect only on dynamic\n		buffers.\n	- `BGFX_BUFFER_INDEX32` - Buffer is using 32-bit indices. This flag has effect only on\n		index buffers.\n\n @returns Dynamic vertex buffer handle.\n"]
	pub fn bgfx_create_dynamic_vertex_buffer_mem(
		_mem: *const bgfx_memory_t,
		_layout: *const bgfx_vertex_layout_t,
		_flags: u16,
	) -> bgfx_dynamic_vertex_buffer_handle_t;
}
extern "C" {
	#[doc = " Update dynamic vertex buffer.\n\n @param[in] _handle Dynamic vertex buffer handle.\n @param[in] _startVertex Start vertex.\n @param[in] _mem Vertex buffer data.\n"]
	pub fn bgfx_update_dynamic_vertex_buffer(
		_handle: bgfx_dynamic_vertex_buffer_handle_t,
		_startVertex: u32,
		_mem: *const bgfx_memory_t,
	);
}
extern "C" {
	#[doc = " Destroy dynamic vertex buffer.\n\n @param[in] _handle Dynamic vertex buffer handle.\n"]
	pub fn bgfx_destroy_dynamic_vertex_buffer(_handle: bgfx_dynamic_vertex_buffer_handle_t);
}
extern "C" {
	#[doc = " Returns number of requested or maximum available indices.\n\n @param[in] _num Number of required indices.\n @param[in] _index32 Set to `true` if input indices will be 32-bit.\n\n @returns Number of requested or maximum available indices.\n"]
	pub fn bgfx_get_avail_transient_index_buffer(_num: u32, _index32: bool) -> u32;
}
extern "C" {
	#[doc = " Returns number of requested or maximum available vertices.\n\n @param[in] _num Number of required vertices.\n @param[in] _layout Vertex layout.\n\n @returns Number of requested or maximum available vertices.\n"]
	pub fn bgfx_get_avail_transient_vertex_buffer(
		_num: u32,
		_layout: *const bgfx_vertex_layout_t,
	) -> u32;
}
extern "C" {
	#[doc = " Returns number of requested or maximum available instance buffer slots.\n\n @param[in] _num Number of required instances.\n @param[in] _stride Stride per instance.\n\n @returns Number of requested or maximum available instance buffer slots.\n"]
	pub fn bgfx_get_avail_instance_data_buffer(_num: u32, _stride: u16) -> u32;
}
extern "C" {
	#[doc = " Allocate transient index buffer.\n\n @param[out] _tib TransientIndexBuffer structure will be filled, and will be valid\n  for the duration of frame, and can be reused for multiple draw\n  calls.\n @param[in] _num Number of indices to allocate.\n @param[in] _index32 Set to `true` if input indices will be 32-bit.\n"]
	pub fn bgfx_alloc_transient_index_buffer(
		_tib: *mut bgfx_transient_index_buffer_t,
		_num: u32,
		_index32: bool,
	);
}
extern "C" {
	#[doc = " Allocate transient vertex buffer.\n\n @param[out] _tvb TransientVertexBuffer structure will be filled, and will be valid\n  for the duration of frame, and can be reused for multiple draw\n  calls.\n @param[in] _num Number of vertices to allocate.\n @param[in] _layout Vertex layout.\n"]
	pub fn bgfx_alloc_transient_vertex_buffer(
		_tvb: *mut bgfx_transient_vertex_buffer_t,
		_num: u32,
		_layout: *const bgfx_vertex_layout_t,
	);
}
extern "C" {
	#[doc = " Check for required space and allocate transient vertex and index\n buffers. If both space requirements are satisfied function returns\n true.\n\n @param[out] _tvb TransientVertexBuffer structure will be filled, and will be valid\n  for the duration of frame, and can be reused for multiple draw\n  calls.\n @param[in] _layout Vertex layout.\n @param[in] _numVertices Number of vertices to allocate.\n @param[out] _tib TransientIndexBuffer structure will be filled, and will be valid\n  for the duration of frame, and can be reused for multiple draw\n  calls.\n @param[in] _numIndices Number of indices to allocate.\n @param[in] _index32 Set to `true` if input indices will be 32-bit.\n"]
	pub fn bgfx_alloc_transient_buffers(
		_tvb: *mut bgfx_transient_vertex_buffer_t,
		_layout: *const bgfx_vertex_layout_t,
		_numVertices: u32,
		_tib: *mut bgfx_transient_index_buffer_t,
		_numIndices: u32,
		_index32: bool,
	) -> bool;
}
extern "C" {
	#[doc = " Allocate instance data buffer.\n\n @param[out] _idb InstanceDataBuffer structure will be filled, and will be valid\n  for duration of frame, and can be reused for multiple draw\n  calls.\n @param[in] _num Number of instances.\n @param[in] _stride Instance stride. Must be multiple of 16.\n"]
	pub fn bgfx_alloc_instance_data_buffer(
		_idb: *mut bgfx_instance_data_buffer_t,
		_num: u32,
		_stride: u16,
	);
}
extern "C" {
	#[doc = " Create draw indirect buffer.\n\n @param[in] _num Number of indirect calls.\n\n @returns Indirect buffer handle.\n"]
	pub fn bgfx_create_indirect_buffer(_num: u32) -> bgfx_indirect_buffer_handle_t;
}
extern "C" {
	#[doc = " Destroy draw indirect buffer.\n\n @param[in] _handle Indirect buffer handle.\n"]
	pub fn bgfx_destroy_indirect_buffer(_handle: bgfx_indirect_buffer_handle_t);
}
extern "C" {
	#[doc = " Create shader from memory buffer.\n @remarks\n   Shader binary is obtained by compiling shader offline with shaderc command line tool.\n\n @param[in] _mem Shader binary.\n\n @returns Shader handle.\n"]
	pub fn bgfx_create_shader(_mem: *const bgfx_memory_t) -> bgfx_shader_handle_t;
}
extern "C" {
	#[doc = " Returns the number of uniforms and uniform handles used inside a shader.\n @remarks\n   Only non-predefined uniforms are returned.\n\n @param[in] _handle Shader handle.\n @param[out] _uniforms UniformHandle array where data will be stored.\n @param[in] _max Maximum capacity of array.\n\n @returns Number of uniforms used by shader.\n"]
	pub fn bgfx_get_shader_uniforms(
		_handle: bgfx_shader_handle_t,
		_uniforms: *mut bgfx_uniform_handle_t,
		_max: u16,
	) -> u16;
}
extern "C" {
	#[doc = " Set shader debug name.\n\n @param[in] _handle Shader handle.\n @param[in] _name Shader name.\n @param[in] _len Shader name length (if length is INT32_MAX, it's expected\n  that _name is zero terminated string).\n"]
	pub fn bgfx_set_shader_name(
		_handle: bgfx_shader_handle_t,
		_name: *const ::std::os::raw::c_char,
		_len: i32,
	);
}
extern "C" {
	#[doc = " Destroy shader.\n @remark Once a shader program is created with _handle,\n   it is safe to destroy that shader.\n\n @param[in] _handle Shader handle.\n"]
	pub fn bgfx_destroy_shader(_handle: bgfx_shader_handle_t);
}
extern "C" {
	#[doc = " Create program with vertex and fragment shaders.\n\n @param[in] _vsh Vertex shader.\n @param[in] _fsh Fragment shader.\n @param[in] _destroyShaders If true, shaders will be destroyed when program is destroyed.\n\n @returns Program handle if vertex shader output and fragment shader\n  input are matching, otherwise returns invalid program handle.\n"]
	pub fn bgfx_create_program(
		_vsh: bgfx_shader_handle_t,
		_fsh: bgfx_shader_handle_t,
		_destroyShaders: bool,
	) -> bgfx_program_handle_t;
}
extern "C" {
	#[doc = " Create program with compute shader.\n\n @param[in] _csh Compute shader.\n @param[in] _destroyShaders If true, shaders will be destroyed when program is destroyed.\n\n @returns Program handle.\n"]
	pub fn bgfx_create_compute_program(
		_csh: bgfx_shader_handle_t,
		_destroyShaders: bool,
	) -> bgfx_program_handle_t;
}
extern "C" {
	#[doc = " Destroy program.\n\n @param[in] _handle Program handle.\n"]
	pub fn bgfx_destroy_program(_handle: bgfx_program_handle_t);
}
extern "C" {
	#[doc = " Validate texture parameters.\n\n @param[in] _depth Depth dimension of volume texture.\n @param[in] _cubeMap Indicates that texture contains cubemap.\n @param[in] _numLayers Number of layers in texture array.\n @param[in] _format Texture format. See: `TextureFormat::Enum`.\n @param[in] _flags Texture flags. See `BGFX_TEXTURE_*`.\n\n @returns True if a texture with the same parameters can be created.\n"]
	pub fn bgfx_is_texture_valid(
		_depth: u16,
		_cubeMap: bool,
		_numLayers: u16,
		_format: bgfx_texture_format_t,
		_flags: u64,
	) -> bool;
}
extern "C" {
	#[doc = " Validate frame buffer parameters.\n\n @param[in] _num Number of attachments.\n @param[in] _attachment Attachment texture info. See: `bgfx::Attachment`.\n\n @returns True if a frame buffer with the same parameters can be created.\n"]
	pub fn bgfx_is_frame_buffer_valid(_num: u8, _attachment: *const bgfx_attachment_t) -> bool;
}
extern "C" {
	#[doc = " Calculate amount of memory required for texture.\n\n @param[out] _info Resulting texture info structure. See: `TextureInfo`.\n @param[in] _width Width.\n @param[in] _height Height.\n @param[in] _depth Depth dimension of volume texture.\n @param[in] _cubeMap Indicates that texture contains cubemap.\n @param[in] _hasMips Indicates that texture contains full mip-map chain.\n @param[in] _numLayers Number of layers in texture array.\n @param[in] _format Texture format. See: `TextureFormat::Enum`.\n"]
	pub fn bgfx_calc_texture_size(
		_info: *mut bgfx_texture_info_t,
		_width: u16,
		_height: u16,
		_depth: u16,
		_cubeMap: bool,
		_hasMips: bool,
		_numLayers: u16,
		_format: bgfx_texture_format_t,
	);
}
extern "C" {
	#[doc = " Create texture from memory buffer.\n\n @param[in] _mem DDS, KTX or PVR texture binary data.\n @param[in] _flags Texture creation (see `BGFX_TEXTURE_*`.), and sampler (see `BGFX_SAMPLER_*`)\n  flags. Default texture sampling mode is linear, and wrap mode is repeat.\n  - `BGFX_SAMPLER_[U/V/W]_[MIRROR/CLAMP]` - Mirror or clamp to edge wrap\n	mode.\n  - `BGFX_SAMPLER_[MIN/MAG/MIP]_[POINT/ANISOTROPIC]` - Point or anisotropic\n	sampling.\n @param[in] _skip Skip top level mips when parsing texture.\n @param[out] _info When non-`NULL` is specified it returns parsed texture information.\n\n @returns Texture handle.\n"]
	pub fn bgfx_create_texture(
		_mem: *const bgfx_memory_t,
		_flags: u64,
		_skip: u8,
		_info: *mut bgfx_texture_info_t,
	) -> bgfx_texture_handle_t;
}
extern "C" {
	#[doc = " Create 2D texture.\n\n @param[in] _width Width.\n @param[in] _height Height.\n @param[in] _hasMips Indicates that texture contains full mip-map chain.\n @param[in] _numLayers Number of layers in texture array. Must be 1 if caps\n  `BGFX_CAPS_TEXTURE_2D_ARRAY` flag is not set.\n @param[in] _format Texture format. See: `TextureFormat::Enum`.\n @param[in] _flags Texture creation (see `BGFX_TEXTURE_*`.), and sampler (see `BGFX_SAMPLER_*`)\n  flags. Default texture sampling mode is linear, and wrap mode is repeat.\n  - `BGFX_SAMPLER_[U/V/W]_[MIRROR/CLAMP]` - Mirror or clamp to edge wrap\n	mode.\n  - `BGFX_SAMPLER_[MIN/MAG/MIP]_[POINT/ANISOTROPIC]` - Point or anisotropic\n	sampling.\n @param[in] _mem Texture data. If `_mem` is non-NULL, created texture will be immutable. If\n  `_mem` is NULL content of the texture is uninitialized. When `_numLayers` is more than\n  1, expected memory layout is texture and all mips together for each array element.\n\n @returns Texture handle.\n"]
	pub fn bgfx_create_texture_2d(
		_width: u16,
		_height: u16,
		_hasMips: bool,
		_numLayers: u16,
		_format: bgfx_texture_format_t,
		_flags: u64,
		_mem: *const bgfx_memory_t,
	) -> bgfx_texture_handle_t;
}
extern "C" {
	#[doc = " Create texture with size based on back-buffer ratio. Texture will maintain ratio\n if back buffer resolution changes.\n\n @param[in] _ratio Texture size in respect to back-buffer size. See: `BackbufferRatio::Enum`.\n @param[in] _hasMips Indicates that texture contains full mip-map chain.\n @param[in] _numLayers Number of layers in texture array. Must be 1 if caps\n  `BGFX_CAPS_TEXTURE_2D_ARRAY` flag is not set.\n @param[in] _format Texture format. See: `TextureFormat::Enum`.\n @param[in] _flags Texture creation (see `BGFX_TEXTURE_*`.), and sampler (see `BGFX_SAMPLER_*`)\n  flags. Default texture sampling mode is linear, and wrap mode is repeat.\n  - `BGFX_SAMPLER_[U/V/W]_[MIRROR/CLAMP]` - Mirror or clamp to edge wrap\n	mode.\n  - `BGFX_SAMPLER_[MIN/MAG/MIP]_[POINT/ANISOTROPIC]` - Point or anisotropic\n	sampling.\n\n @returns Texture handle.\n"]
	pub fn bgfx_create_texture_2d_scaled(
		_ratio: bgfx_backbuffer_ratio_t,
		_hasMips: bool,
		_numLayers: u16,
		_format: bgfx_texture_format_t,
		_flags: u64,
	) -> bgfx_texture_handle_t;
}
extern "C" {
	#[doc = " Create 3D texture.\n\n @param[in] _width Width.\n @param[in] _height Height.\n @param[in] _depth Depth.\n @param[in] _hasMips Indicates that texture contains full mip-map chain.\n @param[in] _format Texture format. See: `TextureFormat::Enum`.\n @param[in] _flags Texture creation (see `BGFX_TEXTURE_*`.), and sampler (see `BGFX_SAMPLER_*`)\n  flags. Default texture sampling mode is linear, and wrap mode is repeat.\n  - `BGFX_SAMPLER_[U/V/W]_[MIRROR/CLAMP]` - Mirror or clamp to edge wrap\n	mode.\n  - `BGFX_SAMPLER_[MIN/MAG/MIP]_[POINT/ANISOTROPIC]` - Point or anisotropic\n	sampling.\n @param[in] _mem Texture data. If `_mem` is non-NULL, created texture will be immutable. If\n  `_mem` is NULL content of the texture is uninitialized. When `_numLayers` is more than\n  1, expected memory layout is texture and all mips together for each array element.\n\n @returns Texture handle.\n"]
	pub fn bgfx_create_texture_3d(
		_width: u16,
		_height: u16,
		_depth: u16,
		_hasMips: bool,
		_format: bgfx_texture_format_t,
		_flags: u64,
		_mem: *const bgfx_memory_t,
	) -> bgfx_texture_handle_t;
}
extern "C" {
	#[doc = " Create Cube texture.\n\n @param[in] _size Cube side size.\n @param[in] _hasMips Indicates that texture contains full mip-map chain.\n @param[in] _numLayers Number of layers in texture array. Must be 1 if caps\n  `BGFX_CAPS_TEXTURE_2D_ARRAY` flag is not set.\n @param[in] _format Texture format. See: `TextureFormat::Enum`.\n @param[in] _flags Texture creation (see `BGFX_TEXTURE_*`.), and sampler (see `BGFX_SAMPLER_*`)\n  flags. Default texture sampling mode is linear, and wrap mode is repeat.\n  - `BGFX_SAMPLER_[U/V/W]_[MIRROR/CLAMP]` - Mirror or clamp to edge wrap\n	mode.\n  - `BGFX_SAMPLER_[MIN/MAG/MIP]_[POINT/ANISOTROPIC]` - Point or anisotropic\n	sampling.\n @param[in] _mem Texture data. If `_mem` is non-NULL, created texture will be immutable. If\n  `_mem` is NULL content of the texture is uninitialized. When `_numLayers` is more than\n  1, expected memory layout is texture and all mips together for each array element.\n\n @returns Texture handle.\n"]
	pub fn bgfx_create_texture_cube(
		_size: u16,
		_hasMips: bool,
		_numLayers: u16,
		_format: bgfx_texture_format_t,
		_flags: u64,
		_mem: *const bgfx_memory_t,
	) -> bgfx_texture_handle_t;
}
extern "C" {
	#[doc = " Update 2D texture.\n @attention It's valid to update only mutable texture. See `bgfx::createTexture2D` for more info.\n\n @param[in] _handle Texture handle.\n @param[in] _layer Layer in texture array.\n @param[in] _mip Mip level.\n @param[in] _x X offset in texture.\n @param[in] _y Y offset in texture.\n @param[in] _width Width of texture block.\n @param[in] _height Height of texture block.\n @param[in] _mem Texture update data.\n @param[in] _pitch Pitch of input image (bytes). When _pitch is set to\n  UINT16_MAX, it will be calculated internally based on _width.\n"]
	pub fn bgfx_update_texture_2d(
		_handle: bgfx_texture_handle_t,
		_layer: u16,
		_mip: u8,
		_x: u16,
		_y: u16,
		_width: u16,
		_height: u16,
		_mem: *const bgfx_memory_t,
		_pitch: u16,
	);
}
extern "C" {
	#[doc = " Update 3D texture.\n @attention It's valid to update only mutable texture. See `bgfx::createTexture3D` for more info.\n\n @param[in] _handle Texture handle.\n @param[in] _mip Mip level.\n @param[in] _x X offset in texture.\n @param[in] _y Y offset in texture.\n @param[in] _z Z offset in texture.\n @param[in] _width Width of texture block.\n @param[in] _height Height of texture block.\n @param[in] _depth Depth of texture block.\n @param[in] _mem Texture update data.\n"]
	pub fn bgfx_update_texture_3d(
		_handle: bgfx_texture_handle_t,
		_mip: u8,
		_x: u16,
		_y: u16,
		_z: u16,
		_width: u16,
		_height: u16,
		_depth: u16,
		_mem: *const bgfx_memory_t,
	);
}
extern "C" {
	#[doc = " Update Cube texture.\n @attention It's valid to update only mutable texture. See `bgfx::createTextureCube` for more info.\n\n @param[in] _handle Texture handle.\n @param[in] _layer Layer in texture array.\n @param[in] _side Cubemap side `BGFX_CUBE_MAP_<POSITIVE or NEGATIVE>_<X, Y or Z>`,\n	where 0 is +X, 1 is -X, 2 is +Y, 3 is -Y, 4 is +Z, and 5 is -Z.\n				   +----------+\n				   |-z	   2|\n				   | ^  +y	|\n				   | |		|	Unfolded cube:\n				   | +---->+x |\n		+----------+----------+----------+----------+\n		|+y	   1|+y	   4|+y	   0|+y	   5|\n		| ^  -x	| ^  +z	| ^  +x	| ^  -z	|\n		| |		| |		| |		| |		|\n		| +---->+z | +---->+x | +---->-z | +---->-x |\n		+----------+----------+----------+----------+\n				   |+z	   3|\n				   | ^  -y	|\n				   | |		|\n				   | +---->+x |\n				   +----------+\n @param[in] _mip Mip level.\n @param[in] _x X offset in texture.\n @param[in] _y Y offset in texture.\n @param[in] _width Width of texture block.\n @param[in] _height Height of texture block.\n @param[in] _mem Texture update data.\n @param[in] _pitch Pitch of input image (bytes). When _pitch is set to\n  UINT16_MAX, it will be calculated internally based on _width.\n"]
	pub fn bgfx_update_texture_cube(
		_handle: bgfx_texture_handle_t,
		_layer: u16,
		_side: u8,
		_mip: u8,
		_x: u16,
		_y: u16,
		_width: u16,
		_height: u16,
		_mem: *const bgfx_memory_t,
		_pitch: u16,
	);
}
extern "C" {
	#[doc = " Read back texture content.\n @attention Texture must be created with `BGFX_TEXTURE_READ_BACK` flag.\n @attention Availability depends on: `BGFX_CAPS_TEXTURE_READ_BACK`.\n\n @param[in] _handle Texture handle.\n @param[in] _data Destination buffer.\n @param[in] _mip Mip level.\n\n @returns Frame number when the result will be available. See: `bgfx::frame`.\n"]
	pub fn bgfx_read_texture(
		_handle: bgfx_texture_handle_t,
		_data: *mut ::std::os::raw::c_void,
		_mip: u8,
	) -> u32;
}
extern "C" {
	#[doc = " Set texture debug name.\n\n @param[in] _handle Texture handle.\n @param[in] _name Texture name.\n @param[in] _len Texture name length (if length is INT32_MAX, it's expected\n  that _name is zero terminated string.\n"]
	pub fn bgfx_set_texture_name(
		_handle: bgfx_texture_handle_t,
		_name: *const ::std::os::raw::c_char,
		_len: i32,
	);
}
extern "C" {
	#[doc = " Returns texture direct access pointer.\n @attention Availability depends on: `BGFX_CAPS_TEXTURE_DIRECT_ACCESS`. This feature\n   is available on GPUs that have unified memory architecture (UMA) support.\n\n @param[in] _handle Texture handle.\n\n @returns Pointer to texture memory. If returned pointer is `NULL` direct access\n  is not available for this texture. If pointer is `UINTPTR_MAX` sentinel value\n  it means texture is pending creation. Pointer returned can be cached and it\n  will be valid until texture is destroyed.\n"]
	pub fn bgfx_get_direct_access_ptr(
		_handle: bgfx_texture_handle_t,
	) -> *mut ::std::os::raw::c_void;
}
extern "C" {
	#[doc = " Destroy texture.\n\n @param[in] _handle Texture handle.\n"]
	pub fn bgfx_destroy_texture(_handle: bgfx_texture_handle_t);
}
extern "C" {
	#[doc = " Create frame buffer (simple).\n\n @param[in] _width Texture width.\n @param[in] _height Texture height.\n @param[in] _format Texture format. See: `TextureFormat::Enum`.\n @param[in] _textureFlags Texture creation (see `BGFX_TEXTURE_*`.), and sampler (see `BGFX_SAMPLER_*`)\n  flags. Default texture sampling mode is linear, and wrap mode is repeat.\n  - `BGFX_SAMPLER_[U/V/W]_[MIRROR/CLAMP]` - Mirror or clamp to edge wrap\n	mode.\n  - `BGFX_SAMPLER_[MIN/MAG/MIP]_[POINT/ANISOTROPIC]` - Point or anisotropic\n	sampling.\n\n @returns Frame buffer handle.\n"]
	pub fn bgfx_create_frame_buffer(
		_width: u16,
		_height: u16,
		_format: bgfx_texture_format_t,
		_textureFlags: u64,
	) -> bgfx_frame_buffer_handle_t;
}
extern "C" {
	#[doc = " Create frame buffer with size based on back-buffer ratio. Frame buffer will maintain ratio\n if back buffer resolution changes.\n\n @param[in] _ratio Frame buffer size in respect to back-buffer size. See:\n  `BackbufferRatio::Enum`.\n @param[in] _format Texture format. See: `TextureFormat::Enum`.\n @param[in] _textureFlags Texture creation (see `BGFX_TEXTURE_*`.), and sampler (see `BGFX_SAMPLER_*`)\n  flags. Default texture sampling mode is linear, and wrap mode is repeat.\n  - `BGFX_SAMPLER_[U/V/W]_[MIRROR/CLAMP]` - Mirror or clamp to edge wrap\n	mode.\n  - `BGFX_SAMPLER_[MIN/MAG/MIP]_[POINT/ANISOTROPIC]` - Point or anisotropic\n	sampling.\n\n @returns Frame buffer handle.\n"]
	pub fn bgfx_create_frame_buffer_scaled(
		_ratio: bgfx_backbuffer_ratio_t,
		_format: bgfx_texture_format_t,
		_textureFlags: u64,
	) -> bgfx_frame_buffer_handle_t;
}
extern "C" {
	#[doc = " Create MRT frame buffer from texture handles (simple).\n\n @param[in] _num Number of texture handles.\n @param[in] _handles Texture attachments.\n @param[in] _destroyTexture If true, textures will be destroyed when\n  frame buffer is destroyed.\n\n @returns Frame buffer handle.\n"]
	pub fn bgfx_create_frame_buffer_from_handles(
		_num: u8,
		_handles: *const bgfx_texture_handle_t,
		_destroyTexture: bool,
	) -> bgfx_frame_buffer_handle_t;
}
extern "C" {
	#[doc = " Create MRT frame buffer from texture handles with specific layer and\n mip level.\n\n @param[in] _num Number of attachments.\n @param[in] _attachment Attachment texture info. See: `bgfx::Attachment`.\n @param[in] _destroyTexture If true, textures will be destroyed when\n  frame buffer is destroyed.\n\n @returns Frame buffer handle.\n"]
	pub fn bgfx_create_frame_buffer_from_attachment(
		_num: u8,
		_attachment: *const bgfx_attachment_t,
		_destroyTexture: bool,
	) -> bgfx_frame_buffer_handle_t;
}
extern "C" {
	#[doc = " Create frame buffer for multiple window rendering.\n @remarks\n   Frame buffer cannot be used for sampling.\n @attention Availability depends on: `BGFX_CAPS_SWAP_CHAIN`.\n\n @param[in] _nwh OS' target native window handle.\n @param[in] _width Window back buffer width.\n @param[in] _height Window back buffer height.\n @param[in] _format Window back buffer color format.\n @param[in] _depthFormat Window back buffer depth format.\n\n @returns Frame buffer handle.\n"]
	pub fn bgfx_create_frame_buffer_from_nwh(
		_nwh: *mut ::std::os::raw::c_void,
		_width: u16,
		_height: u16,
		_format: bgfx_texture_format_t,
		_depthFormat: bgfx_texture_format_t,
	) -> bgfx_frame_buffer_handle_t;
}
extern "C" {
	#[doc = " Set frame buffer debug name.\n\n @param[in] _handle Frame buffer handle.\n @param[in] _name Frame buffer name.\n @param[in] _len Frame buffer name length (if length is INT32_MAX, it's expected\n  that _name is zero terminated string.\n"]
	pub fn bgfx_set_frame_buffer_name(
		_handle: bgfx_frame_buffer_handle_t,
		_name: *const ::std::os::raw::c_char,
		_len: i32,
	);
}
extern "C" {
	#[doc = " Obtain texture handle of frame buffer attachment.\n\n @param[in] _handle Frame buffer handle.\n @param[in] _attachment\n"]
	pub fn bgfx_get_texture(
		_handle: bgfx_frame_buffer_handle_t,
		_attachment: u8,
	) -> bgfx_texture_handle_t;
}
extern "C" {
	#[doc = " Destroy frame buffer.\n\n @param[in] _handle Frame buffer handle.\n"]
	pub fn bgfx_destroy_frame_buffer(_handle: bgfx_frame_buffer_handle_t);
}
extern "C" {
	#[doc = " Create shader uniform parameter.\n @remarks\n   1. Uniform names are unique. It's valid to call `bgfx::createUniform`\n	  multiple times with the same uniform name. The library will always\n	  return the same handle, but the handle reference count will be\n	  incremented. This means that the same number of `bgfx::destroyUniform`\n	  must be called to properly destroy the uniform.\n   2. Predefined uniforms (declared in `bgfx_shader.sh`):\n	  - `u_viewRect vec4(x, y, width, height)` - view rectangle for current\n		view, in pixels.\n	  - `u_viewTexel vec4(1.0/width, 1.0/height, undef, undef)` - inverse\n		width and height\n	  - `u_view mat4` - view matrix\n	  - `u_invView mat4` - inverted view matrix\n	  - `u_proj mat4` - projection matrix\n	  - `u_invProj mat4` - inverted projection matrix\n	  - `u_viewProj mat4` - concatenated view projection matrix\n	  - `u_invViewProj mat4` - concatenated inverted view projection matrix\n	  - `u_model mat4[BGFX_CONFIG_MAX_BONES]` - array of model matrices.\n	  - `u_modelView mat4` - concatenated model view matrix, only first\n		model matrix from array is used.\n	  - `u_modelViewProj mat4` - concatenated model view projection matrix.\n	  - `u_alphaRef float` - alpha reference value for alpha test.\n\n @param[in] _name Uniform name in shader.\n @param[in] _type Type of uniform (See: `bgfx::UniformType`).\n @param[in] _num Number of elements in array.\n\n @returns Handle to uniform object.\n"]
	pub fn bgfx_create_uniform(
		_name: *const ::std::os::raw::c_char,
		_type: bgfx_uniform_type_t,
		_num: u16,
	) -> bgfx_uniform_handle_t;
}
extern "C" {
	#[doc = " Retrieve uniform info.\n\n @param[in] _handle Handle to uniform object.\n @param[out] _info Uniform info.\n"]
	pub fn bgfx_get_uniform_info(_handle: bgfx_uniform_handle_t, _info: *mut bgfx_uniform_info_t);
}
extern "C" {
	#[doc = " Destroy shader uniform parameter.\n\n @param[in] _handle Handle to uniform object.\n"]
	pub fn bgfx_destroy_uniform(_handle: bgfx_uniform_handle_t);
}
extern "C" {
	#[doc = " Create occlusion query.\n"]
	pub fn bgfx_create_occlusion_query() -> bgfx_occlusion_query_handle_t;
}
extern "C" {
	#[doc = " Retrieve occlusion query result from previous frame.\n\n @param[in] _handle Handle to occlusion query object.\n @param[out] _result Number of pixels that passed test. This argument\n  can be `NULL` if result of occlusion query is not needed.\n\n @returns Occlusion query result.\n"]
	pub fn bgfx_get_result(
		_handle: bgfx_occlusion_query_handle_t,
		_result: *mut i32,
	) -> bgfx_occlusion_query_result_t;
}
extern "C" {
	#[doc = " Destroy occlusion query.\n\n @param[in] _handle Handle to occlusion query object.\n"]
	pub fn bgfx_destroy_occlusion_query(_handle: bgfx_occlusion_query_handle_t);
}
extern "C" {
	#[doc = " Set palette color value.\n\n @param[in] _index Index into palette.\n @param[in] _rgba RGBA floating point values.\n"]
	pub fn bgfx_set_palette_color(_index: u8, _rgba: *const f32);
}
extern "C" {
	#[doc = " Set palette color value.\n\n @param[in] _index Index into palette.\n @param[in] _r Red value (RGBA floating point values)\n @param[in] _g Green value (RGBA floating point values)\n @param[in] _b Blue value (RGBA floating point values)\n @param[in] _a Alpha value (RGBA floating point values)\n"]
	pub fn bgfx_set_palette_color_rgba32f(_index: u8, _r: f32, _g: f32, _b: f32, _a: f32);
}
extern "C" {
	#[doc = " Set palette color value.\n\n @param[in] _index Index into palette.\n @param[in] _rgba Packed 32-bit RGBA value.\n"]
	pub fn bgfx_set_palette_color_rgba8(_index: u8, _rgba: u32);
}
extern "C" {
	#[doc = " Set view name.\n @remarks\n   This is debug only feature.\n   In graphics debugger view name will appear as:\n	   \"nnnc <view name>\"\n		^  ^ ^\n		|  +--- compute (C)\n		+------ view id\n\n @param[in] _id View id.\n @param[in] _name View name.\n @param[in] _len View name length (if length is INT32_MAX, it's expected\n  that _name is zero terminated string.\n"]
	pub fn bgfx_set_view_name(_id: bgfx_view_id_t, _name: *const ::std::os::raw::c_char, _len: i32);
}
extern "C" {
	#[doc = " Set view rectangle. Draw primitive outside view will be clipped.\n\n @param[in] _id View id.\n @param[in] _x Position x from the left corner of the window.\n @param[in] _y Position y from the top corner of the window.\n @param[in] _width Width of view port region.\n @param[in] _height Height of view port region.\n"]
	pub fn bgfx_set_view_rect(_id: bgfx_view_id_t, _x: u16, _y: u16, _width: u16, _height: u16);
}
extern "C" {
	#[doc = " Set view rectangle. Draw primitive outside view will be clipped.\n\n @param[in] _id View id.\n @param[in] _x Position x from the left corner of the window.\n @param[in] _y Position y from the top corner of the window.\n @param[in] _ratio Width and height will be set in respect to back-buffer size.\n  See: `BackbufferRatio::Enum`.\n"]
	pub fn bgfx_set_view_rect_ratio(
		_id: bgfx_view_id_t,
		_x: u16,
		_y: u16,
		_ratio: bgfx_backbuffer_ratio_t,
	);
}
extern "C" {
	#[doc = " Set view scissor. Draw primitive outside view will be clipped. When\n _x, _y, _width and _height are set to 0, scissor will be disabled.\n\n @param[in] _id View id.\n @param[in] _x Position x from the left corner of the window.\n @param[in] _y Position y from the top corner of the window.\n @param[in] _width Width of view scissor region.\n @param[in] _height Height of view scissor region.\n"]
	pub fn bgfx_set_view_scissor(_id: bgfx_view_id_t, _x: u16, _y: u16, _width: u16, _height: u16);
}
extern "C" {
	#[doc = " Set view clear flags.\n\n @param[in] _id View id.\n @param[in] _flags Clear flags. Use `BGFX_CLEAR_NONE` to remove any clear\n  operation. See: `BGFX_CLEAR_*`.\n @param[in] _rgba Color clear value.\n @param[in] _depth Depth clear value.\n @param[in] _stencil Stencil clear value.\n"]
	pub fn bgfx_set_view_clear(
		_id: bgfx_view_id_t,
		_flags: u16,
		_rgba: u32,
		_depth: f32,
		_stencil: u8,
	);
}
extern "C" {
	#[doc = " Set view clear flags with different clear color for each\n frame buffer texture. `bgfx::setPaletteColor` must be used to set up a\n clear color palette.\n\n @param[in] _id View id.\n @param[in] _flags Clear flags. Use `BGFX_CLEAR_NONE` to remove any clear\n  operation. See: `BGFX_CLEAR_*`.\n @param[in] _depth Depth clear value.\n @param[in] _stencil Stencil clear value.\n @param[in] _c0 Palette index for frame buffer attachment 0.\n @param[in] _c1 Palette index for frame buffer attachment 1.\n @param[in] _c2 Palette index for frame buffer attachment 2.\n @param[in] _c3 Palette index for frame buffer attachment 3.\n @param[in] _c4 Palette index for frame buffer attachment 4.\n @param[in] _c5 Palette index for frame buffer attachment 5.\n @param[in] _c6 Palette index for frame buffer attachment 6.\n @param[in] _c7 Palette index for frame buffer attachment 7.\n"]
	pub fn bgfx_set_view_clear_mrt(
		_id: bgfx_view_id_t,
		_flags: u16,
		_depth: f32,
		_stencil: u8,
		_c0: u8,
		_c1: u8,
		_c2: u8,
		_c3: u8,
		_c4: u8,
		_c5: u8,
		_c6: u8,
		_c7: u8,
	);
}
extern "C" {
	#[doc = " Set view sorting mode.\n @remarks\n   View mode must be set prior calling `bgfx::submit` for the view.\n\n @param[in] _id View id.\n @param[in] _mode View sort mode. See `ViewMode::Enum`.\n"]
	pub fn bgfx_set_view_mode(_id: bgfx_view_id_t, _mode: bgfx_view_mode_t);
}
extern "C" {
	#[doc = " Set view frame buffer.\n @remarks\n   Not persistent after `bgfx::reset` call.\n\n @param[in] _id View id.\n @param[in] _handle Frame buffer handle. Passing `BGFX_INVALID_HANDLE` as\n  frame buffer handle will draw primitives from this view into\n  default back buffer.\n"]
	pub fn bgfx_set_view_frame_buffer(_id: bgfx_view_id_t, _handle: bgfx_frame_buffer_handle_t);
}
extern "C" {
	#[doc = " Set view's view matrix and projection matrix,\n all draw primitives in this view will use these two matrices.\n\n @param[in] _id View id.\n @param[in] _view View matrix.\n @param[in] _proj Projection matrix.\n"]
	pub fn bgfx_set_view_transform(
		_id: bgfx_view_id_t,
		_view: *const ::std::os::raw::c_void,
		_proj: *const ::std::os::raw::c_void,
	);
}
extern "C" {
	#[doc = " Post submit view reordering.\n\n @param[in] _id First view id.\n @param[in] _num Number of views to remap.\n @param[in] _order View remap id table. Passing `NULL` will reset view ids\n  to default state.\n"]
	pub fn bgfx_set_view_order(_id: bgfx_view_id_t, _num: u16, _order: *const bgfx_view_id_t);
}
extern "C" {
	#[doc = " Reset all view settings to default.\n\n @param[in] _id\n"]
	pub fn bgfx_reset_view(_id: bgfx_view_id_t);
}
extern "C" {
	#[doc = " Begin submitting draw calls from thread.\n\n @param[in] _forThread Explicitly request an encoder for a worker thread.\n\n @returns Encoder.\n"]
	pub fn bgfx_encoder_begin(_forThread: bool) -> *mut bgfx_encoder_t;
}
extern "C" {
	#[doc = " End submitting draw calls from thread.\n\n @param[in] _encoder Encoder.\n"]
	pub fn bgfx_encoder_end(_encoder: *mut bgfx_encoder_t);
}
extern "C" {
	#[doc = " Sets a debug marker. This allows you to group graphics calls together for easy browsing in\n graphics debugging tools.\n\n @param[in] _name Marker name.\n @param[in] _len Marker name length (if length is INT32_MAX, it's expected\n  that _name is zero terminated string.\n"]
	pub fn bgfx_encoder_set_marker(
		_this: *mut bgfx_encoder_t,
		_name: *const ::std::os::raw::c_char,
		_len: i32,
	);
}
extern "C" {
	#[doc = " Set render states for draw primitive.\n @remarks\n   1. To set up more complex states use:\n	  `BGFX_STATE_ALPHA_REF(_ref)`,\n	  `BGFX_STATE_POINT_SIZE(_size)`,\n	  `BGFX_STATE_BLEND_FUNC(_src, _dst)`,\n	  `BGFX_STATE_BLEND_FUNC_SEPARATE(_srcRGB, _dstRGB, _srcA, _dstA)`,\n	  `BGFX_STATE_BLEND_EQUATION(_equation)`,\n	  `BGFX_STATE_BLEND_EQUATION_SEPARATE(_equationRGB, _equationA)`\n   2. `BGFX_STATE_BLEND_EQUATION_ADD` is set when no other blend\n	  equation is specified.\n\n @param[in] _state State flags. Default state for primitive type is\n	triangles. See: `BGFX_STATE_DEFAULT`.\n	- `BGFX_STATE_DEPTH_TEST_*` - Depth test function.\n	- `BGFX_STATE_BLEND_*` - See remark 1 about BGFX_STATE_BLEND_FUNC.\n	- `BGFX_STATE_BLEND_EQUATION_*` - See remark 2.\n	- `BGFX_STATE_CULL_*` - Backface culling mode.\n	- `BGFX_STATE_WRITE_*` - Enable R, G, B, A or Z write.\n	- `BGFX_STATE_MSAA` - Enable hardware multisample antialiasing.\n	- `BGFX_STATE_PT_[TRISTRIP/LINES/POINTS]` - Primitive type.\n @param[in] _rgba Sets blend factor used by `BGFX_STATE_BLEND_FACTOR` and\n	`BGFX_STATE_BLEND_INV_FACTOR` blend modes.\n"]
	pub fn bgfx_encoder_set_state(_this: *mut bgfx_encoder_t, _state: u64, _rgba: u32);
}
extern "C" {
	#[doc = " Set condition for rendering.\n\n @param[in] _handle Occlusion query handle.\n @param[in] _visible Render if occlusion query is visible.\n"]
	pub fn bgfx_encoder_set_condition(
		_this: *mut bgfx_encoder_t,
		_handle: bgfx_occlusion_query_handle_t,
		_visible: bool,
	);
}
extern "C" {
	#[doc = " Set stencil test state.\n\n @param[in] _fstencil Front stencil state.\n @param[in] _bstencil Back stencil state. If back is set to `BGFX_STENCIL_NONE`\n  _fstencil is applied to both front and back facing primitives.\n"]
	pub fn bgfx_encoder_set_stencil(_this: *mut bgfx_encoder_t, _fstencil: u32, _bstencil: u32);
}
extern "C" {
	#[doc = " Set scissor for draw primitive.\n @remark\n   To scissor for all primitives in view see `bgfx::setViewScissor`.\n\n @param[in] _x Position x from the left corner of the window.\n @param[in] _y Position y from the top corner of the window.\n @param[in] _width Width of view scissor region.\n @param[in] _height Height of view scissor region.\n\n @returns Scissor cache index.\n"]
	pub fn bgfx_encoder_set_scissor(
		_this: *mut bgfx_encoder_t,
		_x: u16,
		_y: u16,
		_width: u16,
		_height: u16,
	) -> u16;
}
extern "C" {
	#[doc = " Set scissor from cache for draw primitive.\n @remark\n   To scissor for all primitives in view see `bgfx::setViewScissor`.\n\n @param[in] _cache Index in scissor cache.\n"]
	pub fn bgfx_encoder_set_scissor_cached(_this: *mut bgfx_encoder_t, _cache: u16);
}
extern "C" {
	#[doc = " Set model matrix for draw primitive. If it is not called,\n the model will be rendered with an identity model matrix.\n\n @param[in] _mtx Pointer to first matrix in array.\n @param[in] _num Number of matrices in array.\n\n @returns Index into matrix cache in case the same model matrix has\n  to be used for other draw primitive call.\n"]
	pub fn bgfx_encoder_set_transform(
		_this: *mut bgfx_encoder_t,
		_mtx: *const ::std::os::raw::c_void,
		_num: u16,
	) -> u32;
}
extern "C" {
	#[doc = "  Set model matrix from matrix cache for draw primitive.\n\n @param[in] _cache Index in matrix cache.\n @param[in] _num Number of matrices from cache.\n"]
	pub fn bgfx_encoder_set_transform_cached(_this: *mut bgfx_encoder_t, _cache: u32, _num: u16);
}
extern "C" {
	#[doc = " Reserve matrices in internal matrix cache.\n @attention Pointer returned can be modified until `bgfx::frame` is called.\n\n @param[out] _transform Pointer to `Transform` structure.\n @param[in] _num Number of matrices.\n\n @returns Index in matrix cache.\n"]
	pub fn bgfx_encoder_alloc_transform(
		_this: *mut bgfx_encoder_t,
		_transform: *mut bgfx_transform_t,
		_num: u16,
	) -> u32;
}
extern "C" {
	#[doc = " Set shader uniform parameter for draw primitive.\n\n @param[in] _handle Uniform.\n @param[in] _value Pointer to uniform data.\n @param[in] _num Number of elements. Passing `UINT16_MAX` will\n  use the _num passed on uniform creation.\n"]
	pub fn bgfx_encoder_set_uniform(
		_this: *mut bgfx_encoder_t,
		_handle: bgfx_uniform_handle_t,
		_value: *const ::std::os::raw::c_void,
		_num: u16,
	);
}
extern "C" {
	#[doc = " Set index buffer for draw primitive.\n\n @param[in] _handle Index buffer.\n @param[in] _firstIndex First index to render.\n @param[in] _numIndices Number of indices to render.\n"]
	pub fn bgfx_encoder_set_index_buffer(
		_this: *mut bgfx_encoder_t,
		_handle: bgfx_index_buffer_handle_t,
		_firstIndex: u32,
		_numIndices: u32,
	);
}
extern "C" {
	#[doc = " Set index buffer for draw primitive.\n\n @param[in] _handle Dynamic index buffer.\n @param[in] _firstIndex First index to render.\n @param[in] _numIndices Number of indices to render.\n"]
	pub fn bgfx_encoder_set_dynamic_index_buffer(
		_this: *mut bgfx_encoder_t,
		_handle: bgfx_dynamic_index_buffer_handle_t,
		_firstIndex: u32,
		_numIndices: u32,
	);
}
extern "C" {
	#[doc = " Set index buffer for draw primitive.\n\n @param[in] _tib Transient index buffer.\n @param[in] _firstIndex First index to render.\n @param[in] _numIndices Number of indices to render.\n"]
	pub fn bgfx_encoder_set_transient_index_buffer(
		_this: *mut bgfx_encoder_t,
		_tib: *const bgfx_transient_index_buffer_t,
		_firstIndex: u32,
		_numIndices: u32,
	);
}
extern "C" {
	#[doc = " Set vertex buffer for draw primitive.\n\n @param[in] _stream Vertex stream.\n @param[in] _handle Vertex buffer.\n @param[in] _startVertex First vertex to render.\n @param[in] _numVertices Number of vertices to render.\n"]
	pub fn bgfx_encoder_set_vertex_buffer(
		_this: *mut bgfx_encoder_t,
		_stream: u8,
		_handle: bgfx_vertex_buffer_handle_t,
		_startVertex: u32,
		_numVertices: u32,
	);
}
extern "C" {
	#[doc = " Set vertex buffer for draw primitive.\n\n @param[in] _stream Vertex stream.\n @param[in] _handle Vertex buffer.\n @param[in] _startVertex First vertex to render.\n @param[in] _numVertices Number of vertices to render.\n @param[in] _layoutHandle Vertex layout for aliasing vertex buffer. If invalid\n  handle is used, vertex layout used for creation\n  of vertex buffer will be used.\n"]
	pub fn bgfx_encoder_set_vertex_buffer_with_layout(
		_this: *mut bgfx_encoder_t,
		_stream: u8,
		_handle: bgfx_vertex_buffer_handle_t,
		_startVertex: u32,
		_numVertices: u32,
		_layoutHandle: bgfx_vertex_layout_handle_t,
	);
}
extern "C" {
	#[doc = " Set vertex buffer for draw primitive.\n\n @param[in] _stream Vertex stream.\n @param[in] _handle Dynamic vertex buffer.\n @param[in] _startVertex First vertex to render.\n @param[in] _numVertices Number of vertices to render.\n"]
	pub fn bgfx_encoder_set_dynamic_vertex_buffer(
		_this: *mut bgfx_encoder_t,
		_stream: u8,
		_handle: bgfx_dynamic_vertex_buffer_handle_t,
		_startVertex: u32,
		_numVertices: u32,
	);
}
extern "C" {
	pub fn bgfx_encoder_set_dynamic_vertex_buffer_with_layout(
		_this: *mut bgfx_encoder_t,
		_stream: u8,
		_handle: bgfx_dynamic_vertex_buffer_handle_t,
		_startVertex: u32,
		_numVertices: u32,
		_layoutHandle: bgfx_vertex_layout_handle_t,
	);
}
extern "C" {
	#[doc = " Set vertex buffer for draw primitive.\n\n @param[in] _stream Vertex stream.\n @param[in] _tvb Transient vertex buffer.\n @param[in] _startVertex First vertex to render.\n @param[in] _numVertices Number of vertices to render.\n"]
	pub fn bgfx_encoder_set_transient_vertex_buffer(
		_this: *mut bgfx_encoder_t,
		_stream: u8,
		_tvb: *const bgfx_transient_vertex_buffer_t,
		_startVertex: u32,
		_numVertices: u32,
	);
}
extern "C" {
	#[doc = " Set vertex buffer for draw primitive.\n\n @param[in] _stream Vertex stream.\n @param[in] _tvb Transient vertex buffer.\n @param[in] _startVertex First vertex to render.\n @param[in] _numVertices Number of vertices to render.\n @param[in] _layoutHandle Vertex layout for aliasing vertex buffer. If invalid\n  handle is used, vertex layout used for creation\n  of vertex buffer will be used.\n"]
	pub fn bgfx_encoder_set_transient_vertex_buffer_with_layout(
		_this: *mut bgfx_encoder_t,
		_stream: u8,
		_tvb: *const bgfx_transient_vertex_buffer_t,
		_startVertex: u32,
		_numVertices: u32,
		_layoutHandle: bgfx_vertex_layout_handle_t,
	);
}
extern "C" {
	#[doc = " Set number of vertices for auto generated vertices use in conjunction\n with gl_VertexID.\n @attention Availability depends on: `BGFX_CAPS_VERTEX_ID`.\n\n @param[in] _numVertices Number of vertices.\n"]
	pub fn bgfx_encoder_set_vertex_count(_this: *mut bgfx_encoder_t, _numVertices: u32);
}
extern "C" {
	#[doc = " Set instance data buffer for draw primitive.\n\n @param[in] _idb Transient instance data buffer.\n @param[in] _start First instance data.\n @param[in] _num Number of data instances.\n"]
	pub fn bgfx_encoder_set_instance_data_buffer(
		_this: *mut bgfx_encoder_t,
		_idb: *const bgfx_instance_data_buffer_t,
		_start: u32,
		_num: u32,
	);
}
extern "C" {
	#[doc = " Set instance data buffer for draw primitive.\n\n @param[in] _handle Vertex buffer.\n @param[in] _startVertex First instance data.\n @param[in] _num Number of data instances.\n"]
	pub fn bgfx_encoder_set_instance_data_from_vertex_buffer(
		_this: *mut bgfx_encoder_t,
		_handle: bgfx_vertex_buffer_handle_t,
		_startVertex: u32,
		_num: u32,
	);
}
extern "C" {
	#[doc = " Set instance data buffer for draw primitive.\n\n @param[in] _handle Dynamic vertex buffer.\n @param[in] _startVertex First instance data.\n @param[in] _num Number of data instances.\n"]
	pub fn bgfx_encoder_set_instance_data_from_dynamic_vertex_buffer(
		_this: *mut bgfx_encoder_t,
		_handle: bgfx_dynamic_vertex_buffer_handle_t,
		_startVertex: u32,
		_num: u32,
	);
}
extern "C" {
	#[doc = " Set number of instances for auto generated instances use in conjunction\n with gl_InstanceID.\n @attention Availability depends on: `BGFX_CAPS_VERTEX_ID`.\n\n @param[in] _numInstances\n"]
	pub fn bgfx_encoder_set_instance_count(_this: *mut bgfx_encoder_t, _numInstances: u32);
}
extern "C" {
	#[doc = " Set texture stage for draw primitive.\n\n @param[in] _stage Texture unit.\n @param[in] _sampler Program sampler.\n @param[in] _handle Texture handle.\n @param[in] _flags Texture sampling mode. Default value UINT32_MAX uses\n	texture sampling settings from the texture.\n	- `BGFX_SAMPLER_[U/V/W]_[MIRROR/CLAMP]` - Mirror or clamp to edge wrap\n	  mode.\n	- `BGFX_SAMPLER_[MIN/MAG/MIP]_[POINT/ANISOTROPIC]` - Point or anisotropic\n	  sampling.\n"]
	pub fn bgfx_encoder_set_texture(
		_this: *mut bgfx_encoder_t,
		_stage: u8,
		_sampler: bgfx_uniform_handle_t,
		_handle: bgfx_texture_handle_t,
		_flags: u32,
	);
}
extern "C" {
	#[doc = " Submit an empty primitive for rendering. Uniforms and draw state\n will be applied but no geometry will be submitted. Useful in cases\n when no other draw/compute primitive is submitted to view, but it's\n desired to execute clear view.\n @remark\n   These empty draw calls will sort before ordinary draw calls.\n\n @param[in] _id View id.\n"]
	pub fn bgfx_encoder_touch(_this: *mut bgfx_encoder_t, _id: bgfx_view_id_t);
}
extern "C" {
	#[doc = " Submit primitive for rendering.\n\n @param[in] _id View id.\n @param[in] _program Program.\n @param[in] _depth Depth for sorting.\n @param[in] _flags Discard or preserve states. See `BGFX_DISCARD_*`.\n"]
	pub fn bgfx_encoder_submit(
		_this: *mut bgfx_encoder_t,
		_id: bgfx_view_id_t,
		_program: bgfx_program_handle_t,
		_depth: u32,
		_flags: u8,
	);
}
extern "C" {
	#[doc = " Submit primitive with occlusion query for rendering.\n\n @param[in] _id View id.\n @param[in] _program Program.\n @param[in] _occlusionQuery Occlusion query.\n @param[in] _depth Depth for sorting.\n @param[in] _flags Discard or preserve states. See `BGFX_DISCARD_*`.\n"]
	pub fn bgfx_encoder_submit_occlusion_query(
		_this: *mut bgfx_encoder_t,
		_id: bgfx_view_id_t,
		_program: bgfx_program_handle_t,
		_occlusionQuery: bgfx_occlusion_query_handle_t,
		_depth: u32,
		_flags: u8,
	);
}
extern "C" {
	#[doc = " Submit primitive for rendering with index and instance data info from\n indirect buffer.\n @attention Availability depends on: `BGFX_CAPS_DRAW_INDIRECT`.\n\n @param[in] _id View id.\n @param[in] _program Program.\n @param[in] _indirectHandle Indirect buffer.\n @param[in] _start First element in indirect buffer.\n @param[in] _num Number of draws.\n @param[in] _depth Depth for sorting.\n @param[in] _flags Discard or preserve states. See `BGFX_DISCARD_*`.\n"]
	pub fn bgfx_encoder_submit_indirect(
		_this: *mut bgfx_encoder_t,
		_id: bgfx_view_id_t,
		_program: bgfx_program_handle_t,
		_indirectHandle: bgfx_indirect_buffer_handle_t,
		_start: u32,
		_num: u32,
		_depth: u32,
		_flags: u8,
	);
}
extern "C" {
	#[doc = " Submit primitive for rendering with index and instance data info and\n draw count from indirect buffers.\n @attention Availability depends on: `BGFX_CAPS_DRAW_INDIRECT_COUNT`.\n\n @param[in] _id View id.\n @param[in] _program Program.\n @param[in] _indirectHandle Indirect buffer.\n @param[in] _start First element in indirect buffer.\n @param[in] _numHandle Buffer for number of draws. Must be\n	created with `BGFX_BUFFER_INDEX32` and `BGFX_BUFFER_DRAW_INDIRECT`.\n @param[in] _numIndex Element in number buffer.\n @param[in] _numMax Max number of draws.\n @param[in] _depth Depth for sorting.\n @param[in] _flags Discard or preserve states. See `BGFX_DISCARD_*`.\n"]
	pub fn bgfx_encoder_submit_indirect_count(
		_this: *mut bgfx_encoder_t,
		_id: bgfx_view_id_t,
		_program: bgfx_program_handle_t,
		_indirectHandle: bgfx_indirect_buffer_handle_t,
		_start: u32,
		_numHandle: bgfx_index_buffer_handle_t,
		_numIndex: u32,
		_numMax: u32,
		_depth: u32,
		_flags: u8,
	);
}
extern "C" {
	#[doc = " Set compute index buffer.\n\n @param[in] _stage Compute stage.\n @param[in] _handle Index buffer handle.\n @param[in] _access Buffer access. See `Access::Enum`.\n"]
	pub fn bgfx_encoder_set_compute_index_buffer(
		_this: *mut bgfx_encoder_t,
		_stage: u8,
		_handle: bgfx_index_buffer_handle_t,
		_access: bgfx_access_t,
	);
}
extern "C" {
	#[doc = " Set compute vertex buffer.\n\n @param[in] _stage Compute stage.\n @param[in] _handle Vertex buffer handle.\n @param[in] _access Buffer access. See `Access::Enum`.\n"]
	pub fn bgfx_encoder_set_compute_vertex_buffer(
		_this: *mut bgfx_encoder_t,
		_stage: u8,
		_handle: bgfx_vertex_buffer_handle_t,
		_access: bgfx_access_t,
	);
}
extern "C" {
	#[doc = " Set compute dynamic index buffer.\n\n @param[in] _stage Compute stage.\n @param[in] _handle Dynamic index buffer handle.\n @param[in] _access Buffer access. See `Access::Enum`.\n"]
	pub fn bgfx_encoder_set_compute_dynamic_index_buffer(
		_this: *mut bgfx_encoder_t,
		_stage: u8,
		_handle: bgfx_dynamic_index_buffer_handle_t,
		_access: bgfx_access_t,
	);
}
extern "C" {
	#[doc = " Set compute dynamic vertex buffer.\n\n @param[in] _stage Compute stage.\n @param[in] _handle Dynamic vertex buffer handle.\n @param[in] _access Buffer access. See `Access::Enum`.\n"]
	pub fn bgfx_encoder_set_compute_dynamic_vertex_buffer(
		_this: *mut bgfx_encoder_t,
		_stage: u8,
		_handle: bgfx_dynamic_vertex_buffer_handle_t,
		_access: bgfx_access_t,
	);
}
extern "C" {
	#[doc = " Set compute indirect buffer.\n\n @param[in] _stage Compute stage.\n @param[in] _handle Indirect buffer handle.\n @param[in] _access Buffer access. See `Access::Enum`.\n"]
	pub fn bgfx_encoder_set_compute_indirect_buffer(
		_this: *mut bgfx_encoder_t,
		_stage: u8,
		_handle: bgfx_indirect_buffer_handle_t,
		_access: bgfx_access_t,
	);
}
extern "C" {
	#[doc = " Set compute image from texture.\n\n @param[in] _stage Compute stage.\n @param[in] _handle Texture handle.\n @param[in] _mip Mip level.\n @param[in] _access Image access. See `Access::Enum`.\n @param[in] _format Texture format. See: `TextureFormat::Enum`.\n"]
	pub fn bgfx_encoder_set_image(
		_this: *mut bgfx_encoder_t,
		_stage: u8,
		_handle: bgfx_texture_handle_t,
		_mip: u8,
		_access: bgfx_access_t,
		_format: bgfx_texture_format_t,
	);
}
extern "C" {
	#[doc = " Dispatch compute.\n\n @param[in] _id View id.\n @param[in] _program Compute program.\n @param[in] _numX Number of groups X.\n @param[in] _numY Number of groups Y.\n @param[in] _numZ Number of groups Z.\n @param[in] _flags Discard or preserve states. See `BGFX_DISCARD_*`.\n"]
	pub fn bgfx_encoder_dispatch(
		_this: *mut bgfx_encoder_t,
		_id: bgfx_view_id_t,
		_program: bgfx_program_handle_t,
		_numX: u32,
		_numY: u32,
		_numZ: u32,
		_flags: u8,
	);
}
extern "C" {
	#[doc = " Dispatch compute indirect.\n\n @param[in] _id View id.\n @param[in] _program Compute program.\n @param[in] _indirectHandle Indirect buffer.\n @param[in] _start First element in indirect buffer.\n @param[in] _num Number of dispatches.\n @param[in] _flags Discard or preserve states. See `BGFX_DISCARD_*`.\n"]
	pub fn bgfx_encoder_dispatch_indirect(
		_this: *mut bgfx_encoder_t,
		_id: bgfx_view_id_t,
		_program: bgfx_program_handle_t,
		_indirectHandle: bgfx_indirect_buffer_handle_t,
		_start: u32,
		_num: u32,
		_flags: u8,
	);
}
extern "C" {
	#[doc = " Discard previously set state for draw or compute call.\n\n @param[in] _flags Discard or preserve states. See `BGFX_DISCARD_*`.\n"]
	pub fn bgfx_encoder_discard(_this: *mut bgfx_encoder_t, _flags: u8);
}
extern "C" {
	#[doc = " Blit 2D texture region between two 2D textures.\n @attention Destination texture must be created with `BGFX_TEXTURE_BLIT_DST` flag.\n @attention Availability depends on: `BGFX_CAPS_TEXTURE_BLIT`.\n\n @param[in] _id View id.\n @param[in] _dst Destination texture handle.\n @param[in] _dstMip Destination texture mip level.\n @param[in] _dstX Destination texture X position.\n @param[in] _dstY Destination texture Y position.\n @param[in] _dstZ If texture is 2D this argument should be 0. If destination texture is cube\n  this argument represents destination texture cube face. For 3D texture this argument\n  represents destination texture Z position.\n @param[in] _src Source texture handle.\n @param[in] _srcMip Source texture mip level.\n @param[in] _srcX Source texture X position.\n @param[in] _srcY Source texture Y position.\n @param[in] _srcZ If texture is 2D this argument should be 0. If source texture is cube\n  this argument represents source texture cube face. For 3D texture this argument\n  represents source texture Z position.\n @param[in] _width Width of region.\n @param[in] _height Height of region.\n @param[in] _depth If texture is 3D this argument represents depth of region, otherwise it's\n  unused.\n"]
	pub fn bgfx_encoder_blit(
		_this: *mut bgfx_encoder_t,
		_id: bgfx_view_id_t,
		_dst: bgfx_texture_handle_t,
		_dstMip: u8,
		_dstX: u16,
		_dstY: u16,
		_dstZ: u16,
		_src: bgfx_texture_handle_t,
		_srcMip: u8,
		_srcX: u16,
		_srcY: u16,
		_srcZ: u16,
		_width: u16,
		_height: u16,
		_depth: u16,
	);
}
extern "C" {
	#[doc = " Request screen shot of window back buffer.\n @remarks\n   `bgfx::CallbackI::screenShot` must be implemented.\n @attention Frame buffer handle must be created with OS' target native window handle.\n\n @param[in] _handle Frame buffer handle. If handle is `BGFX_INVALID_HANDLE` request will be\n  made for main window back buffer.\n @param[in] _filePath Will be passed to `bgfx::CallbackI::screenShot` callback.\n"]
	pub fn bgfx_request_screen_shot(
		_handle: bgfx_frame_buffer_handle_t,
		_filePath: *const ::std::os::raw::c_char,
	);
}
extern "C" {
	#[doc = " Render frame.\n @attention `bgfx::renderFrame` is blocking call. It waits for\n   `bgfx::frame` to be called from API thread to process frame.\n   If timeout value is passed call will timeout and return even\n   if `bgfx::frame` is not called.\n @warning This call should be only used on platforms that don't\n   allow creating separate rendering thread. If it is called before\n   to bgfx::init, render thread won't be created by bgfx::init call.\n\n @param[in] _msecs Timeout in milliseconds.\n\n @returns Current renderer context state. See: `bgfx::RenderFrame`.\n"]
	pub fn bgfx_render_frame(_msecs: i32) -> bgfx_render_frame_t;
}
extern "C" {
	#[doc = " Set platform data.\n @warning Must be called before `bgfx::init`.\n\n @param[in] _data Platform data.\n"]
	pub fn bgfx_set_platform_data(_data: *const bgfx_platform_data_t);
}
extern "C" {
	#[doc = " Get internal data for interop.\n @attention It's expected you understand some bgfx internals before you\n   use this call.\n @warning Must be called only on render thread.\n"]
	pub fn bgfx_get_internal_data() -> *const bgfx_internal_data_t;
}
extern "C" {
	#[doc = " Override internal texture with externally created texture. Previously\n created internal texture will released.\n @attention It's expected you understand some bgfx internals before you\n   use this call.\n @warning Must be called only on render thread.\n\n @param[in] _handle Texture handle.\n @param[in] _ptr Native API pointer to texture.\n\n @returns Native API pointer to texture. If result is 0, texture is not created\n  yet from the main thread.\n"]
	pub fn bgfx_override_internal_texture_ptr(_handle: bgfx_texture_handle_t, _ptr: usize)
		-> usize;
}
extern "C" {
	#[doc = " Override internal texture by creating new texture. Previously created\n internal texture will released.\n @attention It's expected you understand some bgfx internals before you\n   use this call.\n @returns Native API pointer to texture. If result is 0, texture is not created yet from the\n   main thread.\n @warning Must be called only on render thread.\n\n @param[in] _handle Texture handle.\n @param[in] _width Width.\n @param[in] _height Height.\n @param[in] _numMips Number of mip-maps.\n @param[in] _format Texture format. See: `TextureFormat::Enum`.\n @param[in] _flags Texture creation (see `BGFX_TEXTURE_*`.), and sampler (see `BGFX_SAMPLER_*`)\n  flags. Default texture sampling mode is linear, and wrap mode is repeat.\n  - `BGFX_SAMPLER_[U/V/W]_[MIRROR/CLAMP]` - Mirror or clamp to edge wrap\n	mode.\n  - `BGFX_SAMPLER_[MIN/MAG/MIP]_[POINT/ANISOTROPIC]` - Point or anisotropic\n	sampling.\n\n @returns Native API pointer to texture. If result is 0, texture is not created\n  yet from the main thread.\n"]
	pub fn bgfx_override_internal_texture(
		_handle: bgfx_texture_handle_t,
		_width: u16,
		_height: u16,
		_numMips: u8,
		_format: bgfx_texture_format_t,
		_flags: u64,
	) -> usize;
}
extern "C" {
	#[doc = " Sets a debug marker. This allows you to group graphics calls together for easy browsing in\n graphics debugging tools.\n\n @param[in] _name Marker name.\n @param[in] _len Marker name length (if length is INT32_MAX, it's expected\n  that _name is zero terminated string.\n"]
	pub fn bgfx_set_marker(_name: *const ::std::os::raw::c_char, _len: i32);
}
extern "C" {
	#[doc = " Set render states for draw primitive.\n @remarks\n   1. To set up more complex states use:\n	  `BGFX_STATE_ALPHA_REF(_ref)`,\n	  `BGFX_STATE_POINT_SIZE(_size)`,\n	  `BGFX_STATE_BLEND_FUNC(_src, _dst)`,\n	  `BGFX_STATE_BLEND_FUNC_SEPARATE(_srcRGB, _dstRGB, _srcA, _dstA)`,\n	  `BGFX_STATE_BLEND_EQUATION(_equation)`,\n	  `BGFX_STATE_BLEND_EQUATION_SEPARATE(_equationRGB, _equationA)`\n   2. `BGFX_STATE_BLEND_EQUATION_ADD` is set when no other blend\n	  equation is specified.\n\n @param[in] _state State flags. Default state for primitive type is\n	triangles. See: `BGFX_STATE_DEFAULT`.\n	- `BGFX_STATE_DEPTH_TEST_*` - Depth test function.\n	- `BGFX_STATE_BLEND_*` - See remark 1 about BGFX_STATE_BLEND_FUNC.\n	- `BGFX_STATE_BLEND_EQUATION_*` - See remark 2.\n	- `BGFX_STATE_CULL_*` - Backface culling mode.\n	- `BGFX_STATE_WRITE_*` - Enable R, G, B, A or Z write.\n	- `BGFX_STATE_MSAA` - Enable hardware multisample antialiasing.\n	- `BGFX_STATE_PT_[TRISTRIP/LINES/POINTS]` - Primitive type.\n @param[in] _rgba Sets blend factor used by `BGFX_STATE_BLEND_FACTOR` and\n	`BGFX_STATE_BLEND_INV_FACTOR` blend modes.\n"]
	pub fn bgfx_set_state(_state: u64, _rgba: u32);
}
extern "C" {
	#[doc = " Set condition for rendering.\n\n @param[in] _handle Occlusion query handle.\n @param[in] _visible Render if occlusion query is visible.\n"]
	pub fn bgfx_set_condition(_handle: bgfx_occlusion_query_handle_t, _visible: bool);
}
extern "C" {
	#[doc = " Set stencil test state.\n\n @param[in] _fstencil Front stencil state.\n @param[in] _bstencil Back stencil state. If back is set to `BGFX_STENCIL_NONE`\n  _fstencil is applied to both front and back facing primitives.\n"]
	pub fn bgfx_set_stencil(_fstencil: u32, _bstencil: u32);
}
extern "C" {
	#[doc = " Set scissor for draw primitive.\n @remark\n   To scissor for all primitives in view see `bgfx::setViewScissor`.\n\n @param[in] _x Position x from the left corner of the window.\n @param[in] _y Position y from the top corner of the window.\n @param[in] _width Width of view scissor region.\n @param[in] _height Height of view scissor region.\n\n @returns Scissor cache index.\n"]
	pub fn bgfx_set_scissor(_x: u16, _y: u16, _width: u16, _height: u16) -> u16;
}
extern "C" {
	#[doc = " Set scissor from cache for draw primitive.\n @remark\n   To scissor for all primitives in view see `bgfx::setViewScissor`.\n\n @param[in] _cache Index in scissor cache.\n"]
	pub fn bgfx_set_scissor_cached(_cache: u16);
}
extern "C" {
	#[doc = " Set model matrix for draw primitive. If it is not called,\n the model will be rendered with an identity model matrix.\n\n @param[in] _mtx Pointer to first matrix in array.\n @param[in] _num Number of matrices in array.\n\n @returns Index into matrix cache in case the same model matrix has\n  to be used for other draw primitive call.\n"]
	pub fn bgfx_set_transform(_mtx: *const ::std::os::raw::c_void, _num: u16) -> u32;
}
extern "C" {
	#[doc = "  Set model matrix from matrix cache for draw primitive.\n\n @param[in] _cache Index in matrix cache.\n @param[in] _num Number of matrices from cache.\n"]
	pub fn bgfx_set_transform_cached(_cache: u32, _num: u16);
}
extern "C" {
	#[doc = " Reserve matrices in internal matrix cache.\n @attention Pointer returned can be modified until `bgfx::frame` is called.\n\n @param[out] _transform Pointer to `Transform` structure.\n @param[in] _num Number of matrices.\n\n @returns Index in matrix cache.\n"]
	pub fn bgfx_alloc_transform(_transform: *mut bgfx_transform_t, _num: u16) -> u32;
}
extern "C" {
	#[doc = " Set shader uniform parameter for draw primitive.\n\n @param[in] _handle Uniform.\n @param[in] _value Pointer to uniform data.\n @param[in] _num Number of elements. Passing `UINT16_MAX` will\n  use the _num passed on uniform creation.\n"]
	pub fn bgfx_set_uniform(
		_handle: bgfx_uniform_handle_t,
		_value: *const ::std::os::raw::c_void,
		_num: u16,
	);
}
extern "C" {
	#[doc = " Set index buffer for draw primitive.\n\n @param[in] _handle Index buffer.\n @param[in] _firstIndex First index to render.\n @param[in] _numIndices Number of indices to render.\n"]
	pub fn bgfx_set_index_buffer(
		_handle: bgfx_index_buffer_handle_t,
		_firstIndex: u32,
		_numIndices: u32,
	);
}
extern "C" {
	#[doc = " Set index buffer for draw primitive.\n\n @param[in] _handle Dynamic index buffer.\n @param[in] _firstIndex First index to render.\n @param[in] _numIndices Number of indices to render.\n"]
	pub fn bgfx_set_dynamic_index_buffer(
		_handle: bgfx_dynamic_index_buffer_handle_t,
		_firstIndex: u32,
		_numIndices: u32,
	);
}
extern "C" {
	#[doc = " Set index buffer for draw primitive.\n\n @param[in] _tib Transient index buffer.\n @param[in] _firstIndex First index to render.\n @param[in] _numIndices Number of indices to render.\n"]
	pub fn bgfx_set_transient_index_buffer(
		_tib: *const bgfx_transient_index_buffer_t,
		_firstIndex: u32,
		_numIndices: u32,
	);
}
extern "C" {
	#[doc = " Set vertex buffer for draw primitive.\n\n @param[in] _stream Vertex stream.\n @param[in] _handle Vertex buffer.\n @param[in] _startVertex First vertex to render.\n @param[in] _numVertices Number of vertices to render.\n"]
	pub fn bgfx_set_vertex_buffer(
		_stream: u8,
		_handle: bgfx_vertex_buffer_handle_t,
		_startVertex: u32,
		_numVertices: u32,
	);
}
extern "C" {
	#[doc = " Set vertex buffer for draw primitive.\n\n @param[in] _stream Vertex stream.\n @param[in] _handle Vertex buffer.\n @param[in] _startVertex First vertex to render.\n @param[in] _numVertices Number of vertices to render.\n @param[in] _layoutHandle Vertex layout for aliasing vertex buffer. If invalid\n  handle is used, vertex layout used for creation\n  of vertex buffer will be used.\n"]
	pub fn bgfx_set_vertex_buffer_with_layout(
		_stream: u8,
		_handle: bgfx_vertex_buffer_handle_t,
		_startVertex: u32,
		_numVertices: u32,
		_layoutHandle: bgfx_vertex_layout_handle_t,
	);
}
extern "C" {
	#[doc = " Set vertex buffer for draw primitive.\n\n @param[in] _stream Vertex stream.\n @param[in] _handle Dynamic vertex buffer.\n @param[in] _startVertex First vertex to render.\n @param[in] _numVertices Number of vertices to render.\n"]
	pub fn bgfx_set_dynamic_vertex_buffer(
		_stream: u8,
		_handle: bgfx_dynamic_vertex_buffer_handle_t,
		_startVertex: u32,
		_numVertices: u32,
	);
}
extern "C" {
	#[doc = " Set vertex buffer for draw primitive.\n\n @param[in] _stream Vertex stream.\n @param[in] _handle Dynamic vertex buffer.\n @param[in] _startVertex First vertex to render.\n @param[in] _numVertices Number of vertices to render.\n @param[in] _layoutHandle Vertex layout for aliasing vertex buffer. If invalid\n  handle is used, vertex layout used for creation\n  of vertex buffer will be used.\n"]
	pub fn bgfx_set_dynamic_vertex_buffer_with_layout(
		_stream: u8,
		_handle: bgfx_dynamic_vertex_buffer_handle_t,
		_startVertex: u32,
		_numVertices: u32,
		_layoutHandle: bgfx_vertex_layout_handle_t,
	);
}
extern "C" {
	#[doc = " Set vertex buffer for draw primitive.\n\n @param[in] _stream Vertex stream.\n @param[in] _tvb Transient vertex buffer.\n @param[in] _startVertex First vertex to render.\n @param[in] _numVertices Number of vertices to render.\n"]
	pub fn bgfx_set_transient_vertex_buffer(
		_stream: u8,
		_tvb: *const bgfx_transient_vertex_buffer_t,
		_startVertex: u32,
		_numVertices: u32,
	);
}
extern "C" {
	#[doc = " Set vertex buffer for draw primitive.\n\n @param[in] _stream Vertex stream.\n @param[in] _tvb Transient vertex buffer.\n @param[in] _startVertex First vertex to render.\n @param[in] _numVertices Number of vertices to render.\n @param[in] _layoutHandle Vertex layout for aliasing vertex buffer. If invalid\n  handle is used, vertex layout used for creation\n  of vertex buffer will be used.\n"]
	pub fn bgfx_set_transient_vertex_buffer_with_layout(
		_stream: u8,
		_tvb: *const bgfx_transient_vertex_buffer_t,
		_startVertex: u32,
		_numVertices: u32,
		_layoutHandle: bgfx_vertex_layout_handle_t,
	);
}
extern "C" {
	#[doc = " Set number of vertices for auto generated vertices use in conjunction\n with gl_VertexID.\n @attention Availability depends on: `BGFX_CAPS_VERTEX_ID`.\n\n @param[in] _numVertices Number of vertices.\n"]
	pub fn bgfx_set_vertex_count(_numVertices: u32);
}
extern "C" {
	#[doc = " Set instance data buffer for draw primitive.\n\n @param[in] _idb Transient instance data buffer.\n @param[in] _start First instance data.\n @param[in] _num Number of data instances.\n"]
	pub fn bgfx_set_instance_data_buffer(
		_idb: *const bgfx_instance_data_buffer_t,
		_start: u32,
		_num: u32,
	);
}
extern "C" {
	#[doc = " Set instance data buffer for draw primitive.\n\n @param[in] _handle Vertex buffer.\n @param[in] _startVertex First instance data.\n @param[in] _num Number of data instances.\n"]
	pub fn bgfx_set_instance_data_from_vertex_buffer(
		_handle: bgfx_vertex_buffer_handle_t,
		_startVertex: u32,
		_num: u32,
	);
}
extern "C" {
	#[doc = " Set instance data buffer for draw primitive.\n\n @param[in] _handle Dynamic vertex buffer.\n @param[in] _startVertex First instance data.\n @param[in] _num Number of data instances.\n"]
	pub fn bgfx_set_instance_data_from_dynamic_vertex_buffer(
		_handle: bgfx_dynamic_vertex_buffer_handle_t,
		_startVertex: u32,
		_num: u32,
	);
}
extern "C" {
	#[doc = " Set number of instances for auto generated instances use in conjunction\n with gl_InstanceID.\n @attention Availability depends on: `BGFX_CAPS_VERTEX_ID`.\n\n @param[in] _numInstances\n"]
	pub fn bgfx_set_instance_count(_numInstances: u32);
}
extern "C" {
	#[doc = " Set texture stage for draw primitive.\n\n @param[in] _stage Texture unit.\n @param[in] _sampler Program sampler.\n @param[in] _handle Texture handle.\n @param[in] _flags Texture sampling mode. Default value UINT32_MAX uses\n	texture sampling settings from the texture.\n	- `BGFX_SAMPLER_[U/V/W]_[MIRROR/CLAMP]` - Mirror or clamp to edge wrap\n	  mode.\n	- `BGFX_SAMPLER_[MIN/MAG/MIP]_[POINT/ANISOTROPIC]` - Point or anisotropic\n	  sampling.\n"]
	pub fn bgfx_set_texture(
		_stage: u8,
		_sampler: bgfx_uniform_handle_t,
		_handle: bgfx_texture_handle_t,
		_flags: u32,
	);
}
extern "C" {
	#[doc = " Submit an empty primitive for rendering. Uniforms and draw state\n will be applied but no geometry will be submitted.\n @remark\n   These empty draw calls will sort before ordinary draw calls.\n\n @param[in] _id View id.\n"]
	pub fn bgfx_touch(_id: bgfx_view_id_t);
}
extern "C" {
	#[doc = " Submit primitive for rendering.\n\n @param[in] _id View id.\n @param[in] _program Program.\n @param[in] _depth Depth for sorting.\n @param[in] _flags Which states to discard for next draw. See `BGFX_DISCARD_*`.\n"]
	pub fn bgfx_submit(
		_id: bgfx_view_id_t,
		_program: bgfx_program_handle_t,
		_depth: u32,
		_flags: u8,
	);
}
extern "C" {
	#[doc = " Submit primitive with occlusion query for rendering.\n\n @param[in] _id View id.\n @param[in] _program Program.\n @param[in] _occlusionQuery Occlusion query.\n @param[in] _depth Depth for sorting.\n @param[in] _flags Which states to discard for next draw. See `BGFX_DISCARD_*`.\n"]
	pub fn bgfx_submit_occlusion_query(
		_id: bgfx_view_id_t,
		_program: bgfx_program_handle_t,
		_occlusionQuery: bgfx_occlusion_query_handle_t,
		_depth: u32,
		_flags: u8,
	);
}
extern "C" {
	#[doc = " Submit primitive for rendering with index and instance data info from\n indirect buffer.\n @attention Availability depends on: `BGFX_CAPS_DRAW_INDIRECT`.\n\n @param[in] _id View id.\n @param[in] _program Program.\n @param[in] _indirectHandle Indirect buffer.\n @param[in] _start First element in indirect buffer.\n @param[in] _num Number of draws.\n @param[in] _depth Depth for sorting.\n @param[in] _flags Which states to discard for next draw. See `BGFX_DISCARD_*`.\n"]
	pub fn bgfx_submit_indirect(
		_id: bgfx_view_id_t,
		_program: bgfx_program_handle_t,
		_indirectHandle: bgfx_indirect_buffer_handle_t,
		_start: u32,
		_num: u32,
		_depth: u32,
		_flags: u8,
	);
}
extern "C" {
	#[doc = " Submit primitive for rendering with index and instance data info and\n draw count from indirect buffers.\n @attention Availability depends on: `BGFX_CAPS_DRAW_INDIRECT_COUNT`.\n\n @param[in] _id View id.\n @param[in] _program Program.\n @param[in] _indirectHandle Indirect buffer.\n @param[in] _start First element in indirect buffer.\n @param[in] _numHandle Buffer for number of draws. Must be\n	created with `BGFX_BUFFER_INDEX32` and `BGFX_BUFFER_DRAW_INDIRECT`.\n @param[in] _numIndex Element in number buffer.\n @param[in] _numMax Max number of draws.\n @param[in] _depth Depth for sorting.\n @param[in] _flags Which states to discard for next draw. See `BGFX_DISCARD_*`.\n"]
	pub fn bgfx_submit_indirect_count(
		_id: bgfx_view_id_t,
		_program: bgfx_program_handle_t,
		_indirectHandle: bgfx_indirect_buffer_handle_t,
		_start: u32,
		_numHandle: bgfx_index_buffer_handle_t,
		_numIndex: u32,
		_numMax: u32,
		_depth: u32,
		_flags: u8,
	);
}
extern "C" {
	#[doc = " Set compute index buffer.\n\n @param[in] _stage Compute stage.\n @param[in] _handle Index buffer handle.\n @param[in] _access Buffer access. See `Access::Enum`.\n"]
	pub fn bgfx_set_compute_index_buffer(
		_stage: u8,
		_handle: bgfx_index_buffer_handle_t,
		_access: bgfx_access_t,
	);
}
extern "C" {
	#[doc = " Set compute vertex buffer.\n\n @param[in] _stage Compute stage.\n @param[in] _handle Vertex buffer handle.\n @param[in] _access Buffer access. See `Access::Enum`.\n"]
	pub fn bgfx_set_compute_vertex_buffer(
		_stage: u8,
		_handle: bgfx_vertex_buffer_handle_t,
		_access: bgfx_access_t,
	);
}
extern "C" {
	#[doc = " Set compute dynamic index buffer.\n\n @param[in] _stage Compute stage.\n @param[in] _handle Dynamic index buffer handle.\n @param[in] _access Buffer access. See `Access::Enum`.\n"]
	pub fn bgfx_set_compute_dynamic_index_buffer(
		_stage: u8,
		_handle: bgfx_dynamic_index_buffer_handle_t,
		_access: bgfx_access_t,
	);
}
extern "C" {
	#[doc = " Set compute dynamic vertex buffer.\n\n @param[in] _stage Compute stage.\n @param[in] _handle Dynamic vertex buffer handle.\n @param[in] _access Buffer access. See `Access::Enum`.\n"]
	pub fn bgfx_set_compute_dynamic_vertex_buffer(
		_stage: u8,
		_handle: bgfx_dynamic_vertex_buffer_handle_t,
		_access: bgfx_access_t,
	);
}
extern "C" {
	#[doc = " Set compute indirect buffer.\n\n @param[in] _stage Compute stage.\n @param[in] _handle Indirect buffer handle.\n @param[in] _access Buffer access. See `Access::Enum`.\n"]
	pub fn bgfx_set_compute_indirect_buffer(
		_stage: u8,
		_handle: bgfx_indirect_buffer_handle_t,
		_access: bgfx_access_t,
	);
}
extern "C" {
	#[doc = " Set compute image from texture.\n\n @param[in] _stage Compute stage.\n @param[in] _handle Texture handle.\n @param[in] _mip Mip level.\n @param[in] _access Image access. See `Access::Enum`.\n @param[in] _format Texture format. See: `TextureFormat::Enum`.\n"]
	pub fn bgfx_set_image(
		_stage: u8,
		_handle: bgfx_texture_handle_t,
		_mip: u8,
		_access: bgfx_access_t,
		_format: bgfx_texture_format_t,
	);
}
extern "C" {
	#[doc = " Dispatch compute.\n\n @param[in] _id View id.\n @param[in] _program Compute program.\n @param[in] _numX Number of groups X.\n @param[in] _numY Number of groups Y.\n @param[in] _numZ Number of groups Z.\n @param[in] _flags Discard or preserve states. See `BGFX_DISCARD_*`.\n"]
	pub fn bgfx_dispatch(
		_id: bgfx_view_id_t,
		_program: bgfx_program_handle_t,
		_numX: u32,
		_numY: u32,
		_numZ: u32,
		_flags: u8,
	);
}
extern "C" {
	#[doc = " Dispatch compute indirect.\n\n @param[in] _id View id.\n @param[in] _program Compute program.\n @param[in] _indirectHandle Indirect buffer.\n @param[in] _start First element in indirect buffer.\n @param[in] _num Number of dispatches.\n @param[in] _flags Discard or preserve states. See `BGFX_DISCARD_*`.\n"]
	pub fn bgfx_dispatch_indirect(
		_id: bgfx_view_id_t,
		_program: bgfx_program_handle_t,
		_indirectHandle: bgfx_indirect_buffer_handle_t,
		_start: u32,
		_num: u32,
		_flags: u8,
	);
}
extern "C" {
	#[doc = " Discard previously set state for draw or compute call.\n\n @param[in] _flags Draw/compute states to discard.\n"]
	pub fn bgfx_discard(_flags: u8);
}
extern "C" {
	#[doc = " Blit 2D texture region between two 2D textures.\n @attention Destination texture must be created with `BGFX_TEXTURE_BLIT_DST` flag.\n @attention Availability depends on: `BGFX_CAPS_TEXTURE_BLIT`.\n\n @param[in] _id View id.\n @param[in] _dst Destination texture handle.\n @param[in] _dstMip Destination texture mip level.\n @param[in] _dstX Destination texture X position.\n @param[in] _dstY Destination texture Y position.\n @param[in] _dstZ If texture is 2D this argument should be 0. If destination texture is cube\n  this argument represents destination texture cube face. For 3D texture this argument\n  represents destination texture Z position.\n @param[in] _src Source texture handle.\n @param[in] _srcMip Source texture mip level.\n @param[in] _srcX Source texture X position.\n @param[in] _srcY Source texture Y position.\n @param[in] _srcZ If texture is 2D this argument should be 0. If source texture is cube\n  this argument represents source texture cube face. For 3D texture this argument\n  represents source texture Z position.\n @param[in] _width Width of region.\n @param[in] _height Height of region.\n @param[in] _depth If texture is 3D this argument represents depth of region, otherwise it's\n  unused.\n"]
	pub fn bgfx_blit(
		_id: bgfx_view_id_t,
		_dst: bgfx_texture_handle_t,
		_dstMip: u8,
		_dstX: u16,
		_dstY: u16,
		_dstZ: u16,
		_src: bgfx_texture_handle_t,
		_srcMip: u8,
		_srcX: u16,
		_srcY: u16,
		_srcZ: u16,
		_width: u16,
		_height: u16,
		_depth: u16,
	);
}
pub const BGFX_FUNCTION_ID_ATTACHMENT_INIT: bgfx_function_id = 0;
pub const BGFX_FUNCTION_ID_VERTEX_LAYOUT_BEGIN: bgfx_function_id = 1;
pub const BGFX_FUNCTION_ID_VERTEX_LAYOUT_ADD: bgfx_function_id = 2;
pub const BGFX_FUNCTION_ID_VERTEX_LAYOUT_DECODE: bgfx_function_id = 3;
pub const BGFX_FUNCTION_ID_VERTEX_LAYOUT_HAS: bgfx_function_id = 4;
pub const BGFX_FUNCTION_ID_VERTEX_LAYOUT_SKIP: bgfx_function_id = 5;
pub const BGFX_FUNCTION_ID_VERTEX_LAYOUT_END: bgfx_function_id = 6;
pub const BGFX_FUNCTION_ID_VERTEX_LAYOUT_GET_OFFSET: bgfx_function_id = 7;
pub const BGFX_FUNCTION_ID_VERTEX_LAYOUT_GET_STRIDE: bgfx_function_id = 8;
pub const BGFX_FUNCTION_ID_VERTEX_LAYOUT_GET_SIZE: bgfx_function_id = 9;
pub const BGFX_FUNCTION_ID_VERTEX_PACK: bgfx_function_id = 10;
pub const BGFX_FUNCTION_ID_VERTEX_UNPACK: bgfx_function_id = 11;
pub const BGFX_FUNCTION_ID_VERTEX_CONVERT: bgfx_function_id = 12;
pub const BGFX_FUNCTION_ID_WELD_VERTICES: bgfx_function_id = 13;
pub const BGFX_FUNCTION_ID_TOPOLOGY_CONVERT: bgfx_function_id = 14;
pub const BGFX_FUNCTION_ID_TOPOLOGY_SORT_TRI_LIST: bgfx_function_id = 15;
pub const BGFX_FUNCTION_ID_GET_SUPPORTED_RENDERERS: bgfx_function_id = 16;
pub const BGFX_FUNCTION_ID_GET_RENDERER_NAME: bgfx_function_id = 17;
pub const BGFX_FUNCTION_ID_INIT_CTOR: bgfx_function_id = 18;
pub const BGFX_FUNCTION_ID_INIT: bgfx_function_id = 19;
pub const BGFX_FUNCTION_ID_SHUTDOWN: bgfx_function_id = 20;
pub const BGFX_FUNCTION_ID_RESET: bgfx_function_id = 21;
pub const BGFX_FUNCTION_ID_FRAME: bgfx_function_id = 22;
pub const BGFX_FUNCTION_ID_GET_RENDERER_TYPE: bgfx_function_id = 23;
pub const BGFX_FUNCTION_ID_GET_CAPS: bgfx_function_id = 24;
pub const BGFX_FUNCTION_ID_GET_STATS: bgfx_function_id = 25;
pub const BGFX_FUNCTION_ID_ALLOC: bgfx_function_id = 26;
pub const BGFX_FUNCTION_ID_COPY: bgfx_function_id = 27;
pub const BGFX_FUNCTION_ID_MAKE_REF: bgfx_function_id = 28;
pub const BGFX_FUNCTION_ID_MAKE_REF_RELEASE: bgfx_function_id = 29;
pub const BGFX_FUNCTION_ID_SET_DEBUG: bgfx_function_id = 30;
pub const BGFX_FUNCTION_ID_DBG_TEXT_CLEAR: bgfx_function_id = 31;
pub const BGFX_FUNCTION_ID_DBG_TEXT_PRINTF: bgfx_function_id = 32;
pub const BGFX_FUNCTION_ID_DBG_TEXT_VPRINTF: bgfx_function_id = 33;
pub const BGFX_FUNCTION_ID_DBG_TEXT_IMAGE: bgfx_function_id = 34;
pub const BGFX_FUNCTION_ID_CREATE_INDEX_BUFFER: bgfx_function_id = 35;
pub const BGFX_FUNCTION_ID_SET_INDEX_BUFFER_NAME: bgfx_function_id = 36;
pub const BGFX_FUNCTION_ID_DESTROY_INDEX_BUFFER: bgfx_function_id = 37;
pub const BGFX_FUNCTION_ID_CREATE_VERTEX_LAYOUT: bgfx_function_id = 38;
pub const BGFX_FUNCTION_ID_DESTROY_VERTEX_LAYOUT: bgfx_function_id = 39;
pub const BGFX_FUNCTION_ID_CREATE_VERTEX_BUFFER: bgfx_function_id = 40;
pub const BGFX_FUNCTION_ID_SET_VERTEX_BUFFER_NAME: bgfx_function_id = 41;
pub const BGFX_FUNCTION_ID_DESTROY_VERTEX_BUFFER: bgfx_function_id = 42;
pub const BGFX_FUNCTION_ID_CREATE_DYNAMIC_INDEX_BUFFER: bgfx_function_id = 43;
pub const BGFX_FUNCTION_ID_CREATE_DYNAMIC_INDEX_BUFFER_MEM: bgfx_function_id = 44;
pub const BGFX_FUNCTION_ID_UPDATE_DYNAMIC_INDEX_BUFFER: bgfx_function_id = 45;
pub const BGFX_FUNCTION_ID_DESTROY_DYNAMIC_INDEX_BUFFER: bgfx_function_id = 46;
pub const BGFX_FUNCTION_ID_CREATE_DYNAMIC_VERTEX_BUFFER: bgfx_function_id = 47;
pub const BGFX_FUNCTION_ID_CREATE_DYNAMIC_VERTEX_BUFFER_MEM: bgfx_function_id = 48;
pub const BGFX_FUNCTION_ID_UPDATE_DYNAMIC_VERTEX_BUFFER: bgfx_function_id = 49;
pub const BGFX_FUNCTION_ID_DESTROY_DYNAMIC_VERTEX_BUFFER: bgfx_function_id = 50;
pub const BGFX_FUNCTION_ID_GET_AVAIL_TRANSIENT_INDEX_BUFFER: bgfx_function_id = 51;
pub const BGFX_FUNCTION_ID_GET_AVAIL_TRANSIENT_VERTEX_BUFFER: bgfx_function_id = 52;
pub const BGFX_FUNCTION_ID_GET_AVAIL_INSTANCE_DATA_BUFFER: bgfx_function_id = 53;
pub const BGFX_FUNCTION_ID_ALLOC_TRANSIENT_INDEX_BUFFER: bgfx_function_id = 54;
pub const BGFX_FUNCTION_ID_ALLOC_TRANSIENT_VERTEX_BUFFER: bgfx_function_id = 55;
pub const BGFX_FUNCTION_ID_ALLOC_TRANSIENT_BUFFERS: bgfx_function_id = 56;
pub const BGFX_FUNCTION_ID_ALLOC_INSTANCE_DATA_BUFFER: bgfx_function_id = 57;
pub const BGFX_FUNCTION_ID_CREATE_INDIRECT_BUFFER: bgfx_function_id = 58;
pub const BGFX_FUNCTION_ID_DESTROY_INDIRECT_BUFFER: bgfx_function_id = 59;
pub const BGFX_FUNCTION_ID_CREATE_SHADER: bgfx_function_id = 60;
pub const BGFX_FUNCTION_ID_GET_SHADER_UNIFORMS: bgfx_function_id = 61;
pub const BGFX_FUNCTION_ID_SET_SHADER_NAME: bgfx_function_id = 62;
pub const BGFX_FUNCTION_ID_DESTROY_SHADER: bgfx_function_id = 63;
pub const BGFX_FUNCTION_ID_CREATE_PROGRAM: bgfx_function_id = 64;
pub const BGFX_FUNCTION_ID_CREATE_COMPUTE_PROGRAM: bgfx_function_id = 65;
pub const BGFX_FUNCTION_ID_DESTROY_PROGRAM: bgfx_function_id = 66;
pub const BGFX_FUNCTION_ID_IS_TEXTURE_VALID: bgfx_function_id = 67;
pub const BGFX_FUNCTION_ID_IS_FRAME_BUFFER_VALID: bgfx_function_id = 68;
pub const BGFX_FUNCTION_ID_CALC_TEXTURE_SIZE: bgfx_function_id = 69;
pub const BGFX_FUNCTION_ID_CREATE_TEXTURE: bgfx_function_id = 70;
pub const BGFX_FUNCTION_ID_CREATE_TEXTURE_2D: bgfx_function_id = 71;
pub const BGFX_FUNCTION_ID_CREATE_TEXTURE_2D_SCALED: bgfx_function_id = 72;
pub const BGFX_FUNCTION_ID_CREATE_TEXTURE_3D: bgfx_function_id = 73;
pub const BGFX_FUNCTION_ID_CREATE_TEXTURE_CUBE: bgfx_function_id = 74;
pub const BGFX_FUNCTION_ID_UPDATE_TEXTURE_2D: bgfx_function_id = 75;
pub const BGFX_FUNCTION_ID_UPDATE_TEXTURE_3D: bgfx_function_id = 76;
pub const BGFX_FUNCTION_ID_UPDATE_TEXTURE_CUBE: bgfx_function_id = 77;
pub const BGFX_FUNCTION_ID_READ_TEXTURE: bgfx_function_id = 78;
pub const BGFX_FUNCTION_ID_SET_TEXTURE_NAME: bgfx_function_id = 79;
pub const BGFX_FUNCTION_ID_GET_DIRECT_ACCESS_PTR: bgfx_function_id = 80;
pub const BGFX_FUNCTION_ID_DESTROY_TEXTURE: bgfx_function_id = 81;
pub const BGFX_FUNCTION_ID_CREATE_FRAME_BUFFER: bgfx_function_id = 82;
pub const BGFX_FUNCTION_ID_CREATE_FRAME_BUFFER_SCALED: bgfx_function_id = 83;
pub const BGFX_FUNCTION_ID_CREATE_FRAME_BUFFER_FROM_HANDLES: bgfx_function_id = 84;
pub const BGFX_FUNCTION_ID_CREATE_FRAME_BUFFER_FROM_ATTACHMENT: bgfx_function_id = 85;
pub const BGFX_FUNCTION_ID_CREATE_FRAME_BUFFER_FROM_NWH: bgfx_function_id = 86;
pub const BGFX_FUNCTION_ID_SET_FRAME_BUFFER_NAME: bgfx_function_id = 87;
pub const BGFX_FUNCTION_ID_GET_TEXTURE: bgfx_function_id = 88;
pub const BGFX_FUNCTION_ID_DESTROY_FRAME_BUFFER: bgfx_function_id = 89;
pub const BGFX_FUNCTION_ID_CREATE_UNIFORM: bgfx_function_id = 90;
pub const BGFX_FUNCTION_ID_GET_UNIFORM_INFO: bgfx_function_id = 91;
pub const BGFX_FUNCTION_ID_DESTROY_UNIFORM: bgfx_function_id = 92;
pub const BGFX_FUNCTION_ID_CREATE_OCCLUSION_QUERY: bgfx_function_id = 93;
pub const BGFX_FUNCTION_ID_GET_RESULT: bgfx_function_id = 94;
pub const BGFX_FUNCTION_ID_DESTROY_OCCLUSION_QUERY: bgfx_function_id = 95;
pub const BGFX_FUNCTION_ID_SET_PALETTE_COLOR: bgfx_function_id = 96;
pub const BGFX_FUNCTION_ID_SET_PALETTE_COLOR_RGBA32F: bgfx_function_id = 97;
pub const BGFX_FUNCTION_ID_SET_PALETTE_COLOR_RGBA8: bgfx_function_id = 98;
pub const BGFX_FUNCTION_ID_SET_VIEW_NAME: bgfx_function_id = 99;
pub const BGFX_FUNCTION_ID_SET_VIEW_RECT: bgfx_function_id = 100;
pub const BGFX_FUNCTION_ID_SET_VIEW_RECT_RATIO: bgfx_function_id = 101;
pub const BGFX_FUNCTION_ID_SET_VIEW_SCISSOR: bgfx_function_id = 102;
pub const BGFX_FUNCTION_ID_SET_VIEW_CLEAR: bgfx_function_id = 103;
pub const BGFX_FUNCTION_ID_SET_VIEW_CLEAR_MRT: bgfx_function_id = 104;
pub const BGFX_FUNCTION_ID_SET_VIEW_MODE: bgfx_function_id = 105;
pub const BGFX_FUNCTION_ID_SET_VIEW_FRAME_BUFFER: bgfx_function_id = 106;
pub const BGFX_FUNCTION_ID_SET_VIEW_TRANSFORM: bgfx_function_id = 107;
pub const BGFX_FUNCTION_ID_SET_VIEW_ORDER: bgfx_function_id = 108;
pub const BGFX_FUNCTION_ID_RESET_VIEW: bgfx_function_id = 109;
pub const BGFX_FUNCTION_ID_ENCODER_BEGIN: bgfx_function_id = 110;
pub const BGFX_FUNCTION_ID_ENCODER_END: bgfx_function_id = 111;
pub const BGFX_FUNCTION_ID_ENCODER_SET_MARKER: bgfx_function_id = 112;
pub const BGFX_FUNCTION_ID_ENCODER_SET_STATE: bgfx_function_id = 113;
pub const BGFX_FUNCTION_ID_ENCODER_SET_CONDITION: bgfx_function_id = 114;
pub const BGFX_FUNCTION_ID_ENCODER_SET_STENCIL: bgfx_function_id = 115;
pub const BGFX_FUNCTION_ID_ENCODER_SET_SCISSOR: bgfx_function_id = 116;
pub const BGFX_FUNCTION_ID_ENCODER_SET_SCISSOR_CACHED: bgfx_function_id = 117;
pub const BGFX_FUNCTION_ID_ENCODER_SET_TRANSFORM: bgfx_function_id = 118;
pub const BGFX_FUNCTION_ID_ENCODER_SET_TRANSFORM_CACHED: bgfx_function_id = 119;
pub const BGFX_FUNCTION_ID_ENCODER_ALLOC_TRANSFORM: bgfx_function_id = 120;
pub const BGFX_FUNCTION_ID_ENCODER_SET_UNIFORM: bgfx_function_id = 121;
pub const BGFX_FUNCTION_ID_ENCODER_SET_INDEX_BUFFER: bgfx_function_id = 122;
pub const BGFX_FUNCTION_ID_ENCODER_SET_DYNAMIC_INDEX_BUFFER: bgfx_function_id = 123;
pub const BGFX_FUNCTION_ID_ENCODER_SET_TRANSIENT_INDEX_BUFFER: bgfx_function_id = 124;
pub const BGFX_FUNCTION_ID_ENCODER_SET_VERTEX_BUFFER: bgfx_function_id = 125;
pub const BGFX_FUNCTION_ID_ENCODER_SET_VERTEX_BUFFER_WITH_LAYOUT: bgfx_function_id = 126;
pub const BGFX_FUNCTION_ID_ENCODER_SET_DYNAMIC_VERTEX_BUFFER: bgfx_function_id = 127;
pub const BGFX_FUNCTION_ID_ENCODER_SET_DYNAMIC_VERTEX_BUFFER_WITH_LAYOUT: bgfx_function_id = 128;
pub const BGFX_FUNCTION_ID_ENCODER_SET_TRANSIENT_VERTEX_BUFFER: bgfx_function_id = 129;
pub const BGFX_FUNCTION_ID_ENCODER_SET_TRANSIENT_VERTEX_BUFFER_WITH_LAYOUT: bgfx_function_id = 130;
pub const BGFX_FUNCTION_ID_ENCODER_SET_VERTEX_COUNT: bgfx_function_id = 131;
pub const BGFX_FUNCTION_ID_ENCODER_SET_INSTANCE_DATA_BUFFER: bgfx_function_id = 132;
pub const BGFX_FUNCTION_ID_ENCODER_SET_INSTANCE_DATA_FROM_VERTEX_BUFFER: bgfx_function_id = 133;
pub const BGFX_FUNCTION_ID_ENCODER_SET_INSTANCE_DATA_FROM_DYNAMIC_VERTEX_BUFFER: bgfx_function_id =
	134;
pub const BGFX_FUNCTION_ID_ENCODER_SET_INSTANCE_COUNT: bgfx_function_id = 135;
pub const BGFX_FUNCTION_ID_ENCODER_SET_TEXTURE: bgfx_function_id = 136;
pub const BGFX_FUNCTION_ID_ENCODER_TOUCH: bgfx_function_id = 137;
pub const BGFX_FUNCTION_ID_ENCODER_SUBMIT: bgfx_function_id = 138;
pub const BGFX_FUNCTION_ID_ENCODER_SUBMIT_OCCLUSION_QUERY: bgfx_function_id = 139;
pub const BGFX_FUNCTION_ID_ENCODER_SUBMIT_INDIRECT: bgfx_function_id = 140;
pub const BGFX_FUNCTION_ID_ENCODER_SUBMIT_INDIRECT_COUNT: bgfx_function_id = 141;
pub const BGFX_FUNCTION_ID_ENCODER_SET_COMPUTE_INDEX_BUFFER: bgfx_function_id = 142;
pub const BGFX_FUNCTION_ID_ENCODER_SET_COMPUTE_VERTEX_BUFFER: bgfx_function_id = 143;
pub const BGFX_FUNCTION_ID_ENCODER_SET_COMPUTE_DYNAMIC_INDEX_BUFFER: bgfx_function_id = 144;
pub const BGFX_FUNCTION_ID_ENCODER_SET_COMPUTE_DYNAMIC_VERTEX_BUFFER: bgfx_function_id = 145;
pub const BGFX_FUNCTION_ID_ENCODER_SET_COMPUTE_INDIRECT_BUFFER: bgfx_function_id = 146;
pub const BGFX_FUNCTION_ID_ENCODER_SET_IMAGE: bgfx_function_id = 147;
pub const BGFX_FUNCTION_ID_ENCODER_DISPATCH: bgfx_function_id = 148;
pub const BGFX_FUNCTION_ID_ENCODER_DISPATCH_INDIRECT: bgfx_function_id = 149;
pub const BGFX_FUNCTION_ID_ENCODER_DISCARD: bgfx_function_id = 150;
pub const BGFX_FUNCTION_ID_ENCODER_BLIT: bgfx_function_id = 151;
pub const BGFX_FUNCTION_ID_REQUEST_SCREEN_SHOT: bgfx_function_id = 152;
pub const BGFX_FUNCTION_ID_RENDER_FRAME: bgfx_function_id = 153;
pub const BGFX_FUNCTION_ID_SET_PLATFORM_DATA: bgfx_function_id = 154;
pub const BGFX_FUNCTION_ID_GET_INTERNAL_DATA: bgfx_function_id = 155;
pub const BGFX_FUNCTION_ID_OVERRIDE_INTERNAL_TEXTURE_PTR: bgfx_function_id = 156;
pub const BGFX_FUNCTION_ID_OVERRIDE_INTERNAL_TEXTURE: bgfx_function_id = 157;
pub const BGFX_FUNCTION_ID_SET_MARKER: bgfx_function_id = 158;
pub const BGFX_FUNCTION_ID_SET_STATE: bgfx_function_id = 159;
pub const BGFX_FUNCTION_ID_SET_CONDITION: bgfx_function_id = 160;
pub const BGFX_FUNCTION_ID_SET_STENCIL: bgfx_function_id = 161;
pub const BGFX_FUNCTION_ID_SET_SCISSOR: bgfx_function_id = 162;
pub const BGFX_FUNCTION_ID_SET_SCISSOR_CACHED: bgfx_function_id = 163;
pub const BGFX_FUNCTION_ID_SET_TRANSFORM: bgfx_function_id = 164;
pub const BGFX_FUNCTION_ID_SET_TRANSFORM_CACHED: bgfx_function_id = 165;
pub const BGFX_FUNCTION_ID_ALLOC_TRANSFORM: bgfx_function_id = 166;
pub const BGFX_FUNCTION_ID_SET_UNIFORM: bgfx_function_id = 167;
pub const BGFX_FUNCTION_ID_SET_INDEX_BUFFER: bgfx_function_id = 168;
pub const BGFX_FUNCTION_ID_SET_DYNAMIC_INDEX_BUFFER: bgfx_function_id = 169;
pub const BGFX_FUNCTION_ID_SET_TRANSIENT_INDEX_BUFFER: bgfx_function_id = 170;
pub const BGFX_FUNCTION_ID_SET_VERTEX_BUFFER: bgfx_function_id = 171;
pub const BGFX_FUNCTION_ID_SET_VERTEX_BUFFER_WITH_LAYOUT: bgfx_function_id = 172;
pub const BGFX_FUNCTION_ID_SET_DYNAMIC_VERTEX_BUFFER: bgfx_function_id = 173;
pub const BGFX_FUNCTION_ID_SET_DYNAMIC_VERTEX_BUFFER_WITH_LAYOUT: bgfx_function_id = 174;
pub const BGFX_FUNCTION_ID_SET_TRANSIENT_VERTEX_BUFFER: bgfx_function_id = 175;
pub const BGFX_FUNCTION_ID_SET_TRANSIENT_VERTEX_BUFFER_WITH_LAYOUT: bgfx_function_id = 176;
pub const BGFX_FUNCTION_ID_SET_VERTEX_COUNT: bgfx_function_id = 177;
pub const BGFX_FUNCTION_ID_SET_INSTANCE_DATA_BUFFER: bgfx_function_id = 178;
pub const BGFX_FUNCTION_ID_SET_INSTANCE_DATA_FROM_VERTEX_BUFFER: bgfx_function_id = 179;
pub const BGFX_FUNCTION_ID_SET_INSTANCE_DATA_FROM_DYNAMIC_VERTEX_BUFFER: bgfx_function_id = 180;
pub const BGFX_FUNCTION_ID_SET_INSTANCE_COUNT: bgfx_function_id = 181;
pub const BGFX_FUNCTION_ID_SET_TEXTURE: bgfx_function_id = 182;
pub const BGFX_FUNCTION_ID_TOUCH: bgfx_function_id = 183;
pub const BGFX_FUNCTION_ID_SUBMIT: bgfx_function_id = 184;
pub const BGFX_FUNCTION_ID_SUBMIT_OCCLUSION_QUERY: bgfx_function_id = 185;
pub const BGFX_FUNCTION_ID_SUBMIT_INDIRECT: bgfx_function_id = 186;
pub const BGFX_FUNCTION_ID_SUBMIT_INDIRECT_COUNT: bgfx_function_id = 187;
pub const BGFX_FUNCTION_ID_SET_COMPUTE_INDEX_BUFFER: bgfx_function_id = 188;
pub const BGFX_FUNCTION_ID_SET_COMPUTE_VERTEX_BUFFER: bgfx_function_id = 189;
pub const BGFX_FUNCTION_ID_SET_COMPUTE_DYNAMIC_INDEX_BUFFER: bgfx_function_id = 190;
pub const BGFX_FUNCTION_ID_SET_COMPUTE_DYNAMIC_VERTEX_BUFFER: bgfx_function_id = 191;
pub const BGFX_FUNCTION_ID_SET_COMPUTE_INDIRECT_BUFFER: bgfx_function_id = 192;
pub const BGFX_FUNCTION_ID_SET_IMAGE: bgfx_function_id = 193;
pub const BGFX_FUNCTION_ID_DISPATCH: bgfx_function_id = 194;
pub const BGFX_FUNCTION_ID_DISPATCH_INDIRECT: bgfx_function_id = 195;
pub const BGFX_FUNCTION_ID_DISCARD: bgfx_function_id = 196;
pub const BGFX_FUNCTION_ID_BLIT: bgfx_function_id = 197;
pub const BGFX_FUNCTION_ID_COUNT: bgfx_function_id = 198;
pub type bgfx_function_id = ::std::os::raw::c_uint;
pub use self::bgfx_function_id as bgfx_function_id_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bgfx_interface_vtbl {
	pub attachment_init: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_attachment_t,
			_handle: bgfx_texture_handle_t,
			_access: bgfx_access_t,
			_layer: u16,
			_numLayers: u16,
			_mip: u16,
			_resolve: u8,
		),
	>,
	pub vertex_layout_begin: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_vertex_layout_t,
			_rendererType: bgfx_renderer_type_t,
		) -> *mut bgfx_vertex_layout_t,
	>,
	pub vertex_layout_add: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_vertex_layout_t,
			_attrib: bgfx_attrib_t,
			_num: u8,
			_type: bgfx_attrib_type_t,
			_normalized: bool,
			_asInt: bool,
		) -> *mut bgfx_vertex_layout_t,
	>,
	pub vertex_layout_decode: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *const bgfx_vertex_layout_t,
			_attrib: bgfx_attrib_t,
			_num: *mut u8,
			_type: *mut bgfx_attrib_type_t,
			_normalized: *mut bool,
			_asInt: *mut bool,
		),
	>,
	pub vertex_layout_has: ::std::option::Option<
		unsafe extern "C" fn(_this: *const bgfx_vertex_layout_t, _attrib: bgfx_attrib_t) -> bool,
	>,
	pub vertex_layout_skip: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_vertex_layout_t,
			_num: u8,
		) -> *mut bgfx_vertex_layout_t,
	>,
	pub vertex_layout_end:
		::std::option::Option<unsafe extern "C" fn(_this: *mut bgfx_vertex_layout_t)>,
	pub vertex_layout_get_offset: ::std::option::Option<
		unsafe extern "C" fn(_this: *const bgfx_vertex_layout_t, _attrib: bgfx_attrib_t) -> u16,
	>,
	pub vertex_layout_get_stride:
		::std::option::Option<unsafe extern "C" fn(_this: *const bgfx_vertex_layout_t) -> u16>,
	pub vertex_layout_get_size: ::std::option::Option<
		unsafe extern "C" fn(_this: *const bgfx_vertex_layout_t, _num: u32) -> u32,
	>,
	pub vertex_pack: ::std::option::Option<
		unsafe extern "C" fn(
			_input: *const f32,
			_inputNormalized: bool,
			_attr: bgfx_attrib_t,
			_layout: *const bgfx_vertex_layout_t,
			_data: *mut ::std::os::raw::c_void,
			_index: u32,
		),
	>,
	pub vertex_unpack: ::std::option::Option<
		unsafe extern "C" fn(
			_output: *mut f32,
			_attr: bgfx_attrib_t,
			_layout: *const bgfx_vertex_layout_t,
			_data: *const ::std::os::raw::c_void,
			_index: u32,
		),
	>,
	pub vertex_convert: ::std::option::Option<
		unsafe extern "C" fn(
			_dstLayout: *const bgfx_vertex_layout_t,
			_dstData: *mut ::std::os::raw::c_void,
			_srcLayout: *const bgfx_vertex_layout_t,
			_srcData: *const ::std::os::raw::c_void,
			_num: u32,
		),
	>,
	pub weld_vertices: ::std::option::Option<
		unsafe extern "C" fn(
			_output: *mut ::std::os::raw::c_void,
			_layout: *const bgfx_vertex_layout_t,
			_data: *const ::std::os::raw::c_void,
			_num: u32,
			_index32: bool,
			_epsilon: f32,
		) -> u32,
	>,
	pub topology_convert: ::std::option::Option<
		unsafe extern "C" fn(
			_conversion: bgfx_topology_convert_t,
			_dst: *mut ::std::os::raw::c_void,
			_dstSize: u32,
			_indices: *const ::std::os::raw::c_void,
			_numIndices: u32,
			_index32: bool,
		) -> u32,
	>,
	pub topology_sort_tri_list: ::std::option::Option<
		unsafe extern "C" fn(
			_sort: bgfx_topology_sort_t,
			_dst: *mut ::std::os::raw::c_void,
			_dstSize: u32,
			_dir: *const f32,
			_pos: *const f32,
			_vertices: *const ::std::os::raw::c_void,
			_stride: u32,
			_indices: *const ::std::os::raw::c_void,
			_numIndices: u32,
			_index32: bool,
		),
	>,
	pub get_supported_renderers: ::std::option::Option<
		unsafe extern "C" fn(_max: u8, _enum: *mut bgfx_renderer_type_t) -> u8,
	>,
	pub get_renderer_name: ::std::option::Option<
		unsafe extern "C" fn(_type: bgfx_renderer_type_t) -> *const ::std::os::raw::c_char,
	>,
	pub init_ctor: ::std::option::Option<unsafe extern "C" fn(_init: *mut bgfx_init_t)>,
	pub init: ::std::option::Option<unsafe extern "C" fn(_init: *const bgfx_init_t) -> bool>,
	pub shutdown: ::std::option::Option<unsafe extern "C" fn()>,
	pub reset: ::std::option::Option<
		unsafe extern "C" fn(
			_width: u32,
			_height: u32,
			_flags: u32,
			_format: bgfx_texture_format_t,
		),
	>,
	pub frame: ::std::option::Option<unsafe extern "C" fn(_capture: bool) -> u32>,
	pub get_renderer_type: ::std::option::Option<unsafe extern "C" fn() -> bgfx_renderer_type_t>,
	pub get_caps: ::std::option::Option<unsafe extern "C" fn() -> *const bgfx_caps_t>,
	pub get_stats: ::std::option::Option<unsafe extern "C" fn() -> *const bgfx_stats_t>,
	pub alloc: ::std::option::Option<unsafe extern "C" fn(_size: u32) -> *const bgfx_memory_t>,
	pub copy: ::std::option::Option<
		unsafe extern "C" fn(
			_data: *const ::std::os::raw::c_void,
			_size: u32,
		) -> *const bgfx_memory_t,
	>,
	pub make_ref: ::std::option::Option<
		unsafe extern "C" fn(
			_data: *const ::std::os::raw::c_void,
			_size: u32,
		) -> *const bgfx_memory_t,
	>,
	pub make_ref_release: ::std::option::Option<
		unsafe extern "C" fn(
			_data: *const ::std::os::raw::c_void,
			_size: u32,
			_releaseFn: bgfx_release_fn_t,
			_userData: *mut ::std::os::raw::c_void,
		) -> *const bgfx_memory_t,
	>,
	pub set_debug: ::std::option::Option<unsafe extern "C" fn(_debug: u32)>,
	pub dbg_text_clear: ::std::option::Option<unsafe extern "C" fn(_attr: u8, _small: bool)>,
	pub dbg_text_printf: ::std::option::Option<
		unsafe extern "C" fn(
			_x: u16,
			_y: u16,
			_attr: u8,
			_format: *const ::std::os::raw::c_char,
			...
		),
	>,
	pub dbg_text_vprintf: ::std::option::Option<
		unsafe extern "C" fn(
			_x: u16,
			_y: u16,
			_attr: u8,
			_format: *const ::std::os::raw::c_char,
			_argList: va_list,
		),
	>,
	pub dbg_text_image: ::std::option::Option<
		unsafe extern "C" fn(
			_x: u16,
			_y: u16,
			_width: u16,
			_height: u16,
			_data: *const ::std::os::raw::c_void,
			_pitch: u16,
		),
	>,
	pub create_index_buffer: ::std::option::Option<
		unsafe extern "C" fn(_mem: *const bgfx_memory_t, _flags: u16) -> bgfx_index_buffer_handle_t,
	>,
	pub set_index_buffer_name: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_index_buffer_handle_t,
			_name: *const ::std::os::raw::c_char,
			_len: i32,
		),
	>,
	pub destroy_index_buffer:
		::std::option::Option<unsafe extern "C" fn(_handle: bgfx_index_buffer_handle_t)>,
	pub create_vertex_layout: ::std::option::Option<
		unsafe extern "C" fn(_layout: *const bgfx_vertex_layout_t) -> bgfx_vertex_layout_handle_t,
	>,
	pub destroy_vertex_layout:
		::std::option::Option<unsafe extern "C" fn(_layoutHandle: bgfx_vertex_layout_handle_t)>,
	pub create_vertex_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_mem: *const bgfx_memory_t,
			_layout: *const bgfx_vertex_layout_t,
			_flags: u16,
		) -> bgfx_vertex_buffer_handle_t,
	>,
	pub set_vertex_buffer_name: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_vertex_buffer_handle_t,
			_name: *const ::std::os::raw::c_char,
			_len: i32,
		),
	>,
	pub destroy_vertex_buffer:
		::std::option::Option<unsafe extern "C" fn(_handle: bgfx_vertex_buffer_handle_t)>,
	pub create_dynamic_index_buffer: ::std::option::Option<
		unsafe extern "C" fn(_num: u32, _flags: u16) -> bgfx_dynamic_index_buffer_handle_t,
	>,
	pub create_dynamic_index_buffer_mem: ::std::option::Option<
		unsafe extern "C" fn(
			_mem: *const bgfx_memory_t,
			_flags: u16,
		) -> bgfx_dynamic_index_buffer_handle_t,
	>,
	pub update_dynamic_index_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_dynamic_index_buffer_handle_t,
			_startIndex: u32,
			_mem: *const bgfx_memory_t,
		),
	>,
	pub destroy_dynamic_index_buffer:
		::std::option::Option<unsafe extern "C" fn(_handle: bgfx_dynamic_index_buffer_handle_t)>,
	pub create_dynamic_vertex_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_num: u32,
			_layout: *const bgfx_vertex_layout_t,
			_flags: u16,
		) -> bgfx_dynamic_vertex_buffer_handle_t,
	>,
	pub create_dynamic_vertex_buffer_mem: ::std::option::Option<
		unsafe extern "C" fn(
			_mem: *const bgfx_memory_t,
			_layout: *const bgfx_vertex_layout_t,
			_flags: u16,
		) -> bgfx_dynamic_vertex_buffer_handle_t,
	>,
	pub update_dynamic_vertex_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_dynamic_vertex_buffer_handle_t,
			_startVertex: u32,
			_mem: *const bgfx_memory_t,
		),
	>,
	pub destroy_dynamic_vertex_buffer:
		::std::option::Option<unsafe extern "C" fn(_handle: bgfx_dynamic_vertex_buffer_handle_t)>,
	pub get_avail_transient_index_buffer:
		::std::option::Option<unsafe extern "C" fn(_num: u32, _index32: bool) -> u32>,
	pub get_avail_transient_vertex_buffer: ::std::option::Option<
		unsafe extern "C" fn(_num: u32, _layout: *const bgfx_vertex_layout_t) -> u32,
	>,
	pub get_avail_instance_data_buffer:
		::std::option::Option<unsafe extern "C" fn(_num: u32, _stride: u16) -> u32>,
	pub alloc_transient_index_buffer: ::std::option::Option<
		unsafe extern "C" fn(_tib: *mut bgfx_transient_index_buffer_t, _num: u32, _index32: bool),
	>,
	pub alloc_transient_vertex_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_tvb: *mut bgfx_transient_vertex_buffer_t,
			_num: u32,
			_layout: *const bgfx_vertex_layout_t,
		),
	>,
	pub alloc_transient_buffers: ::std::option::Option<
		unsafe extern "C" fn(
			_tvb: *mut bgfx_transient_vertex_buffer_t,
			_layout: *const bgfx_vertex_layout_t,
			_numVertices: u32,
			_tib: *mut bgfx_transient_index_buffer_t,
			_numIndices: u32,
			_index32: bool,
		) -> bool,
	>,
	pub alloc_instance_data_buffer: ::std::option::Option<
		unsafe extern "C" fn(_idb: *mut bgfx_instance_data_buffer_t, _num: u32, _stride: u16),
	>,
	pub create_indirect_buffer:
		::std::option::Option<unsafe extern "C" fn(_num: u32) -> bgfx_indirect_buffer_handle_t>,
	pub destroy_indirect_buffer:
		::std::option::Option<unsafe extern "C" fn(_handle: bgfx_indirect_buffer_handle_t)>,
	pub create_shader: ::std::option::Option<
		unsafe extern "C" fn(_mem: *const bgfx_memory_t) -> bgfx_shader_handle_t,
	>,
	pub get_shader_uniforms: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_shader_handle_t,
			_uniforms: *mut bgfx_uniform_handle_t,
			_max: u16,
		) -> u16,
	>,
	pub set_shader_name: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_shader_handle_t,
			_name: *const ::std::os::raw::c_char,
			_len: i32,
		),
	>,
	pub destroy_shader: ::std::option::Option<unsafe extern "C" fn(_handle: bgfx_shader_handle_t)>,
	pub create_program: ::std::option::Option<
		unsafe extern "C" fn(
			_vsh: bgfx_shader_handle_t,
			_fsh: bgfx_shader_handle_t,
			_destroyShaders: bool,
		) -> bgfx_program_handle_t,
	>,
	pub create_compute_program: ::std::option::Option<
		unsafe extern "C" fn(
			_csh: bgfx_shader_handle_t,
			_destroyShaders: bool,
		) -> bgfx_program_handle_t,
	>,
	pub destroy_program:
		::std::option::Option<unsafe extern "C" fn(_handle: bgfx_program_handle_t)>,
	pub is_texture_valid: ::std::option::Option<
		unsafe extern "C" fn(
			_depth: u16,
			_cubeMap: bool,
			_numLayers: u16,
			_format: bgfx_texture_format_t,
			_flags: u64,
		) -> bool,
	>,
	pub is_frame_buffer_valid: ::std::option::Option<
		unsafe extern "C" fn(_num: u8, _attachment: *const bgfx_attachment_t) -> bool,
	>,
	pub calc_texture_size: ::std::option::Option<
		unsafe extern "C" fn(
			_info: *mut bgfx_texture_info_t,
			_width: u16,
			_height: u16,
			_depth: u16,
			_cubeMap: bool,
			_hasMips: bool,
			_numLayers: u16,
			_format: bgfx_texture_format_t,
		),
	>,
	pub create_texture: ::std::option::Option<
		unsafe extern "C" fn(
			_mem: *const bgfx_memory_t,
			_flags: u64,
			_skip: u8,
			_info: *mut bgfx_texture_info_t,
		) -> bgfx_texture_handle_t,
	>,
	pub create_texture_2d: ::std::option::Option<
		unsafe extern "C" fn(
			_width: u16,
			_height: u16,
			_hasMips: bool,
			_numLayers: u16,
			_format: bgfx_texture_format_t,
			_flags: u64,
			_mem: *const bgfx_memory_t,
		) -> bgfx_texture_handle_t,
	>,
	pub create_texture_2d_scaled: ::std::option::Option<
		unsafe extern "C" fn(
			_ratio: bgfx_backbuffer_ratio_t,
			_hasMips: bool,
			_numLayers: u16,
			_format: bgfx_texture_format_t,
			_flags: u64,
		) -> bgfx_texture_handle_t,
	>,
	pub create_texture_3d: ::std::option::Option<
		unsafe extern "C" fn(
			_width: u16,
			_height: u16,
			_depth: u16,
			_hasMips: bool,
			_format: bgfx_texture_format_t,
			_flags: u64,
			_mem: *const bgfx_memory_t,
		) -> bgfx_texture_handle_t,
	>,
	pub create_texture_cube: ::std::option::Option<
		unsafe extern "C" fn(
			_size: u16,
			_hasMips: bool,
			_numLayers: u16,
			_format: bgfx_texture_format_t,
			_flags: u64,
			_mem: *const bgfx_memory_t,
		) -> bgfx_texture_handle_t,
	>,
	pub update_texture_2d: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_texture_handle_t,
			_layer: u16,
			_mip: u8,
			_x: u16,
			_y: u16,
			_width: u16,
			_height: u16,
			_mem: *const bgfx_memory_t,
			_pitch: u16,
		),
	>,
	pub update_texture_3d: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_texture_handle_t,
			_mip: u8,
			_x: u16,
			_y: u16,
			_z: u16,
			_width: u16,
			_height: u16,
			_depth: u16,
			_mem: *const bgfx_memory_t,
		),
	>,
	pub update_texture_cube: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_texture_handle_t,
			_layer: u16,
			_side: u8,
			_mip: u8,
			_x: u16,
			_y: u16,
			_width: u16,
			_height: u16,
			_mem: *const bgfx_memory_t,
			_pitch: u16,
		),
	>,
	pub read_texture: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_texture_handle_t,
			_data: *mut ::std::os::raw::c_void,
			_mip: u8,
		) -> u32,
	>,
	pub set_texture_name: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_texture_handle_t,
			_name: *const ::std::os::raw::c_char,
			_len: i32,
		),
	>,
	pub get_direct_access_ptr: ::std::option::Option<
		unsafe extern "C" fn(_handle: bgfx_texture_handle_t) -> *mut ::std::os::raw::c_void,
	>,
	pub destroy_texture:
		::std::option::Option<unsafe extern "C" fn(_handle: bgfx_texture_handle_t)>,
	pub create_frame_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_width: u16,
			_height: u16,
			_format: bgfx_texture_format_t,
			_textureFlags: u64,
		) -> bgfx_frame_buffer_handle_t,
	>,
	pub create_frame_buffer_scaled: ::std::option::Option<
		unsafe extern "C" fn(
			_ratio: bgfx_backbuffer_ratio_t,
			_format: bgfx_texture_format_t,
			_textureFlags: u64,
		) -> bgfx_frame_buffer_handle_t,
	>,
	pub create_frame_buffer_from_handles: ::std::option::Option<
		unsafe extern "C" fn(
			_num: u8,
			_handles: *const bgfx_texture_handle_t,
			_destroyTexture: bool,
		) -> bgfx_frame_buffer_handle_t,
	>,
	pub create_frame_buffer_from_attachment: ::std::option::Option<
		unsafe extern "C" fn(
			_num: u8,
			_attachment: *const bgfx_attachment_t,
			_destroyTexture: bool,
		) -> bgfx_frame_buffer_handle_t,
	>,
	pub create_frame_buffer_from_nwh: ::std::option::Option<
		unsafe extern "C" fn(
			_nwh: *mut ::std::os::raw::c_void,
			_width: u16,
			_height: u16,
			_format: bgfx_texture_format_t,
			_depthFormat: bgfx_texture_format_t,
		) -> bgfx_frame_buffer_handle_t,
	>,
	pub set_frame_buffer_name: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_frame_buffer_handle_t,
			_name: *const ::std::os::raw::c_char,
			_len: i32,
		),
	>,
	pub get_texture: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_frame_buffer_handle_t,
			_attachment: u8,
		) -> bgfx_texture_handle_t,
	>,
	pub destroy_frame_buffer:
		::std::option::Option<unsafe extern "C" fn(_handle: bgfx_frame_buffer_handle_t)>,
	pub create_uniform: ::std::option::Option<
		unsafe extern "C" fn(
			_name: *const ::std::os::raw::c_char,
			_type: bgfx_uniform_type_t,
			_num: u16,
		) -> bgfx_uniform_handle_t,
	>,
	pub get_uniform_info: ::std::option::Option<
		unsafe extern "C" fn(_handle: bgfx_uniform_handle_t, _info: *mut bgfx_uniform_info_t),
	>,
	pub destroy_uniform:
		::std::option::Option<unsafe extern "C" fn(_handle: bgfx_uniform_handle_t)>,
	pub create_occlusion_query:
		::std::option::Option<unsafe extern "C" fn() -> bgfx_occlusion_query_handle_t>,
	pub get_result: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_occlusion_query_handle_t,
			_result: *mut i32,
		) -> bgfx_occlusion_query_result_t,
	>,
	pub destroy_occlusion_query:
		::std::option::Option<unsafe extern "C" fn(_handle: bgfx_occlusion_query_handle_t)>,
	pub set_palette_color:
		::std::option::Option<unsafe extern "C" fn(_index: u8, _rgba: *const f32)>,
	pub set_palette_color_rgba32f:
		::std::option::Option<unsafe extern "C" fn(_index: u8, _r: f32, _g: f32, _b: f32, _a: f32)>,
	pub set_palette_color_rgba8:
		::std::option::Option<unsafe extern "C" fn(_index: u8, _rgba: u32)>,
	pub set_view_name: ::std::option::Option<
		unsafe extern "C" fn(_id: bgfx_view_id_t, _name: *const ::std::os::raw::c_char, _len: i32),
	>,
	pub set_view_rect: ::std::option::Option<
		unsafe extern "C" fn(_id: bgfx_view_id_t, _x: u16, _y: u16, _width: u16, _height: u16),
	>,
	pub set_view_rect_ratio: ::std::option::Option<
		unsafe extern "C" fn(
			_id: bgfx_view_id_t,
			_x: u16,
			_y: u16,
			_ratio: bgfx_backbuffer_ratio_t,
		),
	>,
	pub set_view_scissor: ::std::option::Option<
		unsafe extern "C" fn(_id: bgfx_view_id_t, _x: u16, _y: u16, _width: u16, _height: u16),
	>,
	pub set_view_clear: ::std::option::Option<
		unsafe extern "C" fn(
			_id: bgfx_view_id_t,
			_flags: u16,
			_rgba: u32,
			_depth: f32,
			_stencil: u8,
		),
	>,
	pub set_view_clear_mrt: ::std::option::Option<
		unsafe extern "C" fn(
			_id: bgfx_view_id_t,
			_flags: u16,
			_depth: f32,
			_stencil: u8,
			_c0: u8,
			_c1: u8,
			_c2: u8,
			_c3: u8,
			_c4: u8,
			_c5: u8,
			_c6: u8,
			_c7: u8,
		),
	>,
	pub set_view_mode:
		::std::option::Option<unsafe extern "C" fn(_id: bgfx_view_id_t, _mode: bgfx_view_mode_t)>,
	pub set_view_frame_buffer: ::std::option::Option<
		unsafe extern "C" fn(_id: bgfx_view_id_t, _handle: bgfx_frame_buffer_handle_t),
	>,
	pub set_view_transform: ::std::option::Option<
		unsafe extern "C" fn(
			_id: bgfx_view_id_t,
			_view: *const ::std::os::raw::c_void,
			_proj: *const ::std::os::raw::c_void,
		),
	>,
	pub set_view_order: ::std::option::Option<
		unsafe extern "C" fn(_id: bgfx_view_id_t, _num: u16, _order: *const bgfx_view_id_t),
	>,
	pub reset_view: ::std::option::Option<unsafe extern "C" fn(_id: bgfx_view_id_t)>,
	pub encoder_begin:
		::std::option::Option<unsafe extern "C" fn(_forThread: bool) -> *mut bgfx_encoder_t>,
	pub encoder_end: ::std::option::Option<unsafe extern "C" fn(_encoder: *mut bgfx_encoder_t)>,
	pub encoder_set_marker: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_name: *const ::std::os::raw::c_char,
			_len: i32,
		),
	>,
	pub encoder_set_state: ::std::option::Option<
		unsafe extern "C" fn(_this: *mut bgfx_encoder_t, _state: u64, _rgba: u32),
	>,
	pub encoder_set_condition: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_handle: bgfx_occlusion_query_handle_t,
			_visible: bool,
		),
	>,
	pub encoder_set_stencil: ::std::option::Option<
		unsafe extern "C" fn(_this: *mut bgfx_encoder_t, _fstencil: u32, _bstencil: u32),
	>,
	pub encoder_set_scissor: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_x: u16,
			_y: u16,
			_width: u16,
			_height: u16,
		) -> u16,
	>,
	pub encoder_set_scissor_cached:
		::std::option::Option<unsafe extern "C" fn(_this: *mut bgfx_encoder_t, _cache: u16)>,
	pub encoder_set_transform: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_mtx: *const ::std::os::raw::c_void,
			_num: u16,
		) -> u32,
	>,
	pub encoder_set_transform_cached: ::std::option::Option<
		unsafe extern "C" fn(_this: *mut bgfx_encoder_t, _cache: u32, _num: u16),
	>,
	pub encoder_alloc_transform: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_transform: *mut bgfx_transform_t,
			_num: u16,
		) -> u32,
	>,
	pub encoder_set_uniform: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_handle: bgfx_uniform_handle_t,
			_value: *const ::std::os::raw::c_void,
			_num: u16,
		),
	>,
	pub encoder_set_index_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_handle: bgfx_index_buffer_handle_t,
			_firstIndex: u32,
			_numIndices: u32,
		),
	>,
	pub encoder_set_dynamic_index_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_handle: bgfx_dynamic_index_buffer_handle_t,
			_firstIndex: u32,
			_numIndices: u32,
		),
	>,
	pub encoder_set_transient_index_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_tib: *const bgfx_transient_index_buffer_t,
			_firstIndex: u32,
			_numIndices: u32,
		),
	>,
	pub encoder_set_vertex_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_stream: u8,
			_handle: bgfx_vertex_buffer_handle_t,
			_startVertex: u32,
			_numVertices: u32,
		),
	>,
	pub encoder_set_vertex_buffer_with_layout: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_stream: u8,
			_handle: bgfx_vertex_buffer_handle_t,
			_startVertex: u32,
			_numVertices: u32,
			_layoutHandle: bgfx_vertex_layout_handle_t,
		),
	>,
	pub encoder_set_dynamic_vertex_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_stream: u8,
			_handle: bgfx_dynamic_vertex_buffer_handle_t,
			_startVertex: u32,
			_numVertices: u32,
		),
	>,
	pub encoder_set_dynamic_vertex_buffer_with_layout: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_stream: u8,
			_handle: bgfx_dynamic_vertex_buffer_handle_t,
			_startVertex: u32,
			_numVertices: u32,
			_layoutHandle: bgfx_vertex_layout_handle_t,
		),
	>,
	pub encoder_set_transient_vertex_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_stream: u8,
			_tvb: *const bgfx_transient_vertex_buffer_t,
			_startVertex: u32,
			_numVertices: u32,
		),
	>,
	pub encoder_set_transient_vertex_buffer_with_layout: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_stream: u8,
			_tvb: *const bgfx_transient_vertex_buffer_t,
			_startVertex: u32,
			_numVertices: u32,
			_layoutHandle: bgfx_vertex_layout_handle_t,
		),
	>,
	pub encoder_set_vertex_count:
		::std::option::Option<unsafe extern "C" fn(_this: *mut bgfx_encoder_t, _numVertices: u32)>,
	pub encoder_set_instance_data_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_idb: *const bgfx_instance_data_buffer_t,
			_start: u32,
			_num: u32,
		),
	>,
	pub encoder_set_instance_data_from_vertex_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_handle: bgfx_vertex_buffer_handle_t,
			_startVertex: u32,
			_num: u32,
		),
	>,
	pub encoder_set_instance_data_from_dynamic_vertex_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_handle: bgfx_dynamic_vertex_buffer_handle_t,
			_startVertex: u32,
			_num: u32,
		),
	>,
	pub encoder_set_instance_count:
		::std::option::Option<unsafe extern "C" fn(_this: *mut bgfx_encoder_t, _numInstances: u32)>,
	pub encoder_set_texture: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_stage: u8,
			_sampler: bgfx_uniform_handle_t,
			_handle: bgfx_texture_handle_t,
			_flags: u32,
		),
	>,
	pub encoder_touch: ::std::option::Option<
		unsafe extern "C" fn(_this: *mut bgfx_encoder_t, _id: bgfx_view_id_t),
	>,
	pub encoder_submit: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_id: bgfx_view_id_t,
			_program: bgfx_program_handle_t,
			_depth: u32,
			_flags: u8,
		),
	>,
	pub encoder_submit_occlusion_query: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_id: bgfx_view_id_t,
			_program: bgfx_program_handle_t,
			_occlusionQuery: bgfx_occlusion_query_handle_t,
			_depth: u32,
			_flags: u8,
		),
	>,
	pub encoder_submit_indirect: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_id: bgfx_view_id_t,
			_program: bgfx_program_handle_t,
			_indirectHandle: bgfx_indirect_buffer_handle_t,
			_start: u32,
			_num: u32,
			_depth: u32,
			_flags: u8,
		),
	>,
	pub encoder_submit_indirect_count: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_id: bgfx_view_id_t,
			_program: bgfx_program_handle_t,
			_indirectHandle: bgfx_indirect_buffer_handle_t,
			_start: u32,
			_numHandle: bgfx_index_buffer_handle_t,
			_numIndex: u32,
			_numMax: u32,
			_depth: u32,
			_flags: u8,
		),
	>,
	pub encoder_set_compute_index_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_stage: u8,
			_handle: bgfx_index_buffer_handle_t,
			_access: bgfx_access_t,
		),
	>,
	pub encoder_set_compute_vertex_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_stage: u8,
			_handle: bgfx_vertex_buffer_handle_t,
			_access: bgfx_access_t,
		),
	>,
	pub encoder_set_compute_dynamic_index_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_stage: u8,
			_handle: bgfx_dynamic_index_buffer_handle_t,
			_access: bgfx_access_t,
		),
	>,
	pub encoder_set_compute_dynamic_vertex_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_stage: u8,
			_handle: bgfx_dynamic_vertex_buffer_handle_t,
			_access: bgfx_access_t,
		),
	>,
	pub encoder_set_compute_indirect_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_stage: u8,
			_handle: bgfx_indirect_buffer_handle_t,
			_access: bgfx_access_t,
		),
	>,
	pub encoder_set_image: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_stage: u8,
			_handle: bgfx_texture_handle_t,
			_mip: u8,
			_access: bgfx_access_t,
			_format: bgfx_texture_format_t,
		),
	>,
	pub encoder_dispatch: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_id: bgfx_view_id_t,
			_program: bgfx_program_handle_t,
			_numX: u32,
			_numY: u32,
			_numZ: u32,
			_flags: u8,
		),
	>,
	pub encoder_dispatch_indirect: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_id: bgfx_view_id_t,
			_program: bgfx_program_handle_t,
			_indirectHandle: bgfx_indirect_buffer_handle_t,
			_start: u32,
			_num: u32,
			_flags: u8,
		),
	>,
	pub encoder_discard:
		::std::option::Option<unsafe extern "C" fn(_this: *mut bgfx_encoder_t, _flags: u8)>,
	pub encoder_blit: ::std::option::Option<
		unsafe extern "C" fn(
			_this: *mut bgfx_encoder_t,
			_id: bgfx_view_id_t,
			_dst: bgfx_texture_handle_t,
			_dstMip: u8,
			_dstX: u16,
			_dstY: u16,
			_dstZ: u16,
			_src: bgfx_texture_handle_t,
			_srcMip: u8,
			_srcX: u16,
			_srcY: u16,
			_srcZ: u16,
			_width: u16,
			_height: u16,
			_depth: u16,
		),
	>,
	pub request_screen_shot: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_frame_buffer_handle_t,
			_filePath: *const ::std::os::raw::c_char,
		),
	>,
	pub render_frame:
		::std::option::Option<unsafe extern "C" fn(_msecs: i32) -> bgfx_render_frame_t>,
	pub set_platform_data:
		::std::option::Option<unsafe extern "C" fn(_data: *const bgfx_platform_data_t)>,
	pub get_internal_data:
		::std::option::Option<unsafe extern "C" fn() -> *const bgfx_internal_data_t>,
	pub override_internal_texture_ptr: ::std::option::Option<
		unsafe extern "C" fn(_handle: bgfx_texture_handle_t, _ptr: usize) -> usize,
	>,
	pub override_internal_texture: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_texture_handle_t,
			_width: u16,
			_height: u16,
			_numMips: u8,
			_format: bgfx_texture_format_t,
			_flags: u64,
		) -> usize,
	>,
	pub set_marker: ::std::option::Option<
		unsafe extern "C" fn(_name: *const ::std::os::raw::c_char, _len: i32),
	>,
	pub set_state: ::std::option::Option<unsafe extern "C" fn(_state: u64, _rgba: u32)>,
	pub set_condition: ::std::option::Option<
		unsafe extern "C" fn(_handle: bgfx_occlusion_query_handle_t, _visible: bool),
	>,
	pub set_stencil: ::std::option::Option<unsafe extern "C" fn(_fstencil: u32, _bstencil: u32)>,
	pub set_scissor: ::std::option::Option<
		unsafe extern "C" fn(_x: u16, _y: u16, _width: u16, _height: u16) -> u16,
	>,
	pub set_scissor_cached: ::std::option::Option<unsafe extern "C" fn(_cache: u16)>,
	pub set_transform: ::std::option::Option<
		unsafe extern "C" fn(_mtx: *const ::std::os::raw::c_void, _num: u16) -> u32,
	>,
	pub set_transform_cached: ::std::option::Option<unsafe extern "C" fn(_cache: u32, _num: u16)>,
	pub alloc_transform: ::std::option::Option<
		unsafe extern "C" fn(_transform: *mut bgfx_transform_t, _num: u16) -> u32,
	>,
	pub set_uniform: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_uniform_handle_t,
			_value: *const ::std::os::raw::c_void,
			_num: u16,
		),
	>,
	pub set_index_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_index_buffer_handle_t,
			_firstIndex: u32,
			_numIndices: u32,
		),
	>,
	pub set_dynamic_index_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_dynamic_index_buffer_handle_t,
			_firstIndex: u32,
			_numIndices: u32,
		),
	>,
	pub set_transient_index_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_tib: *const bgfx_transient_index_buffer_t,
			_firstIndex: u32,
			_numIndices: u32,
		),
	>,
	pub set_vertex_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_stream: u8,
			_handle: bgfx_vertex_buffer_handle_t,
			_startVertex: u32,
			_numVertices: u32,
		),
	>,
	pub set_vertex_buffer_with_layout: ::std::option::Option<
		unsafe extern "C" fn(
			_stream: u8,
			_handle: bgfx_vertex_buffer_handle_t,
			_startVertex: u32,
			_numVertices: u32,
			_layoutHandle: bgfx_vertex_layout_handle_t,
		),
	>,
	pub set_dynamic_vertex_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_stream: u8,
			_handle: bgfx_dynamic_vertex_buffer_handle_t,
			_startVertex: u32,
			_numVertices: u32,
		),
	>,
	pub set_dynamic_vertex_buffer_with_layout: ::std::option::Option<
		unsafe extern "C" fn(
			_stream: u8,
			_handle: bgfx_dynamic_vertex_buffer_handle_t,
			_startVertex: u32,
			_numVertices: u32,
			_layoutHandle: bgfx_vertex_layout_handle_t,
		),
	>,
	pub set_transient_vertex_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_stream: u8,
			_tvb: *const bgfx_transient_vertex_buffer_t,
			_startVertex: u32,
			_numVertices: u32,
		),
	>,
	pub set_transient_vertex_buffer_with_layout: ::std::option::Option<
		unsafe extern "C" fn(
			_stream: u8,
			_tvb: *const bgfx_transient_vertex_buffer_t,
			_startVertex: u32,
			_numVertices: u32,
			_layoutHandle: bgfx_vertex_layout_handle_t,
		),
	>,
	pub set_vertex_count: ::std::option::Option<unsafe extern "C" fn(_numVertices: u32)>,
	pub set_instance_data_buffer: ::std::option::Option<
		unsafe extern "C" fn(_idb: *const bgfx_instance_data_buffer_t, _start: u32, _num: u32),
	>,
	pub set_instance_data_from_vertex_buffer: ::std::option::Option<
		unsafe extern "C" fn(_handle: bgfx_vertex_buffer_handle_t, _startVertex: u32, _num: u32),
	>,
	pub set_instance_data_from_dynamic_vertex_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_handle: bgfx_dynamic_vertex_buffer_handle_t,
			_startVertex: u32,
			_num: u32,
		),
	>,
	pub set_instance_count: ::std::option::Option<unsafe extern "C" fn(_numInstances: u32)>,
	pub set_texture: ::std::option::Option<
		unsafe extern "C" fn(
			_stage: u8,
			_sampler: bgfx_uniform_handle_t,
			_handle: bgfx_texture_handle_t,
			_flags: u32,
		),
	>,
	pub touch: ::std::option::Option<unsafe extern "C" fn(_id: bgfx_view_id_t)>,
	pub submit: ::std::option::Option<
		unsafe extern "C" fn(
			_id: bgfx_view_id_t,
			_program: bgfx_program_handle_t,
			_depth: u32,
			_flags: u8,
		),
	>,
	pub submit_occlusion_query: ::std::option::Option<
		unsafe extern "C" fn(
			_id: bgfx_view_id_t,
			_program: bgfx_program_handle_t,
			_occlusionQuery: bgfx_occlusion_query_handle_t,
			_depth: u32,
			_flags: u8,
		),
	>,
	pub submit_indirect: ::std::option::Option<
		unsafe extern "C" fn(
			_id: bgfx_view_id_t,
			_program: bgfx_program_handle_t,
			_indirectHandle: bgfx_indirect_buffer_handle_t,
			_start: u32,
			_num: u32,
			_depth: u32,
			_flags: u8,
		),
	>,
	pub submit_indirect_count: ::std::option::Option<
		unsafe extern "C" fn(
			_id: bgfx_view_id_t,
			_program: bgfx_program_handle_t,
			_indirectHandle: bgfx_indirect_buffer_handle_t,
			_start: u32,
			_numHandle: bgfx_index_buffer_handle_t,
			_numIndex: u32,
			_numMax: u32,
			_depth: u32,
			_flags: u8,
		),
	>,
	pub set_compute_index_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_stage: u8,
			_handle: bgfx_index_buffer_handle_t,
			_access: bgfx_access_t,
		),
	>,
	pub set_compute_vertex_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_stage: u8,
			_handle: bgfx_vertex_buffer_handle_t,
			_access: bgfx_access_t,
		),
	>,
	pub set_compute_dynamic_index_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_stage: u8,
			_handle: bgfx_dynamic_index_buffer_handle_t,
			_access: bgfx_access_t,
		),
	>,
	pub set_compute_dynamic_vertex_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_stage: u8,
			_handle: bgfx_dynamic_vertex_buffer_handle_t,
			_access: bgfx_access_t,
		),
	>,
	pub set_compute_indirect_buffer: ::std::option::Option<
		unsafe extern "C" fn(
			_stage: u8,
			_handle: bgfx_indirect_buffer_handle_t,
			_access: bgfx_access_t,
		),
	>,
	pub set_image: ::std::option::Option<
		unsafe extern "C" fn(
			_stage: u8,
			_handle: bgfx_texture_handle_t,
			_mip: u8,
			_access: bgfx_access_t,
			_format: bgfx_texture_format_t,
		),
	>,
	pub dispatch: ::std::option::Option<
		unsafe extern "C" fn(
			_id: bgfx_view_id_t,
			_program: bgfx_program_handle_t,
			_numX: u32,
			_numY: u32,
			_numZ: u32,
			_flags: u8,
		),
	>,
	pub dispatch_indirect: ::std::option::Option<
		unsafe extern "C" fn(
			_id: bgfx_view_id_t,
			_program: bgfx_program_handle_t,
			_indirectHandle: bgfx_indirect_buffer_handle_t,
			_start: u32,
			_num: u32,
			_flags: u8,
		),
	>,
	pub discard: ::std::option::Option<unsafe extern "C" fn(_flags: u8)>,
	pub blit: ::std::option::Option<
		unsafe extern "C" fn(
			_id: bgfx_view_id_t,
			_dst: bgfx_texture_handle_t,
			_dstMip: u8,
			_dstX: u16,
			_dstY: u16,
			_dstZ: u16,
			_src: bgfx_texture_handle_t,
			_srcMip: u8,
			_srcX: u16,
			_srcY: u16,
			_srcZ: u16,
			_width: u16,
			_height: u16,
			_depth: u16,
		),
	>,
}
pub type PFN_BGFX_GET_INTERFACE =
	::std::option::Option<unsafe extern "C" fn(_version: u32) -> *mut bgfx_interface_vtbl_t>;
extern "C" {
	pub fn bgfx_get_interface(_version: u32) -> *mut bgfx_interface_vtbl_t;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
pub type __uint128_t = u128;
