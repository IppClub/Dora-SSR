/* Copyright (c) 2024 Li Jin, dragon-fly@qq.com

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */

#wa:import dora node_type
func node_type() => i32
#wa:import dora node_set_order
func node_set_order(slf: i64, val: i32);
#wa:import dora node_get_order
func node_get_order(slf: i64) => i32
#wa:import dora node_set_angle
func node_set_angle(slf: i64, val: f32);
#wa:import dora node_get_angle
func node_get_angle(slf: i64) => f32
#wa:import dora node_set_angle_x
func node_set_angle_x(slf: i64, val: f32);
#wa:import dora node_get_angle_x
func node_get_angle_x(slf: i64) => f32
#wa:import dora node_set_angle_y
func node_set_angle_y(slf: i64, val: f32);
#wa:import dora node_get_angle_y
func node_get_angle_y(slf: i64) => f32
#wa:import dora node_set_scale_x
func node_set_scale_x(slf: i64, val: f32);
#wa:import dora node_get_scale_x
func node_get_scale_x(slf: i64) => f32
#wa:import dora node_set_scale_y
func node_set_scale_y(slf: i64, val: f32);
#wa:import dora node_get_scale_y
func node_get_scale_y(slf: i64) => f32
#wa:import dora node_set_x
func node_set_x(slf: i64, val: f32);
#wa:import dora node_get_x
func node_get_x(slf: i64) => f32
#wa:import dora node_set_y
func node_set_y(slf: i64, val: f32);
#wa:import dora node_get_y
func node_get_y(slf: i64) => f32
#wa:import dora node_set_z
func node_set_z(slf: i64, val: f32);
#wa:import dora node_get_z
func node_get_z(slf: i64) => f32
#wa:import dora node_set_position
func node_set_position(slf: i64, val: i64);
#wa:import dora node_get_position
func node_get_position(slf: i64) => i64
#wa:import dora node_set_skew_x
func node_set_skew_x(slf: i64, val: f32);
#wa:import dora node_get_skew_x
func node_get_skew_x(slf: i64) => f32
#wa:import dora node_set_skew_y
func node_set_skew_y(slf: i64, val: f32);
#wa:import dora node_get_skew_y
func node_get_skew_y(slf: i64) => f32
#wa:import dora node_set_visible
func node_set_visible(slf: i64, val: i32);
#wa:import dora node_is_visible
func node_is_visible(slf: i64) => i32
#wa:import dora node_set_anchor
func node_set_anchor(slf: i64, val: i64);
#wa:import dora node_get_anchor
func node_get_anchor(slf: i64) => i64
#wa:import dora node_set_width
func node_set_width(slf: i64, val: f32);
#wa:import dora node_get_width
func node_get_width(slf: i64) => f32
#wa:import dora node_set_height
func node_set_height(slf: i64, val: f32);
#wa:import dora node_get_height
func node_get_height(slf: i64) => f32
#wa:import dora node_set_size
func node_set_size(slf: i64, val: i64);
#wa:import dora node_get_size
func node_get_size(slf: i64) => i64
#wa:import dora node_set_tag
func node_set_tag(slf: i64, val: i64);
#wa:import dora node_get_tag
func node_get_tag(slf: i64) => i64
#wa:import dora node_set_opacity
func node_set_opacity(slf: i64, val: f32);
#wa:import dora node_get_opacity
func node_get_opacity(slf: i64) => f32
#wa:import dora node_set_color
func node_set_color(slf: i64, val: i32);
#wa:import dora node_get_color
func node_get_color(slf: i64) => i32
#wa:import dora node_set_color3
func node_set_color3(slf: i64, val: i32);
#wa:import dora node_get_color3
func node_get_color3(slf: i64) => i32
#wa:import dora node_set_pass_opacity
func node_set_pass_opacity(slf: i64, val: i32);
#wa:import dora node_is_pass_opacity
func node_is_pass_opacity(slf: i64) => i32
#wa:import dora node_set_pass_color3
func node_set_pass_color3(slf: i64, val: i32);
#wa:import dora node_is_pass_color3
func node_is_pass_color3(slf: i64) => i32
#wa:import dora node_set_transform_target
func node_set_transform_target(slf: i64, val: i64);
#wa:import dora node_get_transform_target
func node_get_transform_target(slf: i64) => i64
#wa:import dora node_set_scheduler
func node_set_scheduler(slf: i64, val: i64);
#wa:import dora node_get_scheduler
func node_get_scheduler(slf: i64) => i64
#wa:import dora node_get_children
func node_get_children(slf: i64) => i64
#wa:import dora node_get_parent
func node_get_parent(slf: i64) => i64
#wa:import dora node_is_running
func node_is_running(slf: i64) => i32
#wa:import dora node_is_scheduled
func node_is_scheduled(slf: i64) => i32
#wa:import dora node_get_action_count
func node_get_action_count(slf: i64) => i32
#wa:import dora node_get_data
func node_get_data(slf: i64) => i64
#wa:import dora node_set_touch_enabled
func node_set_touch_enabled(slf: i64, val: i32);
#wa:import dora node_is_touch_enabled
func node_is_touch_enabled(slf: i64) => i32
#wa:import dora node_set_swallow_touches
func node_set_swallow_touches(slf: i64, val: i32);
#wa:import dora node_is_swallow_touches
func node_is_swallow_touches(slf: i64) => i32
#wa:import dora node_set_swallow_mouse_wheel
func node_set_swallow_mouse_wheel(slf: i64, val: i32);
#wa:import dora node_is_swallow_mouse_wheel
func node_is_swallow_mouse_wheel(slf: i64) => i32
#wa:import dora node_set_keyboard_enabled
func node_set_keyboard_enabled(slf: i64, val: i32);
#wa:import dora node_is_keyboard_enabled
func node_is_keyboard_enabled(slf: i64) => i32
#wa:import dora node_set_controller_enabled
func node_set_controller_enabled(slf: i64, val: i32);
#wa:import dora node_is_controller_enabled
func node_is_controller_enabled(slf: i64) => i32
#wa:import dora node_set_render_group
func node_set_render_group(slf: i64, val: i32);
#wa:import dora node_is_render_group
func node_is_render_group(slf: i64) => i32
#wa:import dora node_set_show_debug
func node_set_show_debug(slf: i64, val: i32);
#wa:import dora node_is_show_debug
func node_is_show_debug(slf: i64) => i32
#wa:import dora node_set_render_order
func node_set_render_order(slf: i64, val: i32);
#wa:import dora node_get_render_order
func node_get_render_order(slf: i64) => i32
#wa:import dora node_add_child_with_order_tag
func node_add_child_with_order_tag(slf: i64, child: i64, order: i32, tag: i64)
#wa:import dora node_add_child_with_order
func node_add_child_with_order(slf: i64, child: i64, order: i32)
#wa:import dora node_add_child
func node_add_child(slf: i64, child: i64)
#wa:import dora node_add_to_with_order_tag
func node_add_to_with_order_tag(slf: i64, parent: i64, order: i32, tag: i64) => i64
#wa:import dora node_add_to_with_order
func node_add_to_with_order(slf: i64, parent: i64, order: i32) => i64
#wa:import dora node_add_to
func node_add_to(slf: i64, parent: i64) => i64
#wa:import dora node_remove_child
func node_remove_child(slf: i64, child: i64, cleanup: i32)
#wa:import dora node_remove_child_by_tag
func node_remove_child_by_tag(slf: i64, tag: i64, cleanup: i32)
#wa:import dora node_remove_all_children
func node_remove_all_children(slf: i64, cleanup: i32)
#wa:import dora node_remove_from_parent
func node_remove_from_parent(slf: i64, cleanup: i32)
#wa:import dora node_move_to_parent
func node_move_to_parent(slf: i64, parent: i64)
#wa:import dora node_cleanup
func node_cleanup(slf: i64)
#wa:import dora node_get_child_by_tag
func node_get_child_by_tag(slf: i64, tag: i64) => i64
#wa:import dora node_schedule
func node_schedule(slf: i64, func0: i32, stack0: i64)
#wa:import dora node_unschedule
func node_unschedule(slf: i64)
#wa:import dora node_convert_to_node_space
func node_convert_to_node_space(slf: i64, world_point: i64) => i64
#wa:import dora node_convert_to_world_space
func node_convert_to_world_space(slf: i64, node_point: i64) => i64
#wa:import dora node_convert_to_window_space
func node_convert_to_window_space(slf: i64, node_point: i64, func0: i32, stack0: i64)
#wa:import dora node_each_child
func node_each_child(slf: i64, func0: i32, stack0: i64) => i32
#wa:import dora node_traverse
func node_traverse(slf: i64, func0: i32, stack0: i64) => i32
#wa:import dora node_traverse_all
func node_traverse_all(slf: i64, func0: i32, stack0: i64) => i32
#wa:import dora node_run_action_def
func node_run_action_def(slf: i64, def: i64, looped: i32) => f32
#wa:import dora node_run_action
func node_run_action(slf: i64, action: i64, looped: i32) => f32
#wa:import dora node_stop_all_actions
func node_stop_all_actions(slf: i64)
#wa:import dora node_perform_def
func node_perform_def(slf: i64, action_def: i64, looped: i32) => f32
#wa:import dora node_perform
func node_perform(slf: i64, action: i64, looped: i32) => f32
#wa:import dora node_stop_action
func node_stop_action(slf: i64, action: i64)
#wa:import dora node_align_items_vertically
func node_align_items_vertically(slf: i64, padding: f32) => i64
#wa:import dora node_align_items_vertically_with_size
func node_align_items_vertically_with_size(slf: i64, size: i64, padding: f32) => i64
#wa:import dora node_align_items_horizontally
func node_align_items_horizontally(slf: i64, padding: f32) => i64
#wa:import dora node_align_items_horizontally_with_size
func node_align_items_horizontally_with_size(slf: i64, size: i64, padding: f32) => i64
#wa:import dora node_align_items
func node_align_items(slf: i64, padding: f32) => i64
#wa:import dora node_align_items_with_size
func node_align_items_with_size(slf: i64, size: i64, padding: f32) => i64
#wa:import dora node_move_and_cull_items
func node_move_and_cull_items(slf: i64, delta: i64)
#wa:import dora node_attach_ime
func node_attach_ime(slf: i64)
#wa:import dora node_detach_ime
func node_detach_ime(slf: i64)
#wa:import dora node_grab
func node_grab(slf: i64) => i64
#wa:import dora node_grab_with_size
func node_grab_with_size(slf: i64, grid_x: i32, grid_y: i32) => i64
#wa:import dora node_stop_grab
func node_stop_grab(slf: i64)
#wa:import dora node_set_transform_target_null
func node_set_transform_target_null(slf: i64)
#wa:import dora node_slot
func node_slot(slf: i64, event_name: i64, func0: i32, stack0: i64)
#wa:import dora node_gslot
func node_gslot(slf: i64, event_name: i64, func0: i32, stack0: i64)
#wa:import dora node_emit
func node_emit(slf: i64, name: i64, stack: i64)
#wa:import dora node_on_update
func node_on_update(slf: i64, func0: i32, stack0: i64)
#wa:import dora node_new
func node_new() => i64
type Node struct { Object }
func NodeFrom(raw: i64) => *Node {
	if raw == 0 {
		return nil
	}
	object := Node{}
	object.raw = &raw
	setFinalizer(object.raw, ObjectFinalizer)
	result := &object
	return result
}
func Node.GetTypeId() => i32 {
	return node_type()
}
func Node.SetOrder(val: i32) {
	node_set_order(*this.raw, val)
}
func Node.GetOrder() => i32 {
	return node_get_order(*this.raw)
}
func Node.SetAngle(val: f32) {
	node_set_angle(*this.raw, val)
}
func Node.GetAngle() => f32 {
	return node_get_angle(*this.raw)
}
func Node.SetAngleX(val: f32) {
	node_set_angle_x(*this.raw, val)
}
func Node.GetAngleX() => f32 {
	return node_get_angle_x(*this.raw)
}
func Node.SetAngleY(val: f32) {
	node_set_angle_y(*this.raw, val)
}
func Node.GetAngleY() => f32 {
	return node_get_angle_y(*this.raw)
}
func Node.SetScaleX(val: f32) {
	node_set_scale_x(*this.raw, val)
}
func Node.GetScaleX() => f32 {
	return node_get_scale_x(*this.raw)
}
func Node.SetScaleY(val: f32) {
	node_set_scale_y(*this.raw, val)
}
func Node.GetScaleY() => f32 {
	return node_get_scale_y(*this.raw)
}
func Node.SetX(val: f32) {
	node_set_x(*this.raw, val)
}
func Node.GetX() => f32 {
	return node_get_x(*this.raw)
}
func Node.SetY(val: f32) {
	node_set_y(*this.raw, val)
}
func Node.GetY() => f32 {
	return node_get_y(*this.raw)
}
func Node.SetZ(val: f32) {
	node_set_z(*this.raw, val)
}
func Node.GetZ() => f32 {
	return node_get_z(*this.raw)
}
func Node.SetPosition(val: Vec2) {
	node_set_position(*this.raw, val.ToValue())
}
func Node.GetPosition() => Vec2 {
	return Vec2FromValue(node_get_position(*this.raw))
}
func Node.SetSkewX(val: f32) {
	node_set_skew_x(*this.raw, val)
}
func Node.GetSkewX() => f32 {
	return node_get_skew_x(*this.raw)
}
func Node.SetSkewY(val: f32) {
	node_set_skew_y(*this.raw, val)
}
func Node.GetSkewY() => f32 {
	return node_get_skew_y(*this.raw)
}
func Node.SetVisible(val: bool) {
	node_set_visible(*this.raw, ToDoraBool(val))
}
func Node.IsVisible() => bool {
	return node_is_visible(*this.raw) != 0
}
func Node.SetAnchor(val: Vec2) {
	node_set_anchor(*this.raw, val.ToValue())
}
func Node.GetAnchor() => Vec2 {
	return Vec2FromValue(node_get_anchor(*this.raw))
}
func Node.SetWidth(val: f32) {
	node_set_width(*this.raw, val)
}
func Node.GetWidth() => f32 {
	return node_get_width(*this.raw)
}
func Node.SetHeight(val: f32) {
	node_set_height(*this.raw, val)
}
func Node.GetHeight() => f32 {
	return node_get_height(*this.raw)
}
func Node.SetSize(val: Size) {
	node_set_size(*this.raw, val.ToValue())
}
func Node.GetSize() => Size {
	return SizeFromValue(node_get_size(*this.raw))
}
func Node.SetTag(val: string) {
	node_set_tag(*this.raw, ToDoraString(val))
}
func Node.GetTag() => string {
	return FromDoraString(node_get_tag(*this.raw))
}
func Node.SetOpacity(val: f32) {
	node_set_opacity(*this.raw, val)
}
func Node.GetOpacity() => f32 {
	return node_get_opacity(*this.raw)
}
func Node.SetColor(val: Color) {
	node_set_color(*this.raw, val.ToARGB())
}
func Node.GetColor() => Color {
	return ColorFromARGB(node_get_color(*this.raw))
}
func Node.SetColor3(val: Color3) {
	node_set_color3(*this.raw, val.ToRGB())
}
func Node.GetColor3() => Color3 {
	return Color3FromRGB(node_get_color3(*this.raw))
}
func Node.SetPassOpacity(val: bool) {
	node_set_pass_opacity(*this.raw, ToDoraBool(val))
}
func Node.IsPassOpacity() => bool {
	return node_is_pass_opacity(*this.raw) != 0
}
func Node.SetPassColor3(val: bool) {
	node_set_pass_color3(*this.raw, ToDoraBool(val))
}
func Node.IsPassColor3() => bool {
	return node_is_pass_color3(*this.raw) != 0
}
func Node.SetTransformTarget(val: Node) {
	node_set_transform_target(*this.raw, val.GetRaw())
}
func Node.GetTransformTarget() => *Node {
	ptr_ := node_get_transform_target(*this.raw)
	if ptr_ == 0 {
		return nil
	}
	obj_ := *NodeFrom(ptr_)
	return &obj_
}
func Node.SetScheduler(val: Scheduler) {
	node_set_scheduler(*this.raw, val.GetRaw())
}
func Node.GetScheduler() => Scheduler {
	return *SchedulerFrom(node_get_scheduler(*this.raw))
}
func Node.GetChildren() => *Array {
	ptr_ := node_get_children(*this.raw)
	if ptr_ == 0 {
		return nil
	}
	obj_ := *ArrayFrom(ptr_)
	return &obj_
}
func Node.GetParent() => *Node {
	ptr_ := node_get_parent(*this.raw)
	if ptr_ == 0 {
		return nil
	}
	obj_ := *NodeFrom(ptr_)
	return &obj_
}
func Node.IsRunning() => bool {
	return node_is_running(*this.raw) != 0
}
func Node.IsScheduled() => bool {
	return node_is_scheduled(*this.raw) != 0
}
func Node.GetActionCount() => i32 {
	return node_get_action_count(*this.raw)
}
func Node.GetData() => Dictionary {
	return *DictionaryFrom(node_get_data(*this.raw))
}
func Node.SetTouchEnabled(val: bool) {
	node_set_touch_enabled(*this.raw, ToDoraBool(val))
}
func Node.IsTouchEnabled() => bool {
	return node_is_touch_enabled(*this.raw) != 0
}
func Node.SetSwallowTouches(val: bool) {
	node_set_swallow_touches(*this.raw, ToDoraBool(val))
}
func Node.IsSwallowTouches() => bool {
	return node_is_swallow_touches(*this.raw) != 0
}
func Node.SetSwallowMouseWheel(val: bool) {
	node_set_swallow_mouse_wheel(*this.raw, ToDoraBool(val))
}
func Node.IsSwallowMouseWheel() => bool {
	return node_is_swallow_mouse_wheel(*this.raw) != 0
}
func Node.SetKeyboardEnabled(val: bool) {
	node_set_keyboard_enabled(*this.raw, ToDoraBool(val))
}
func Node.IsKeyboardEnabled() => bool {
	return node_is_keyboard_enabled(*this.raw) != 0
}
func Node.SetControllerEnabled(val: bool) {
	node_set_controller_enabled(*this.raw, ToDoraBool(val))
}
func Node.IsControllerEnabled() => bool {
	return node_is_controller_enabled(*this.raw) != 0
}
func Node.SetRenderGroup(val: bool) {
	node_set_render_group(*this.raw, ToDoraBool(val))
}
func Node.IsRenderGroup() => bool {
	return node_is_render_group(*this.raw) != 0
}
func Node.SetShowDebug(val: bool) {
	node_set_show_debug(*this.raw, ToDoraBool(val))
}
func Node.IsShowDebug() => bool {
	return node_is_show_debug(*this.raw) != 0
}
func Node.SetRenderOrder(val: i32) {
	node_set_render_order(*this.raw, val)
}
func Node.GetRenderOrder() => i32 {
	return node_get_render_order(*this.raw)
}
func Node.AddChildWithOrderTag(child: Node, order: i32, tag: string) {
	node_add_child_with_order_tag(*this.raw, child.GetRaw(), order, ToDoraString(tag))
}
func Node.AddChildWithOrder(child: Node, order: i32) {
	node_add_child_with_order(*this.raw, child.GetRaw(), order)
}
func Node.AddChild(child: Node) {
	node_add_child(*this.raw, child.GetRaw())
}
func Node.AddToWithOrderTag(parent: Node, order: i32, tag: string) => Node {
	return *NodeFrom(node_add_to_with_order_tag(*this.raw, parent.GetRaw(), order, ToDoraString(tag)))
}
func Node.AddToWithOrder(parent: Node, order: i32) => Node {
	return *NodeFrom(node_add_to_with_order(*this.raw, parent.GetRaw(), order))
}
func Node.AddTo(parent: Node) => Node {
	return *NodeFrom(node_add_to(*this.raw, parent.GetRaw()))
}
func Node.RemoveChild(child: Node, cleanup: bool) {
	node_remove_child(*this.raw, child.GetRaw(), ToDoraBool(cleanup))
}
func Node.RemoveChildByTag(tag: string, cleanup: bool) {
	node_remove_child_by_tag(*this.raw, ToDoraString(tag), ToDoraBool(cleanup))
}
func Node.RemoveAllChildren(cleanup: bool) {
	node_remove_all_children(*this.raw, ToDoraBool(cleanup))
}
func Node.RemoveFromParent(cleanup: bool) {
	node_remove_from_parent(*this.raw, ToDoraBool(cleanup))
}
func Node.MoveToParent(parent: Node) {
	node_move_to_parent(*this.raw, parent.GetRaw())
}
func Node.Cleanup() {
	node_cleanup(*this.raw)
}
func Node.GetChildByTag(tag: string) => *Node {
	ptr_ := node_get_child_by_tag(*this.raw, ToDoraString(tag))
	if ptr_ == 0 {
		return nil
	}
	obj_ := *NodeFrom(ptr_)
	return &obj_
}
func Node.Schedule(update_func: func(delta_time: f64) => bool) {
	stack0 := NewCallStack()
	func_id0 := PushFunction(func() {
		deltaTime, _ := stack0.PopF64()
		result_ := update_func(deltaTime)
		stack0.Push(result_)
	})
	node_schedule(*this.raw, func_id0, *stack0.raw)
}
func Node.Unschedule() {
	node_unschedule(*this.raw)
}
func Node.ConvertToNodeSpace(world_point: Vec2) => Vec2 {
	return Vec2FromValue(node_convert_to_node_space(*this.raw, world_point.ToValue()))
}
func Node.ConvertToWorldSpace(node_point: Vec2) => Vec2 {
	return Vec2FromValue(node_convert_to_world_space(*this.raw, node_point.ToValue()))
}
func Node.ConvertToWindowSpace(node_point: Vec2, callback: func(result: Vec2)) {
	stack0 := NewCallStack()
	func_id0 := PushFunction(func() {
		result, _ := stack0.PopVec2()
		callback(result)
	})
	node_convert_to_window_space(*this.raw, node_point.ToValue(), func_id0, *stack0.raw)
}
func Node.EachChild(visitor_func: func(child: Node) => bool) => bool {
	stack0 := NewCallStack()
	func_id0 := PushFunction(func() {
		child := *NodeFrom(stack0.PopObject().GetRaw())
		result_ := visitor_func(child)
		stack0.Push(result_)
	})
	return node_each_child(*this.raw, func_id0, *stack0.raw) != 0
}
func Node.Traverse(visitor_func: func(child: Node) => bool) => bool {
	stack0 := NewCallStack()
	func_id0 := PushFunction(func() {
		child := *NodeFrom(stack0.PopObject().GetRaw())
		result_ := visitor_func(child)
		stack0.Push(result_)
	})
	return node_traverse(*this.raw, func_id0, *stack0.raw) != 0
}
func Node.TraverseAll(visitor_func: func(child: Node) => bool) => bool {
	stack0 := NewCallStack()
	func_id0 := PushFunction(func() {
		child := *NodeFrom(stack0.PopObject().GetRaw())
		result_ := visitor_func(child)
		stack0.Push(result_)
	})
	return node_traverse_all(*this.raw, func_id0, *stack0.raw) != 0
}
func Node.RunActionDef(def: ActionDef, looped: bool) => f32 {
	return node_run_action_def(*this.raw, def.GetRaw(), ToDoraBool(looped))
}
func Node.RunAction(action: Action, looped: bool) => f32 {
	return node_run_action(*this.raw, action.GetRaw(), ToDoraBool(looped))
}
func Node.StopAllActions() {
	node_stop_all_actions(*this.raw)
}
func Node.PerformDef(action_def: ActionDef, looped: bool) => f32 {
	return node_perform_def(*this.raw, action_def.GetRaw(), ToDoraBool(looped))
}
func Node.Perform(action: Action, looped: bool) => f32 {
	return node_perform(*this.raw, action.GetRaw(), ToDoraBool(looped))
}
func Node.StopAction(action: Action) {
	node_stop_action(*this.raw, action.GetRaw())
}
func Node.AlignItemsVertically(padding: f32) => Size {
	return SizeFromValue(node_align_items_vertically(*this.raw, padding))
}
func Node.AlignItemsVerticallyWithSize(size: Size, padding: f32) => Size {
	return SizeFromValue(node_align_items_vertically_with_size(*this.raw, size.ToValue(), padding))
}
func Node.AlignItemsHorizontally(padding: f32) => Size {
	return SizeFromValue(node_align_items_horizontally(*this.raw, padding))
}
func Node.AlignItemsHorizontallyWithSize(size: Size, padding: f32) => Size {
	return SizeFromValue(node_align_items_horizontally_with_size(*this.raw, size.ToValue(), padding))
}
func Node.AlignItems(padding: f32) => Size {
	return SizeFromValue(node_align_items(*this.raw, padding))
}
func Node.AlignItemsWithSize(size: Size, padding: f32) => Size {
	return SizeFromValue(node_align_items_with_size(*this.raw, size.ToValue(), padding))
}
func Node.MoveAndCullItems(delta: Vec2) {
	node_move_and_cull_items(*this.raw, delta.ToValue())
}
func Node.AttachIme() {
	node_attach_ime(*this.raw)
}
func Node.DetachIme() {
	node_detach_ime(*this.raw)
}
func Node.Grab() => Grabber {
	return *GrabberFrom(node_grab(*this.raw))
}
func Node.GrabWithSize(grid_x: i32, grid_y: i32) => Grabber {
	return *GrabberFrom(node_grab_with_size(*this.raw, grid_x, grid_y))
}
func Node.StopGrab() {
	node_stop_grab(*this.raw)
}
func Node.SetTransformTargetNull() {
	node_set_transform_target_null(*this.raw)
}
func Node.Slot(event_name: string, handler: func(e: CallStack)) {
	stack0 := NewCallStack()
	func_id0 := PushFunction(func() {
		e := stack0
		handler(e)
	})
	node_slot(*this.raw, ToDoraString(event_name), func_id0, *stack0.raw)
}
func Node.Gslot(event_name: string, handler: func(e: CallStack)) {
	stack0 := NewCallStack()
	func_id0 := PushFunction(func() {
		e := stack0
		handler(e)
	})
	node_gslot(*this.raw, ToDoraString(event_name), func_id0, *stack0.raw)
}
func Node.Emit(name: string, stack: CallStack) {
	node_emit(*this.raw, ToDoraString(name), stack.GetRaw())
}
func Node.OnUpdate(update_func: func(delta_time: f64) => bool) {
	stack0 := NewCallStack()
	func_id0 := PushFunction(func() {
		deltaTime, _ := stack0.PopF64()
		result_ := update_func(deltaTime)
		stack0.Push(result_)
	})
	node_on_update(*this.raw, func_id0, *stack0.raw)
}
func NewNode() => Node {
	raw := node_new()
	object := Node{}
	object.raw = &raw
	setFinalizer(object.raw, ObjectFinalizer)
	return object
}